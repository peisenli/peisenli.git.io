<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title> | 帅的如此过分</title><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><link rel="icon" href="/favicon.ico"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">空空</div><div class="author-info__description text-center">非宁静无以致远，非淡泊无以明志</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">35</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">15</span></a></div></div></div><nav class="https://i.loli.net/2019/05/12/5cd78b8a60164.jpg" id="nav" style="background-image: url(https://i.loli.net/2019/05/12/5cd78b8a60164.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">帅的如此过分</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">帅的如此过分</div><div id="site-sub-title"></div><div id="site-social-icons"> <a class="social-icon" href="https://github.com/peisenli" target="_blank"><i class="fa fa-github fab"></i></a><a class="social-icon" href="http://weibo.com/577991660" target="_blank"><i class="fa fa-weibo fab"></i></a><a class="social-icon" href="https://twitter.com/lipeisen1" target="_blank"><i class="fa fa-twitter fas"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item"><a class="article-title" href="/2019/08/13/图的基本概念/">图的基本概念</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-13 </time><div class="content"><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="  图的基本概念 "></a><center>  图的基本概念 </center></h2><p><strong>图结构特点：</strong><br>图(Graph)是一种较线性表和树更为复杂的数据结构。在线性表中，数据元素之间仅有线性关系，即每个数据元素只有一个直接前驱和一个直接后继；在树形结构中，数据元素 之间有着明显的层次关系，虽然每一层上的数据元素可能和下一层中多个元素(孩子) 相关，但只能和上一层中一个元素(双亲)相关；而在图形结构中，结点之间 的关系可以是任意的，任意两个数据元素之间都可能相关。   </p></div><a class="more" href="/2019/08/13/图的基本概念/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/12/位运算-异或/">位运算-异或</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-12 </time><div class="content"><p><strong>异或</strong>，英文为exclusive OR，缩写成xor<br>异或（xor）是一个数学运算符。它应用于逻辑运算。异或的数学符号  为“⊕”，计算机符号为“xor”。<br>其运算法则为：<br>a⊕b = (¬a ∧ b) ∨ (a ∧¬b)<br>如果a、b两个值不相同，则异或结果为1。<br>如果a、b两个值相同，异或结果为0。<br>异或也叫半加运算，其运算法则相当于不带进位的二进制加法：二进制下用1表示真，0表示假，则异或的运算法则为：<br>0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0（同为0，异为1），这些法则与加法是相同的，只是不带进位，所以异或常被认作不进位加法。<br></p></div><a class="more" href="/2019/08/12/位运算-异或/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/11/LeetCode-求数组的子集/">LeetCode-求数组的子集</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-11 </time><div class="content"><h3 id="LeetCode78-子集"><a href="#LeetCode78-子集" class="headerlink" title="LeetCode78.子集"></a>LeetCode78.子集</h3><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>说明：解集不能包含重复的子集。<br></p></div><a class="more" href="/2019/08/11/LeetCode-求数组的子集/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/10/Sort-list/">Sort-list</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-10 </time><div class="content"><p>常见的排序算法比较表如下所示：</p>
<p><center><img src="https://i.loli.net/2019/08/10/7y58PONKUuH2g4e.png" alt="1565437239(1).png"></center></p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。快速排序（Quicksort）是对冒泡排序的一种改进。<br></p></div><a class="more" href="/2019/08/10/Sort-list/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/09/Greedy-Algorithm/">Greedy Algorithm</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-09 </time><div class="content"><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。<br>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。<br>贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止。<br></p></div><a class="more" href="/2019/08/09/Greedy-Algorithm/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/07/Leetcode23-sort-K-lists/">Leetcode23_sort-K-lists</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-07 </time><div class="content"><p><center><strong>堆-合并 k 个排序链表</strong></center><br>LeetCode23-合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。<br>示例：<br>输入:<br>    [<br>          1-&gt;4-&gt;5,<br>          1-&gt;3-&gt;4,<br>          2-&gt;6<br>    ]<br>输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<br>算法思路：利用一个size为K的优先级队列，每次把K个链表的当前头的val塞进优先级队列。  </p>
<ul>
<li>首先将list中的每个链表比较首元素，然后依次加入优先队列。  </li>
<li>然后判断这个优先队列是否为空，不为空，我们弹出队首元素，接着判断这个弹出的元素作为一个链表节点，其后是否还有元素，如果有元素，将元素加入新队列中。 </li>
</ul></div><a class="more" href="/2019/08/07/Leetcode23-sort-K-lists/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/06/LeetCode-Kth-Largest/">LeetCode Kth Largest</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-06 </time><div class="content"><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br>示例 1:<br>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5<br>示例 2:<br>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4<br>说明：你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。<br>思路：对输入示例进行从大到小排序后进行输出第K大的数值即可。<br></p></div><a class="more" href="/2019/08/06/LeetCode-Kth-Largest/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/05/vaildparentheses/">vaildparentheses</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-05 </time><div class="content"><p><center><strong>栈在括号匹配中的应用问题</strong></center><br>算法思想：  </p>
<ul>
<li>初始设置一个空栈，顺序读入括号  </li>
<li>若是右括号，则使之置于栈顶的最急迫期待得以消解，或者是不合法的情况（括号序列不匹配，退出程序）  </li>
<li><p>若是左括号，则作为新的更急迫的期待压入栈中，自然使原有的在栈中的所未消解的期待解决降了一级。算法结束时，栈为空，否则括号序列不匹配。   </p></li></ul></div><a class="more" href="/2019/08/05/vaildparentheses/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/04/Mini-stack/">Mini-stack</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-04 </time><div class="content"><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。<br>push(x) – 将元素 x 推入栈中。<br>pop() – 删除栈顶的元素。<br>top() – 获取栈顶元素。<br>getMin() – 检索栈中的最小元素。<br></p></div><a class="more" href="/2019/08/04/Mini-stack/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/07/25/BiTree/">BiTree</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-07-25 </time><div class="content"><h1 id="树型结构"><a href="#树型结构" class="headerlink" title="树型结构"></a><center><strong>树型结构</strong></center></h1><ol>
<li>树的定义<br>树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：  <ul>
<li>每个节点有零个或多个子节点</li>
<li>没有父节点的节点称为根节点；</li>
<li>每一个非根节点有且只有一个父节点；</li>
<li>除了根节点外，每个子节点可以分为多个不相交的子树。</li></ul></li></ol></div><a class="more" href="/2019/07/25/BiTree/#more">阅读更多</a><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">©2016 - 2019 By 空空</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span> |  </span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span> |  </span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/fancybox.js"></script><script src="/js/sidebar.js"></script><script src="/js/copy.js"></script><script src="/js/fireworks.js"></script><script src="/js/transition.js"></script><script src="/js/scroll.js"></script><script src="/js/head.js"></script></body></html>