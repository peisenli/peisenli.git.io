<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title> | 帅的如此过分</title><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><link rel="icon" href="/favicon.ico"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">空空</div><div class="author-info__description text-center">非宁静无以致远，非淡泊无以明志</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">28</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">15</span></a></div></div></div><nav class="https://i.loli.net/2019/05/12/5cd78b8a60164.jpg" id="nav" style="background-image: url(https://i.loli.net/2019/05/12/5cd78b8a60164.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">帅的如此过分</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">帅的如此过分</div><div id="site-sub-title"></div><div id="site-social-icons"> <a class="social-icon" href="https://github.com/peisenli" target="_blank"><i class="fa fa-github fab"></i></a><a class="social-icon" href="http://weibo.com/577991660" target="_blank"><i class="fa fa-weibo fab"></i></a><a class="social-icon" href="https://twitter.com/lipeisen1" target="_blank"><i class="fa fa-twitter fas"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item"><a class="article-title" href="/2019/08/13/图的遍历问题/">图的遍历问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-13 </time><div class="content"><p>图的遍历：从图中某个顶点出发游历图，访遍图中其余顶点，并且使图中的每个顶点仅被访问一次的过程。我们可以设置一个全局型标志数组visited来标志某个顶点是否被访问过，未访问的值为0，访问过的值为1。<br></p></div><a class="more" href="/2019/08/13/图的遍历问题/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/13/LeetCode169-求众数/">LeetCode169.求众数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-13 </time><div class="content"><p>给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊n/2⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在众数。<br>示例 1:<br>输入: [3,2,3]<br>输出: 3<br>示例 2:<br>输入: [2,2,1,1,1,2,2]<br>输出: 2<br>来源：力扣（LeetCode）<br>解题思路：摩尔投票算法<br>从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，总能找到最多的那个。<br></p></div><a class="more" href="/2019/08/13/LeetCode169-求众数/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/13/图的存储结构/">图的存储结构</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-13 </time><div class="content"><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a><center>图的存储结构</center></h2><p>由于图的结构比较复杂，任意两个顶点之间都可能存在关系，因此无法以数据元素在存储区中的物理位置来表示元素之间关系，即图没有顺序映象的存储结构。<br>另一方面，用多重链表表示图是自然的事，它是一种最简单的链式映象结构，即以一个由一个数据域和多个指针域组成的结点表示图中一个顶点，其中数据域存储该顶点的信息，指针域存储指向其邻接点的指针。  </p>
<p><center><img src="https://i.loli.net/2019/08/13/YLTV6NISDibzh53.png" alt="多重.jpg"><br>图1 有向图多重链表<br><img src="https://i.loli.net/2019/08/13/MRQzS3pCLbJFoZO.png" alt="表.jpg"><br>图2 无向图的多重链表</center><br>我们一般采用一些改进的方式来存储图，常用的有邻接矩阵、邻接表和十字链表及邻接多重表等。除了要存储图中各个顶点本身的信息外，同时还要存储顶点与顶点之间的所有关系（边的信息）。存储方法的选择，取决于具体的应用。  </p></div><a class="more" href="/2019/08/13/图的存储结构/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/13/图的基本概念/">图的基本概念</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-13 </time><div class="content"><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="  图的基本概念 "></a><center>  图的基本概念 </center></h2><p><strong>图结构特点：</strong><br>图(Graph)是一种较线性表和树更为复杂的数据结构。在线性表中，数据元素之间仅有线性关系，即每个数据元素只有一个直接前驱和一个直接后继；在树形结构中，数据元素 之间有着明显的层次关系，虽然每一层上的数据元素可能和下一层中多个元素(孩子) 相关，但只能和上一层中一个元素(双亲)相关；而在图形结构中，结点之间 的关系可以是任意的，任意两个数据元素之间都可能相关。   </p></div><a class="more" href="/2019/08/13/图的基本概念/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/12/位运算-异或/">位运算-异或</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-12 </time><div class="content"><p><strong>异或</strong>，英文为exclusive OR，缩写成xor<br>异或（xor）是一个数学运算符。它应用于逻辑运算。异或的数学符号  为“⊕”，计算机符号为“xor”。<br>其运算法则为：<br>a⊕b = (¬a ∧ b) ∨ (a ∧¬b)<br>如果a、b两个值不相同，则异或结果为1。<br>如果a、b两个值相同，异或结果为0。<br>异或也叫半加运算，其运算法则相当于不带进位的二进制加法：二进制下用1表示真，0表示假，则异或的运算法则为：<br>0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0（同为0，异为1），这些法则与加法是相同的，只是不带进位，所以异或常被认作不进位加法。<br></p></div><a class="more" href="/2019/08/12/位运算-异或/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/11/LeetCode-求数组的子集/">LeetCode-求数组的子集</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-11 </time><div class="content"><h3 id="LeetCode78-子集"><a href="#LeetCode78-子集" class="headerlink" title="LeetCode78.子集"></a>LeetCode78.子集</h3><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>说明：解集不能包含重复的子集。<br></p></div><a class="more" href="/2019/08/11/LeetCode-求数组的子集/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/10/Sort-list/">Sort-list</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-10 </time><div class="content"><p>常见的排序算法比较表如下所示：</p>
<p><center><img src="https://i.loli.net/2019/08/10/7y58PONKUuH2g4e.png" alt="1565437239(1).png"></center></p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。快速排序（Quicksort）是对冒泡排序的一种改进。<br></p></div><a class="more" href="/2019/08/10/Sort-list/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/09/Greedy-Algorithm/">Greedy Algorithm</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-09 </time><div class="content"><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。<br>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。<br>贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止。<br></p></div><a class="more" href="/2019/08/09/Greedy-Algorithm/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/07/Leetcode23-sort-K-lists/">Leetcode23_sort-K-lists</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-07 </time><div class="content"><p><center><strong>堆-合并 k 个排序链表</strong></center><br>LeetCode23-合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。<br>示例：<br>输入:<br>    [<br>          1-&gt;4-&gt;5,<br>          1-&gt;3-&gt;4,<br>          2-&gt;6<br>    ]<br>输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<br>算法思路：利用一个size为K的优先级队列，每次把K个链表的当前头的val塞进优先级队列。  </p>
<ul>
<li>首先将list中的每个链表比较首元素，然后依次加入优先队列。  </li>
<li>然后判断这个优先队列是否为空，不为空，我们弹出队首元素，接着判断这个弹出的元素作为一个链表节点，其后是否还有元素，如果有元素，将元素加入新队列中。 </li>
</ul></div><a class="more" href="/2019/08/07/Leetcode23-sort-K-lists/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/06/LeetCode-Kth-Largest/">LeetCode Kth Largest</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-06 </time><div class="content"><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br>示例 1:<br>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5<br>示例 2:<br>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4<br>说明：你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。<br>思路：对输入示例进行从大到小排序后进行输出第K大的数值即可。<br></p></div><a class="more" href="/2019/08/06/LeetCode-Kth-Largest/#more">阅读更多</a><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">©2016 - 2019 By 空空</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span> |  </span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span> |  </span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/fancybox.js"></script><script src="/js/sidebar.js"></script><script src="/js/copy.js"></script><script src="/js/fireworks.js"></script><script src="/js/transition.js"></script><script src="/js/scroll.js"></script><script src="/js/head.js"></script></body></html>