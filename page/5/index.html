<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title> | Paysonly</title><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><link rel="icon" href="/favicon.ico"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/"></div><div class="author-info__name text-center">Kong</div><div class="author-info__description text-center">非宁静无以致远，非淡泊无以明志</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">51</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">18</span></a></div></div></div><nav class="https://paysonly.oss-cn-chengdu.aliyuncs.com/img/qiuqiudazuozhan.jpg" id="nav" style="background-image: url(https://paysonly.oss-cn-chengdu.aliyuncs.com/img/qiuqiudazuozhan.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Paysonly</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">Paysonly</div><div id="site-sub-title"></div><div id="site-social-icons"> <a class="social-icon" href="https://github.com/peisenli" target="_blank"><i class="fa fa-github fab"></i></a><a class="social-icon" href="http://weibo.com/577991660" target="_blank"><i class="fa fa-weibo fab"></i></a><a class="social-icon" href="https://twitter.com/Peisen_CHN" target="_blank"><i class="fa fa-twitter fas"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item"><a class="article-title" href="/2019/08/09/Greedy-Algorithm/">Greedy Algorithm</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-09 </time><div class="content"><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。<br>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。<br>贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止。<br></p></div><a class="more" href="/2019/08/09/Greedy-Algorithm/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/07/Leetcode23-sort-K-lists/">Leetcode23_sort-K-lists</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-07 </time><div class="content"><p><center><strong>堆-合并 k 个排序链表</strong></center><br>LeetCode23-合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。<br>示例：<br>输入:<br>    [<br>          1-&gt;4-&gt;5,<br>          1-&gt;3-&gt;4,<br>          2-&gt;6<br>    ]<br>输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<br>算法思路：利用一个size为K的优先级队列，每次把K个链表的当前头的val塞进优先级队列。  </p>
<ul>
<li>首先将list中的每个链表比较首元素，然后依次加入优先队列。  </li>
<li>然后判断这个优先队列是否为空，不为空，我们弹出队首元素，接着判断这个弹出的元素作为一个链表节点，其后是否还有元素，如果有元素，将元素加入新队列中。 </li>
</ul></div><a class="more" href="/2019/08/07/Leetcode23-sort-K-lists/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/06/LeetCode-Kth-Largest/">LeetCode Kth Largest</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-06 </time><div class="content"><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br>示例 1:<br>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5<br>示例 2:<br>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4<br>说明：你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。<br>思路：对输入示例进行从大到小排序后进行输出第K大的数值即可。<br></p></div><a class="more" href="/2019/08/06/LeetCode-Kth-Largest/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/05/vaildparentheses/">vaildparentheses</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-05 </time><div class="content"><p><center><strong>栈在括号匹配中的应用问题</strong></center><br>算法思想：  </p>
<ul>
<li>初始设置一个空栈，顺序读入括号  </li>
<li>若是右括号，则使之置于栈顶的最急迫期待得以消解，或者是不合法的情况（括号序列不匹配，退出程序）  </li>
<li><p>若是左括号，则作为新的更急迫的期待压入栈中，自然使原有的在栈中的所未消解的期待解决降了一级。算法结束时，栈为空，否则括号序列不匹配。   </p></li></ul></div><a class="more" href="/2019/08/05/vaildparentheses/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/04/Mini-stack/">Mini-stack</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-04 </time><div class="content"><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。<br>push(x) – 将元素 x 推入栈中。<br>pop() – 删除栈顶的元素。<br>top() – 获取栈顶元素。<br>getMin() – 检索栈中的最小元素。<br></p></div><a class="more" href="/2019/08/04/Mini-stack/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/07/25/BiTree/">BiTree</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-20 </time><div class="content"><h1 id="树型结构"><a href="#树型结构" class="headerlink" title="树型结构"></a><center><strong>树型结构</strong></center></h1><ol>
<li>树的定义<br>树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：  <ul>
<li>每个节点有零个或多个子节点</li>
<li>没有父节点的节点称为根节点；</li>
<li>每一个非根节点有且只有一个父节点；</li>
<li>除了根节点外，每个子节点可以分为多个不相交的子树。</li></ul></li></ol></div><a class="more" href="/2019/07/25/BiTree/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/07/25/Node2Vec/">Node2Vec</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-07-25 </time><div class="content"><h1 id="Node2Vec-Scalable-Feature-Learning-for-Networks"><a href="#Node2Vec-Scalable-Feature-Learning-for-Networks" class="headerlink" title=" Node2Vec: Scalable Feature Learning for Networks "></a><center> Node2Vec: Scalable Feature Learning for Networks </center></h1><p><strong>核心内容</strong>：Node2Vec是论文Scalable Feature Learning for Networks提出的一种对网络中的节点学习连续特征表达的框架。通过将节点映射到maximizes the likelihood of preserving network neighborhoods of nodes的低维特征空间。定义了一个目标函数来保存节点的局部邻居结构是一种方法。论文的目标是提出一个灵活的学习节点表示的算法，既能将属于相同的社区的节点学习得到相近的嵌入；又能对有相似功能的节点（如在社区中的连接结构相似）学得相似的嵌入。借鉴Word2Vec提出了Node2Vec，并利用二阶随机游走产生节点社区。<br></p></div><a class="more" href="/2019/07/25/Node2Vec/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/07/13/The-application-of-machine-learning-in-network-security/">The application of machine learning in network security</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-07-22 </time><div class="content"><h2 id="机器学习在网络安全中的应用综述"><a href="#机器学习在网络安全中的应用综述" class="headerlink" title="机器学习在网络安全中的应用综述"></a><center>机器学习在网络安全中的应用综述</center></h2><p>摘要：随着互联网人口在线人数的增长，在互联网背景下各行业爆发了很多问题，例如信息的加密和治理，可疑的营销信息，特别是网络安全问题不断的锐化。机器学习和人工智能的诞生，对网络发展既是机遇也是挑战，它用于搜索引擎，图像分类，语音识别等，而利用网络上的安全问题融合机器学习算法，成为网络安全技术的一个新的研究领域，利用机器学习得到的模型和方法，对网络安全攻击行为自动进行判断和预测，进而进行防御，是非常具有利用前景和使用价值，本文是对当前机器学习在网络安全中的不同应用进行总结和概述。<br>关键词：机器学习 网络安全 入侵防御<br>Abstract: with the growth of the number of Internet online population, in the context of the Internet industry broke out a lot of problems, such as the encryption and governance of information, suspicious marketing information, especially the sharpening of network security issues. The birth of machine learning and artificial intelligence, is both opportunity and challenge of network development, which is used to search engine, image classification, speech recognition, etc., and the use of machine learning algorithm on the network security problem fusion, become a new research field of network security technology, using machine learning model and method of judgment and projections for network security attacks automatically, and defend, is very has the advantage of future and use value, this article is for the current machine learning summarize its application in network security.<br>Key words: machine learning; network security; defense<br></p></div><a class="more" href="/2019/07/13/The-application-of-machine-learning-in-network-security/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/05/11/MPI-Programming-Project/">MPI Programming Project</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-07-13 </time><div class="content"><p>一、实验目的<br>1、掌握分布式并行计算基础<br>2、掌握MPI分布式并行基本操作<br>3、利用MPI进行程序设计，寻找1000000000以内的素数<br>二、实验环境<br>PC、Ubuntu16.04、MPICH<br>三、实验要求<br>Part 1: Modify the parallel Sieve of Eratosthenes program in class so that the program  does NOT set aside memory for even integers.<br></p></div><a class="more" href="/2019/05/11/MPI-Programming-Project/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/05/11/Chat-based-on-Socket/">Chat based on Socket</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-07-13 </time><div class="content"><p>套接字库加载：<br>Socket socket=new Socket();<br>ServerSocket server=new ServerSocket();<br></p></div><a class="more" href="/2019/05/11/Chat-based-on-Socket/#more">阅读更多</a><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">©2016 - 2020 By Kong</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span> |  </span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span> |  </span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/fancybox.js"></script><script src="/js/sidebar.js"></script><script src="/js/copy.js"></script><script src="/js/fireworks.js"></script><script src="/js/transition.js"></script><script src="/js/scroll.js"></script><script src="/js/head.js"></script></body></html>