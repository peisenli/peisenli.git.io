<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title> | Paysonly</title><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><link rel="icon" href="/favicon.ico"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/"></div><div class="author-info__name text-center">Kong</div><div class="author-info__description text-center">非宁静无以致远，非淡泊无以明志</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">53</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">19</span></a></div></div></div><nav class="https://paysonly.oss-cn-chengdu.aliyuncs.com/img/qiuqiudazuozhan.jpg" id="nav" style="background-image: url(https://paysonly.oss-cn-chengdu.aliyuncs.com/img/qiuqiudazuozhan.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Paysonly</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">Paysonly</div><div id="site-sub-title"></div><div id="site-social-icons"> <a class="social-icon" href="https://github.com/peisenli" target="_blank"><i class="fa fa-github fab"></i></a><a class="social-icon" href="http://weibo.com/577991660" target="_blank"><i class="fa fa-weibo fab"></i></a><a class="social-icon" href="https://twitter.com/Peisen_CHN" target="_blank"><i class="fa fa-twitter fas"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item"><a class="article-title" href="/2019/08/19/LeetCode230-二叉搜索树中第k小的元素/">LeetCode230-二叉搜索树中第k小的元素</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-08 </time><div class="content"><p>给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。<br>说明：<br>你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。<br>示例 1:<br>输入: root = [3,1,4,null,2], k = 1  </p>
<pre><code>  3
 / \
1   4
 \
  2
</code></pre><p>输出: 1<br>示例 2:<br>输入: root = [5,3,6,2,4,null,null,1], k = 3  </p>
<pre><code>      5
     / \
    3   6
   / \
  2   4
 /
1
</code></pre><p>输出: 3<br>进阶：<br>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？<br>思路分析：利用“二叉搜索树”在“中序遍历”以后，得到的是有序数组，那么我们就中序遍历好了，遍历到第k个数即可。<br></p></div><a class="more" href="/2019/08/19/LeetCode230-二叉搜索树中第k小的元素/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/18/LeetCode124-二叉树中最大路径和/">LeetCode124-二叉树中最大路径和</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-08 </time><div class="content"><p>给定一个非空二叉树，返回其最大路径和。</p>
<p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p>
<p>示例 1:</p>
<p>输入: [1,2,3]</p>
<pre><code>  1
 / \
2   3
</code></pre><p>输出: 6</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-maximum-path-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br></p></div><a class="more" href="/2019/08/18/LeetCode124-二叉树中最大路径和/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/16/LeetCode104-二叉树的最大深度/">LeetCode104-二叉树的最大深度</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-08 </time><div class="content"><p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。<br>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，  </p>
<pre><code>  3  
 / \  
9  20  
  /  \  
 15   7  
</code></pre><p>返回它的最大深度 3 。<br></p></div><a class="more" href="/2019/08/16/LeetCode104-二叉树的最大深度/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/14/LeetCode231-2的幂/">LeetCode231-2的幂</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-08 </time><div class="content"><p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。<br>示例 1:<br>输入: 1<br>输出: true<br>解释: 20 = 1<br>示例 2:<br>输入: 16<br>输出: true<br>解释: 24 = 16<br>示例 3:<br>输入: 218<br>输出: false<br></p></div><a class="more" href="/2019/08/14/LeetCode231-2的幂/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/13/图的遍历代码/">图的遍历代码</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-08 </time><div class="content"><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>1.准备工作：创建一个visited数组，用来记录已被访问过的顶点；创建一个队列，用来存放每一层的顶点；初始化图G。<br>2.从图中的v0开始访问，将的visited[v0]数组的值设置为true，同时将v0入队。<br>3.只要队列不空，则重复如下操作：<br>(1)队头顶点u出队。<br>(2)依次检查u的所有邻接顶点w，若visited[w]的值为false，则访问w，并将visited[w]置为true，同时将w入队。<br></p></div><a class="more" href="/2019/08/13/图的遍历代码/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/13/图的遍历问题/">图的遍历问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-08 </time><div class="content"><p>图的遍历：从图中某个顶点出发游历图，访遍图中其余顶点，并且使图中的每个顶点仅被访问一次的过程。我们可以设置一个全局型标志数组visited来标志某个顶点是否被访问过，未访问的值为0，访问过的值为1。<br></p></div><a class="more" href="/2019/08/13/图的遍历问题/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/13/LeetCode169-求众数/">LeetCode169.求众数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-08 </time><div class="content"><p>给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊n/2⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在众数。<br>示例 1:<br>输入: [3,2,3]<br>输出: 3<br>示例 2:<br>输入: [2,2,1,1,1,2,2]<br>输出: 2<br>来源：力扣（LeetCode）<br>解题思路：摩尔投票算法<br>从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，总能找到最多的那个。<br></p></div><a class="more" href="/2019/08/13/LeetCode169-求众数/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/13/图的存储结构/">图的存储结构</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-08 </time><div class="content"><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a><center>图的存储结构</center></h2><p>由于图的结构比较复杂，任意两个顶点之间都可能存在关系，因此无法以数据元素在存储区中的物理位置来表示元素之间关系，即图没有顺序映象的存储结构。<br>另一方面，用多重链表表示图是自然的事，它是一种最简单的链式映象结构，即以一个由一个数据域和多个指针域组成的结点表示图中一个顶点，其中数据域存储该顶点的信息，指针域存储指向其邻接点的指针。  </p>
<p><center><img src="https://i.loli.net/2019/08/13/YLTV6NISDibzh53.png" alt="多重.jpg"><br>图1 有向图多重链表<br><img src="https://i.loli.net/2019/08/13/MRQzS3pCLbJFoZO.png" alt="表.jpg"><br>图2 无向图的多重链表</center><br>我们一般采用一些改进的方式来存储图，常用的有邻接矩阵、邻接表和十字链表及邻接多重表等。除了要存储图中各个顶点本身的信息外，同时还要存储顶点与顶点之间的所有关系（边的信息）。存储方法的选择，取决于具体的应用。  </p></div><a class="more" href="/2019/08/13/图的存储结构/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/13/图的基本概念/">图的基本概念</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-08 </time><div class="content"><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="  图的基本概念 "></a><center>  图的基本概念 </center></h2><p><strong>图结构特点：</strong><br>图(Graph)是一种较线性表和树更为复杂的数据结构。在线性表中，数据元素之间仅有线性关系，即每个数据元素只有一个直接前驱和一个直接后继；在树形结构中，数据元素 之间有着明显的层次关系，虽然每一层上的数据元素可能和下一层中多个元素(孩子) 相关，但只能和上一层中一个元素(双亲)相关；而在图形结构中，结点之间 的关系可以是任意的，任意两个数据元素之间都可能相关。   </p></div><a class="more" href="/2019/08/13/图的基本概念/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/08/12/位运算-异或/">位运算-异或</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-08 </time><div class="content"><p><strong>异或</strong>，英文为exclusive OR，缩写成xor<br>异或（xor）是一个数学运算符。它应用于逻辑运算。异或的数学符号  为“⊕”，计算机符号为“xor”。<br>其运算法则为：<br>a⊕b = (¬a ∧ b) ∨ (a ∧¬b)<br>如果a、b两个值不相同，则异或结果为1。<br>如果a、b两个值相同，异或结果为0。<br>异或也叫半加运算，其运算法则相当于不带进位的二进制加法：二进制下用1表示真，0表示假，则异或的运算法则为：<br>0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0（同为0，异为1），这些法则与加法是相同的，只是不带进位，所以异或常被认作不进位加法。<br></p></div><a class="more" href="/2019/08/12/位运算-异或/#more">阅读更多</a><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">©2016 - 2021 By Kong</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span> |  </span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span> |  </span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/fancybox.js"></script><script src="/js/sidebar.js"></script><script src="/js/copy.js"></script><script src="/js/fireworks.js"></script><script src="/js/transition.js"></script><script src="/js/scroll.js"></script><script src="/js/head.js"></script></body></html>