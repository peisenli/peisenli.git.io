<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>BiTree | 空空学长</title><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><link rel="icon" href="/favicon.ico"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#树型结构"><span class="toc-number">1.</span> <span class="toc-text">树型结构</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/"></div><div class="author-info__name text-center">空空</div><div class="author-info__description text-center">非宁静无以致远，非淡泊无以明志</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">53</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">19</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://paysonly.oss-cn-chengdu.aliyuncs.com/img/qiuqiudazuozhan.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">空空学长</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">BiTree</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-08 </time></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><h1 id="树型结构"><a href="#树型结构" class="headerlink" title="树型结构"></a><center><strong>树型结构</strong></center></h1><ol>
<li>树的定义<br>树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：  <ul>
<li>每个节点有零个或多个子节点</li>
<li>没有父节点的节点称为根节点；</li>
<li>每一个非根节点有且只有一个父节点；</li>
<li>除了根节点外，每个子节点可以分为多个不相交的子树。<a id="more"></a>  </li>
</ul>
</li>
<li>树的基本术语<br>若一个结点有子树，那么该结点称为子树根的”双亲”，子树的根是该结点的”孩子”。有相同双亲的结点互为”兄弟”。一个结点的所有子树上的任何结点都是该结点的后裔。从根结点到某个结点的路径上的所有结点都是该结点的祖先。<br>结点的度：结点拥有的子树的数目。<br>叶子：度为零的结点。<br>分支结点：度不为零的结点。<br>树的度：树中结点的最大的度。<br>层次：根结点的层次为1，其余结点的层次等于该结点的双亲结点的层次加1。<br>树的高度：树中结点的最大层次。<br>无序树：如果树中结点的各子树之间的次序是不重要的，可以交换位置。<br>有序树：如果树中结点的各子树之间的次序是重要的, 不可以交换位置。<br>森林：0个或多个不相交的树组成。对森林加上一个根，森林即成为树；删去根，树即成为森林。   </li>
<li>树的性质<ul>
<li>树中的结点数等于所有结点度数加1;</li>
<li>度为m的树中第i层上至多有m^(i-1)个结点（i&gt;=1）;</li>
<li>高度为h的m叉树至多有（m^h-1）/(m-1)个节点；</li>
<li>具有n个结点的m叉树的最小高度为logm(n(m-1)+1)的上界；    </li>
</ul>
</li>
<li>完全二叉树——若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。</li>
<li>满二叉树——除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。</li>
<li>平衡二叉树——平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。<br><img src="https://i.loli.net/2019/07/25/5d3960b20c6ad20993.jpg" alt="Cache_43cc6ab39bd2379b..jpg"><center>数据结构树形结构思维导图</center>  
</li>
</ol>
<hr>
<p>##<strong>二叉树</strong>##</p>
<ol>
<li><p>二叉树的定义<br> 二叉树是每个节点最多有两个子树的树结构。它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；或者左、右子树皆为空。  </p>
</li>
<li><p>二叉树的性质<br> 二叉树有以下几个性质：TODO(上标和下标)<br> 性质1：二叉树第i层上的结点数目最多为 2^(i-1) (i≥1)。<br> 性质2：深度为k的二叉树至多有2^k-1个结点(k≥1)。<br> 性质3：包含n个结点的二叉树的高度至少为log2(n+1)。<br> 性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1。  </p>
</li>
<li><p>二叉树存储结构</p>
<ul>
<li>顺序存储：采用数组的方式进行存储</li>
<li><p>链式存储：包括三个域：数据域data、左指针域lchild和右指针域rchild;<br><code>typedef struct node<br>{</code></p>
<p> ElemType data;</p>
<pre><code>struct node *lchild,*rchild; 
</code></pre><p>}BTNode;<br></p>
</li>
</ul>
</li>
<li><p>二叉树的遍历<br>二叉树的遍历本质上是将一个复杂的非线性结构转换为线性结构，使每个结点都有了唯一前驱和后继（第一个结点无前驱，最后一个结点无后继）。对于二叉树的一个结点，查找其左右子女是方便的，其前驱后继只有在遍历中得到。为了容易找到前驱和后继，有两种方法。一是在结点结构中增加向前和向后的指针，这种方法增加了存储开销，不可取；二是利用二叉树的空链指针。  </p>
<ul>
<li><p>前序遍历:若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。<br><code><br>void preScanf(TreeNode* t)<br>{<br>if (t == NULL)<br>{  </code></p>
<p>  return;<br>}<br>cout &lt;&lt; t-&gt;val &lt;&lt;” “;<br>preScanf(t-&gt;left);<br>preScanf(t-&gt;right);<br>}  </p>
</li>
<li><p>中序遍历:若二叉树为空，则空操作返回，否则从根结点开始，先中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。<br><code><br>//中序遍历二叉树：左—根—右<br>void middleScanf(TreeNode* t)<br>{<br>if (t == NULL)<br>{   </code></p>
<p>  return;<br>}<br>middleScanf(t-&gt;left);<br>cout &lt;&lt; t-&gt;val &lt;&lt; “ “;<br>middleScanf(t-&gt;right);<br>}  </p>
</li>
<li><p>后序遍历：若二叉树为空，则空操作返回，否则从根结点开始，先后序遍历根结点的左子树，再后序遍历根结点的右子树，最后访问根结点。<br><code>//后序遍历二叉树：左—右—根<br>void backScanf(TreeNode* t)<br>{<br>if (t == NULL)<br>{  </code></p>
<p>  return;<br>}<br>backScanf(t-&gt;left);<br>backScanf(t-&gt;right);<br>cout &lt;&lt; t-&gt;val &lt;&lt;” “;<br>}  <br>-层次遍历： 若二叉树为空，则空操作返回，否则从二叉树的第一层也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。代码思路讲解：若要实现按层遍历，那么应该先访问根结点，然后再访问遍历结点的两个子节点，放入容器，按照从左到右的顺序遍历到左子节点时就把其的两个子节点放到容器，最后输出的时候，就是从容器中按照顺序输出，先进先出，所以想到可以用队列做为数据容器。从上到下打印二叉树的规律：每一次打印一个节点的时候，如果该结点有子结点，则把该结点的子结点放到一个队列的末尾，接下来从队列的头部取出最早进入队列的结点，重复输出，直至队列中所有结点都被打印出来。<br><code>//层序遍历二叉树：从上到下，从左到右<br>void fromTopToBottomScanf(TreeNode<em> t)<br>{<br>if (t==NULL)<br>{<br>  return;<br>}<br>deque&lt;TreeNode</em>&gt; dequeTreeNode;<br>dequeTreeNode.push_back(t);<br>while (dequeTreeNode.size())<br>{<br>  TreeNode* pNode = dequeTreeNode.front(); //依次取出队列中的头部元素进行打印<br>  dequeTreeNode.pop_front(); //<br>  cout &lt;&lt; pNode-&gt;val &lt;&lt; “ “;<br>  if (pNode-&gt;left)<br>  {  </code></p>
<pre><code>dequeTreeNode.push_back(pNode-&gt;left);  
</code></pre><p>  }<br>  if (pNode-&gt;right)<br>  {</p>
<pre><code>dequeTreeNode.push_back(pNode-&gt;right);  
</code></pre><p>  }<br>}<br>}  </p>
</li>
</ul>
</li>
<li><p>线索二叉树<br>在二叉树的结点上加上线索的二叉树称为线索二叉树，对二叉树以某种遍历方式（如先序、中序、后序或层次等）进行遍历，使其变为线索二叉树的过程称为对二叉树进行线索化。<br>对于n个结点的二叉树，在二叉链存储结构中有n+1个空链域，利用这些空链域存放在某种遍历次序下该结点的前驱结点和后继结点的指针，这些指针称为线索，加上线索的二叉树称为线索二叉树。<br>这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种。<br>线索二叉树中的线索能记录每个结点前驱和后继信息。为了区别线索指针和孩子指针，在每个结点中设置两个标志ltag和rtag。<br>当tag和rtag为0时，leftChild和rightChild分别是指向左孩子和右孩子的指针；否则，leftChild是指向结点前驱的线索(pre)，rightChild是指向结点的后继线索(suc)。由于标志只占用一个二进位，每个结点所需要的存储空间节省很多。<br>现将二叉树的结点结构重新定义如下：lchild、ltag、data、rtag、rchild；其中：ltag=0 时lchild指向左儿子；ltag=1 时lchild指向前驱；rtag=0 时rchild指向右儿子；rtag=1 时rchild指向后继。</p>
</li>
</ol>
<hr>
</div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Tree/">Tree</a></div></article><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/08/04/Mini-stack/"><i class="fa fa-chevron-left">  </i><span>Mini-stack</span></a></div><div class="next-post pull-right"><a href="/2019/07/25/Node2Vec/"><span>Node2Vec</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">©2016 - 2021 By 空空</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span> |  </span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/fancybox.js"></script><script src="/js/sidebar.js"></script><script src="/js/copy.js"></script><script src="/js/fireworks.js"></script><script src="/js/transition.js"></script><script src="/js/scroll.js"></script><script src="/js/head.js"></script></body></html>