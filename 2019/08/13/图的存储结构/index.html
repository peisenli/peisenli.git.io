<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>图的存储结构 | 帅的如此过分</title><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><link rel="icon" href="/favicon.ico"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#图的存储结构"><span class="toc-number">1.</span> <span class="toc-text">图的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#邻接矩阵"><span class="toc-number">1.1.</span> <span class="toc-text">邻接矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#邻接表"><span class="toc-number">1.2.</span> <span class="toc-text">邻接表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#十字链表"><span class="toc-number">1.3.</span> <span class="toc-text">十字链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多重链表"><span class="toc-number">1.4.</span> <span class="toc-text">多重链表</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">空空</div><div class="author-info__description text-center">非宁静无以致远，非淡泊无以明志</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">27</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">15</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2019/05/12/5cd78b8a60164.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">帅的如此过分</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">图的存储结构</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-13 </time></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a><center>图的存储结构</center></h2><p>由于图的结构比较复杂，任意两个顶点之间都可能存在关系，因此无法以数据元素在存储区中的物理位置来表示元素之间关系，即图没有顺序映象的存储结构。<br>另一方面，用多重链表表示图是自然的事，它是一种最简单的链式映象结构，即以一个由一个数据域和多个指针域组成的结点表示图中一个顶点，其中数据域存储该顶点的信息，指针域存储指向其邻接点的指针。  </p>
<p><center><img src="https://i.loli.net/2019/08/13/YLTV6NISDibzh53.png" alt="多重.jpg"><br>图1 有向图多重链表<br><img src="https://i.loli.net/2019/08/13/MRQzS3pCLbJFoZO.png" alt="表.jpg"><br>图2 无向图的多重链表</center><br>我们一般采用一些改进的方式来存储图，常用的有邻接矩阵、邻接表和十字链表及邻接多重表等。除了要存储图中各个顶点本身的信息外，同时还要存储顶点与顶点之间的所有关系（边的信息）。存储方法的选择，取决于具体的应用。  </p>
<a id="more"></a>
<hr>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>在邻接矩阵表示中，除了存放顶点本身信息外，还用一个矩阵表示各个顶点之间的关系。若(i,j)∈E(G)或&lt;i,j&gt;∈E(G),则矩阵中第i行 第j列元素值为1，否则为0 。<br><strong>无向图：  </strong>  </p>
<p><center><img src="https://i.loli.net/2019/08/13/eo1HNckBwgzQDiM.png" alt="邻阶矩阵.jpg"><br>图3 无向图的邻接矩阵表示</center><br>分析1：无向图的邻接矩阵是对称的；<br>分析2：顶点i 的度＝第 i 行 (列) 中1 的个数；<br>特别：完全图的邻接矩阵中，对角元素为0，其余1。<br>结论：<br>（1）矩阵是对称的，可压缩存储(上(下)三角);<br>（2）第i行或第i 列中1的个数为顶点i 的度;<br>（3）矩阵中1的个数的一半为图中边的数目;<br>（4）很容易判断顶点i和顶点j之间是否有边相连(看矩阵中i行j列值是否为1)。   </p>
<hr>
<p><strong>有向图：</strong>  </p>
<p><center><img src="https://i.loli.net/2019/08/13/jsqWJYnwrG9HM3X.png" alt="1565661031(1).jpg"><br>有向图的邻接矩阵表示</center><br>分析1：有向图的邻接矩阵可能是不对称的。<br>分析2：顶点的出度=第i行元素之和，顶点的入度=第i列元素之和，顶点的度=第i行元素之和+第i列元素之和。<br>结论：<br>（1） 矩阵不一定是对称的;<br>（2） 第i 行中1的个数为顶点i 的出度;<br>（3） 第i列中1的个数为顶点 i的入度;<br>（4） 矩阵中1的个数为图中弧的数目;<br>（5） 很容易判断顶点i 和顶点j 是否有弧相连.<br>邻接矩阵法优点：<br>容易实现图的操作，如：求某顶点的度、判断顶点之间是否有边（弧）、找顶点的邻接点等等。<br>邻接矩阵法缺点：<br>n个顶点需要n*n个单元存储边(弧);空间效率为O(n2)。 对稀疏图而言尤其浪费空间。</p>
<pre><code>#define INFINITE 9999       /* 假设的无穷大数 */
void  creatadj(int n,int e,int t) /*n为顶点数,e为边数,t为1~4,分别表示无向图、有向图、带权无向图、带权有向图*/
{  
    int i,j,k,w;
    for(i=1;i&lt;=n;i++)
     {  
        printf(“输入第%d顶点信息”,i);
        v[i]=getchar();  
    }
    for(i=1;i&lt;=n;i++)
          for(j=1;j&lt;=n;j++)
            if(t&gt;2) 
                A[i][j]=INFINITE;
            else     
                A[i][j]=0;  
    for(k=1;k&lt;=e;k++)
     {  
        scanf(“%d,%d”,&amp;i,&amp;j);
         if(i&gt;n ||j&gt;n)  exit(0);
         if(t&gt;2)    
        {     
            scanf(“%d”,&amp;w);
            A[i][j]=w;
               if(t==3) A[j][i]=w;  
        }
        else         
        { 
            A[i][j]=1;
            if(t==1)  A[j][i]=1;  
        } 
     }
} 
</code></pre><hr>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>图的邻接表存储方法是一种顺序分配与链式分配相结合的存储方法，它包括两部分：一部分是单链表，用来存放边的信息；另一部分是数组，主要用来存放顶点本身的数据信息。<br><strong>有向图：</strong>  </p>
<p><center><img src="https://i.loli.net/2019/08/13/sz1qmV6A5EdBNKb.png" alt="1565662180(1).jpg"><br>有向图的邻接表表示</center><br>出度：OD(Vi)＝单链出边表中链接的结点数<br>入度：ID(Vi)＝邻接点域为Vi的弧个数<br>结论：<br>（1）第i 个链表中结点数目为顶点i的出度；<br>（2）所有链表中结点数目为图中弧数；<br>（3）占用的存储单元数目为n+e 。<br><strong>无向图：</strong>  </p>
<p><center><img src="https://i.loli.net/2019/08/13/9MOj6Fop7kiV1qG.png" alt="1565662132(1).jpg"><br>无向图的邻接表表示</center><br>注：邻接表不唯一，因各个边结点的链入顺序是任意的<br>空间效率为O(n+2e)。<br>若是稀疏图(e&lt;&lt;n2)，比邻接矩阵表示法O(n2)省空间。<br>结论：<br>（1）第i 个链表中结点数目为顶点i的度；<br>（2）所有链表中结点数目的一半为图中边数；<br>（3）占用的存储单元数目为n+2e 。<br><strong>邻接表优缺点：</strong><br>优：空间效率高；容易寻找顶点的邻接点；<br>缺：判断两顶点间是否有边或弧，需搜索两结点对应的单链表，没有邻接矩阵方便。<br><strong>与邻接矩阵对比：</strong><br>① 对于任一确定的无向图，邻接矩阵是唯一的（行列号与顶点编号一致），但邻接表不唯一（链接次序与顶点编号无关）。<br>② 邻接矩阵的空间复杂度为O(n2),而邻接表的空间复杂度为O(n+e)。<br>③ 邻接矩阵多用于稠密图；而邻接表多用于稀疏图</p>
<h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p>C语言实现及定义：<br><img src="https://i.loli.net/2019/08/13/fT7IYKbRoOXiqQN.png" width="250" hegiht="100" align="left">  </p>
<pre><code>弧结点：
typedef  struct  arcnode
{   
    int   tailvex,  headvex;        //弧尾、弧头在表头数组中位置
     struct   arcnode   *hlink；//指向弧头相同的下一条弧
     struct   arcnode   *tlink;    //指向弧尾相同的下一条弧
}AD;    
顶点结点：
typedef  struct  dnode
{   
    int   data;  //存与顶点有关信息
     struct   arcnode   *firstin；//指向以该顶点为弧头的第一个弧结点
     struct   arcnode   *firstout; //指向以该顶点为弧尾的第一个弧结点
}DD;
</code></pre><h3 id="多重链表"><a href="#多重链表" class="headerlink" title="多重链表"></a>多重链表</h3><p>C语言实现及定义：<br><img src="https://i.loli.net/2019/08/13/tEPCrjLlOzBwXY5.png" width="250" hegiht="200" align="left">  </p>
<pre><code>边结点：
typedef   struct  node
{   
    int  mark;   //标志域
     int  ivex, jvex;  //该边依附的两个顶点在表头数组中位置
     struct  node   *ilink,  *jlink;  //分别指向依附于ivex和jvex的下一条边
}JD;
顶点结点：
typedef   struct  dnode
{    
    int   data;   //存与顶点有关的信息
    struct   node  *firstedge;  //指向第一条依附于该顶点的边
}DD;
</code></pre></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Data-Struct/">Data Struct</a></div></article><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/08/13/LeetCode169-求众数/"><i class="fa fa-chevron-left">  </i><span>LeetCode169.求众数</span></a></div><div class="next-post pull-right"><a href="/2019/08/13/图的基本概念/"><span>图的基本概念</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">©2016 - 2019 By 空空</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span> |  </span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/fancybox.js"></script><script src="/js/sidebar.js"></script><script src="/js/copy.js"></script><script src="/js/fireworks.js"></script><script src="/js/transition.js"></script><script src="/js/scroll.js"></script><script src="/js/head.js"></script></body></html>