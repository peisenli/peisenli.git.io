<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>帅的如此过分</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://peisenli.github.io/"/>
  <updated>2019-08-13T07:22:31.705Z</updated>
  <id>http://peisenli.github.io/</id>
  
  <author>
    <name>空空</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图的遍历问题</title>
    <link href="http://peisenli.github.io/2019/08/13/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98/"/>
    <id>http://peisenli.github.io/2019/08/13/图的遍历问题/</id>
    <published>2019-08-13T07:04:08.000Z</published>
    <updated>2019-08-13T07:22:31.705Z</updated>
    
    <content type="html"><![CDATA[<p>图的遍历：从图中某个顶点出发游历图，访遍图中其余顶点，并且使图中的每个顶点仅被访问一次的过程。我们可以设置一个全局型标志数组visited来标志某个顶点是否被访问过，未访问的值为0，访问过的值为1。<br><a id="more"></a></p><h3 id="深度优先搜索遍历"><a href="#深度优先搜索遍历" class="headerlink" title="深度优先搜索遍历"></a>深度优先搜索遍历</h3><p>深度优先搜索遍历类似于树的先序遍历。假定给定图G的初态是所有顶点均未被访问过，在G中任选一个顶点i作为遍历的初始点，则深度优先搜索遍历可定义如下：<br>(1)首先访问顶点i，并将其访问标记置为访问过，即visited[i]=1；<br>(2)然后搜索与顶点i有边相连的下一个顶点j，若j未被访问过，则访问它，并将j的访问标记置为访问过，visited[j]=1，然后从j开始重复此过程，若j已访问，再看与i有边相连的其它顶点；<br>(3)若与i有边相连的顶点都被访问过，则退回到前一个访问顶点并重复刚才过程，直到图中所有顶点都被访问完为止。<br>若图是连通的或强连通的，则从图中某一个顶点出发可以访问到图中所有顶点，否则只能访问到一部分顶点。另外，从刚才写出的遍历结果可以看出，从某一个顶点出发的遍历结果是不唯一的。但是,若我们给定图的存贮结构,则从某一顶点出发的遍历结果应是唯一的。<br><strong>用邻接矩阵实现图的深度优先搜索</strong></p><pre><code>void dfs (int i)          /* 从顶点i 出发遍历*/{       int j;                                                               visit(i);               /*输出访问顶点*/    visited[i]=1;       /*全局数组访问标记置1表示已经访问*/    for(j=1; j&lt;=n; j++)         if((A[i][j]==1)&amp;&amp;(!visited[j]))        dfs(j);        }</code></pre><p>时间复杂度为:O(n2)<br><strong>用邻接表实现图的深度优先搜索</strong></p><pre><code>void  dfs1(int i){      link *p;       visit(head[i]) ;       //输出访问顶点    visted[i]=1;        //全局数组访问标记置为1表示已访问    p=head[i].link;    while (p!=NULL)    {          if(!visited[p-&gt;adjvex]) //如果p指向的邻接点未被访问过            dfs1(p-&gt;adjvex);           p=p-&gt;next;    }}</code></pre><p>而当以邻接表作图的存储结构时，找邻接点所需时间为O(e)，其中e为无向图中边的数或有向图中弧的数。由此，当以邻接表作存储结构时，深度优先搜索遍历图的时间复杂度为O(n＋e)。<br><strong>非连通图的深度优先搜索</strong><br>若图是非连通的或非强连通图，则从图中某一个顶点出发。不能用深度优先搜索访问到图中所有顶点，而只能访问到一个连通子图（既连通分量）或只能访问到一个强连通子图（即强连通分量）。这时，可以在每个连通分量或每个强连通分量中都选一个顶点，进行深度优先搜索遍历，最后将每个连通分量或每个强连通分量的遍历结果合起来，则得到整个非连通图的遍历结果。<br>遍历算法实现与连通图的只有一点不同，即对所有顶点进行循环，反复调用连通图的深度优先搜索遍历算法即可。</p><hr><h3 id="广度优先搜索遍历"><a href="#广度优先搜索遍历" class="headerlink" title="广度优先搜索遍历"></a>广度优先搜索遍历</h3><p>广度优先搜索遍历类似于树的按层次遍历。设图G的初态是所有顶点均未访问，在G 中任选一顶点i作为初始点，则广度优先搜索的基本思想是：<br>(1)首先访问顶点i，并将其访问标志置为已被访问，即visited[i]=1；<br>(2)接着依次访问与顶点i有边相连的所有顶点W1，W2，…，Wt；<br>(3)然后再按顺序访问与W1，W2，…，Wt有边相连又未曾访问过的顶点；<br>依此类推，直到图中所有顶点都被访问完为止 。   </p><pre><code>void bfs(Graph g ,vtx * v）{   visit(v); visited[v]=1; INIQUEUE(Q);ENQUEUE(Q,v); while (!EMPTY(Q)){     DLQUEUE(Q,v); //队头元素出队     w=FIRSTADJ(g,v);        //求v的邻接点    while (w!=0)    {         if(!visited[w])         {             visit(w);             visited[w]=1;                        ENQUEUE(Q,w);         }         w=NEXTADJ(g,v,w);//求下一邻接点     } } }//bfs </code></pre><p><strong>用邻接矩阵实现图的广度优先搜索遍历</strong><br>算法描述如下：</p><pre><code>void  bfs(int  i)      //从顶点i出发遍历{      int  Q[n+1] ;       //Q为队列    int  f,r,j ;        // f,r分别为队列头，尾指针    f=r=0 ;             //设置空队列    visit(v[i]) ;       // 输出访问顶点    visited[i]=1 ;      //全局数组标记置1表示已经访问    r++; q[r]=i ;       //入队列    while (f&lt;r)     {           f++;         i=q[f] ;       //出队列           for (j=1; j&lt;=n; j++)               if ((A[i][j]==1)&amp;&amp;(!visited[j]))            {                  visit(v[j]);                     visited[j]=1;                     r++; q[r]=j;            }    }   }</code></pre><p><strong>用邻接表实现图的广序优先搜索遍历</strong><br>算法描述如下：</p><pre><code>void  BFSl(int i){      int  q[n+1] ;                               //定义队列    int  f,r ;      E_NODE *p ;             //P为搜索指针    f=r=0 ;      visit(head[i]) ;    visited[i]=1; r++; q[r]=i ;                //进队    while (f&lt;r)       {         f++ ; i=q[f] ;    //出队  p=head[i].link ;          while  (p!=NULL)        {               if(!visited[p-&gt;adjvex])                 {                      visit(head[p-&gt;adjvex].vertex;                    visited[p-&gt;adjvex]=1;                       r++;q[r]=p-&gt;adjvex;                 }            p=p-&gt;next;         }    }  }</code></pre><p><strong>非连通图的广度优先搜索</strong><br>若图是非连通的或非强连通图，则从图中某一个顶点出发。不能用广度优先搜索遍历访问到图中所有顶点，而只能访问到一个连通子图（既连通分量）或只能访问到一个强连通子图（既强连通分量）。这时，可以在每个连通分量或每个强连通分量中都选一个顶点，进行广度优先搜索遍历，最后将每个连通分量或每个强连通分量的遍历结果合起来，则得到整个非连通图或非强连通图的广度优先搜索遍历序列。<br>遍历算法实现与连通图的只有一点不同，即对所有顶点进行循环，反复调用连通图的广度优先搜索遍历算法即可。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图的遍历：从图中某个顶点出发游历图，访遍图中其余顶点，并且使图中的每个顶点仅被访问一次的过程。我们可以设置一个全局型标志数组visited来标志某个顶点是否被访问过，未访问的值为0，访问过的值为1。&lt;br&gt;
    
    </summary>
    
    
      <category term="Data Struct" scheme="http://peisenli.github.io/tags/Data-Struct/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode169.求众数</title>
    <link href="http://peisenli.github.io/2019/08/13/LeetCode169-%E6%B1%82%E4%BC%97%E6%95%B0/"/>
    <id>http://peisenli.github.io/2019/08/13/LeetCode169-求众数/</id>
    <published>2019-08-13T03:04:28.000Z</published>
    <updated>2019-08-13T03:34:55.541Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊n/2⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在众数。<br>示例 1:<br>输入: [3,2,3]<br>输出: 3<br>示例 2:<br>输入: [2,2,1,1,1,2,2]<br>输出: 2<br>来源：力扣（LeetCode）<br>解题思路：摩尔投票算法<br>从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，总能找到最多的那个。<br><a id="more"></a><br>python实现：    </p><pre><code>class Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        MostF = nums[0]        count = 1;        for i in range(1,len(nums)):            if MostF == nums[i]:                count += 1            else:                count -=1                if count == 0:                      MostF = nums[i + 1]        return MostF</code></pre><p>Boyer-Moore majority vote algorithm(摩尔投票算法)是一种在线性时间O(n)和空间复杂度的情况下，在一个元素序列中查找包含最多的元素。它是以Robert S.Boyer和J Strother Moore命名的，1981年发明的，是一种典型的流算法(streaming algorithm)。<br>在它最简单的形式就是，查找最多的元素，也就是在输入中重复出现超过一半以上(n/2)的元素。如果序列中没有最多的元素，算法不能检测到正确结果，将输出其中的一个元素之一。<br>当元素重复的次数比较小的时候，对于流算法不能在小于线性空间的情况下查找频率最高的元素。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊n/2⌋ 的元素。&lt;br&gt;你可以假设数组是非空的，并且给定的数组总是存在众数。&lt;br&gt;示例 1:&lt;br&gt;输入: [3,2,3]&lt;br&gt;输出: 3&lt;br&gt;示例 2:&lt;br&gt;输入: [2,2,1,1,1,2,2]&lt;br&gt;输出: 2&lt;br&gt;来源：力扣（LeetCode）&lt;br&gt;解题思路：摩尔投票算法&lt;br&gt;从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，总能找到最多的那个。&lt;br&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://peisenli.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>图的存储结构</title>
    <link href="http://peisenli.github.io/2019/08/13/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
    <id>http://peisenli.github.io/2019/08/13/图的存储结构/</id>
    <published>2019-08-13T02:41:59.000Z</published>
    <updated>2019-08-13T02:48:19.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a><center>图的存储结构</center></h2><p>由于图的结构比较复杂，任意两个顶点之间都可能存在关系，因此无法以数据元素在存储区中的物理位置来表示元素之间关系，即图没有顺序映象的存储结构。<br>另一方面，用多重链表表示图是自然的事，它是一种最简单的链式映象结构，即以一个由一个数据域和多个指针域组成的结点表示图中一个顶点，其中数据域存储该顶点的信息，指针域存储指向其邻接点的指针。  </p><p><center><img src="https://i.loli.net/2019/08/13/YLTV6NISDibzh53.png" alt="多重.jpg"><br>图1 有向图多重链表<br><img src="https://i.loli.net/2019/08/13/MRQzS3pCLbJFoZO.png" alt="表.jpg"><br>图2 无向图的多重链表</center><br>我们一般采用一些改进的方式来存储图，常用的有邻接矩阵、邻接表和十字链表及邻接多重表等。除了要存储图中各个顶点本身的信息外，同时还要存储顶点与顶点之间的所有关系（边的信息）。存储方法的选择，取决于具体的应用。  </p><a id="more"></a><hr><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>在邻接矩阵表示中，除了存放顶点本身信息外，还用一个矩阵表示各个顶点之间的关系。若(i,j)∈E(G)或&lt;i,j&gt;∈E(G),则矩阵中第i行 第j列元素值为1，否则为0 。<br><strong>无向图：  </strong>  </p><p><center><img src="https://i.loli.net/2019/08/13/eo1HNckBwgzQDiM.png" alt="邻阶矩阵.jpg"><br>图3 无向图的邻接矩阵表示</center><br>分析1：无向图的邻接矩阵是对称的；<br>分析2：顶点i 的度＝第 i 行 (列) 中1 的个数；<br>特别：完全图的邻接矩阵中，对角元素为0，其余1。<br>结论：<br>（1）矩阵是对称的，可压缩存储(上(下)三角);<br>（2）第i行或第i 列中1的个数为顶点i 的度;<br>（3）矩阵中1的个数的一半为图中边的数目;<br>（4）很容易判断顶点i和顶点j之间是否有边相连(看矩阵中i行j列值是否为1)。   </p><hr><p><strong>有向图：</strong>  </p><p><center><img src="https://i.loli.net/2019/08/13/jsqWJYnwrG9HM3X.png" alt="1565661031(1).jpg"><br>有向图的邻接矩阵表示</center><br>分析1：有向图的邻接矩阵可能是不对称的。<br>分析2：顶点的出度=第i行元素之和，顶点的入度=第i列元素之和，顶点的度=第i行元素之和+第i列元素之和。<br>结论：<br>（1） 矩阵不一定是对称的;<br>（2） 第i 行中1的个数为顶点i 的出度;<br>（3） 第i列中1的个数为顶点 i的入度;<br>（4） 矩阵中1的个数为图中弧的数目;<br>（5） 很容易判断顶点i 和顶点j 是否有弧相连.<br>邻接矩阵法优点：<br>容易实现图的操作，如：求某顶点的度、判断顶点之间是否有边（弧）、找顶点的邻接点等等。<br>邻接矩阵法缺点：<br>n个顶点需要n*n个单元存储边(弧);空间效率为O(n2)。 对稀疏图而言尤其浪费空间。</p><pre><code>#define INFINITE 9999       /* 假设的无穷大数 */void  creatadj(int n,int e,int t) /*n为顶点数,e为边数,t为1~4,分别表示无向图、有向图、带权无向图、带权有向图*/{      int i,j,k,w;    for(i=1;i&lt;=n;i++)     {          printf(“输入第%d顶点信息”,i);        v[i]=getchar();      }    for(i=1;i&lt;=n;i++)          for(j=1;j&lt;=n;j++)            if(t&gt;2)                 A[i][j]=INFINITE;            else                     A[i][j]=0;      for(k=1;k&lt;=e;k++)     {          scanf(“%d,%d”,&amp;i,&amp;j);         if(i&gt;n ||j&gt;n)  exit(0);         if(t&gt;2)            {                 scanf(“%d”,&amp;w);            A[i][j]=w;               if(t==3) A[j][i]=w;          }        else                 {             A[i][j]=1;            if(t==1)  A[j][i]=1;          }      }} </code></pre><hr><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>图的邻接表存储方法是一种顺序分配与链式分配相结合的存储方法，它包括两部分：一部分是单链表，用来存放边的信息；另一部分是数组，主要用来存放顶点本身的数据信息。<br><strong>有向图：</strong>  </p><p><center><img src="https://i.loli.net/2019/08/13/sz1qmV6A5EdBNKb.png" alt="1565662180(1).jpg"><br>有向图的邻接表表示</center><br>出度：OD(Vi)＝单链出边表中链接的结点数<br>入度：ID(Vi)＝邻接点域为Vi的弧个数<br>结论：<br>（1）第i 个链表中结点数目为顶点i的出度；<br>（2）所有链表中结点数目为图中弧数；<br>（3）占用的存储单元数目为n+e 。<br><strong>无向图：</strong>  </p><p><center><img src="https://i.loli.net/2019/08/13/9MOj6Fop7kiV1qG.png" alt="1565662132(1).jpg"><br>无向图的邻接表表示</center><br>注：邻接表不唯一，因各个边结点的链入顺序是任意的<br>空间效率为O(n+2e)。<br>若是稀疏图(e&lt;&lt;n2)，比邻接矩阵表示法O(n2)省空间。<br>结论：<br>（1）第i 个链表中结点数目为顶点i的度；<br>（2）所有链表中结点数目的一半为图中边数；<br>（3）占用的存储单元数目为n+2e 。<br><strong>邻接表优缺点：</strong><br>优：空间效率高；容易寻找顶点的邻接点；<br>缺：判断两顶点间是否有边或弧，需搜索两结点对应的单链表，没有邻接矩阵方便。<br><strong>与邻接矩阵对比：</strong><br>① 对于任一确定的无向图，邻接矩阵是唯一的（行列号与顶点编号一致），但邻接表不唯一（链接次序与顶点编号无关）。<br>② 邻接矩阵的空间复杂度为O(n2),而邻接表的空间复杂度为O(n+e)。<br>③ 邻接矩阵多用于稠密图；而邻接表多用于稀疏图</p><h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p>C语言实现及定义：<br><img src="https://i.loli.net/2019/08/13/fT7IYKbRoOXiqQN.png" width="250" hegiht="100" align="left">  </p><pre><code>弧结点：typedef  struct  arcnode{       int   tailvex,  headvex;        //弧尾、弧头在表头数组中位置     struct   arcnode   *hlink；//指向弧头相同的下一条弧     struct   arcnode   *tlink;    //指向弧尾相同的下一条弧}AD;    顶点结点：typedef  struct  dnode{       int   data;  //存与顶点有关信息     struct   arcnode   *firstin；//指向以该顶点为弧头的第一个弧结点     struct   arcnode   *firstout; //指向以该顶点为弧尾的第一个弧结点}DD;</code></pre><h3 id="多重链表"><a href="#多重链表" class="headerlink" title="多重链表"></a>多重链表</h3><p>C语言实现及定义：<br><img src="https://i.loli.net/2019/08/13/tEPCrjLlOzBwXY5.png" width="250" hegiht="200" align="left">  </p><pre><code>边结点：typedef   struct  node{       int  mark;   //标志域     int  ivex, jvex;  //该边依附的两个顶点在表头数组中位置     struct  node   *ilink,  *jlink;  //分别指向依附于ivex和jvex的下一条边}JD;顶点结点：typedef   struct  dnode{        int   data;   //存与顶点有关的信息    struct   node  *firstedge;  //指向第一条依附于该顶点的边}DD;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;图的存储结构&quot;&gt;&lt;a href=&quot;#图的存储结构&quot; class=&quot;headerlink&quot; title=&quot;图的存储结构&quot;&gt;&lt;/a&gt;&lt;center&gt;图的存储结构&lt;/center&gt;&lt;/h2&gt;&lt;p&gt;由于图的结构比较复杂，任意两个顶点之间都可能存在关系，因此无法以数据元素在存储区中的物理位置来表示元素之间关系，即图没有顺序映象的存储结构。&lt;br&gt;另一方面，用多重链表表示图是自然的事，它是一种最简单的链式映象结构，即以一个由一个数据域和多个指针域组成的结点表示图中一个顶点，其中数据域存储该顶点的信息，指针域存储指向其邻接点的指针。  &lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src=&quot;https://i.loli.net/2019/08/13/YLTV6NISDibzh53.png&quot; alt=&quot;多重.jpg&quot;&gt;&lt;br&gt;图1 有向图多重链表&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2019/08/13/MRQzS3pCLbJFoZO.png&quot; alt=&quot;表.jpg&quot;&gt;&lt;br&gt;图2 无向图的多重链表&lt;/center&gt;&lt;br&gt;我们一般采用一些改进的方式来存储图，常用的有邻接矩阵、邻接表和十字链表及邻接多重表等。除了要存储图中各个顶点本身的信息外，同时还要存储顶点与顶点之间的所有关系（边的信息）。存储方法的选择，取决于具体的应用。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Data Struct" scheme="http://peisenli.github.io/tags/Data-Struct/"/>
    
  </entry>
  
  <entry>
    <title>图的基本概念</title>
    <link href="http://peisenli.github.io/2019/08/13/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://peisenli.github.io/2019/08/13/图的基本概念/</id>
    <published>2019-08-13T01:28:03.000Z</published>
    <updated>2019-08-13T01:32:16.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="  图的基本概念 "></a><center>  图的基本概念 </center></h2><p><strong>图结构特点：</strong><br>图(Graph)是一种较线性表和树更为复杂的数据结构。在线性表中，数据元素之间仅有线性关系，即每个数据元素只有一个直接前驱和一个直接后继；在树形结构中，数据元素 之间有着明显的层次关系，虽然每一层上的数据元素可能和下一层中多个元素(孩子) 相关，但只能和上一层中一个元素(双亲)相关；而在图形结构中，结点之间 的关系可以是任意的，任意两个数据元素之间都可能相关。   </p><a id="more"></a><hr><p><strong>图的定义：</strong><br>Graph=(V,E)，V：顶点(数据元素)的有穷非空集合；E：边的有穷集合。<br>无向图：每条边都是无方向的<br>有向图：每条边都是有方向的  </p><p><center><img src="https://i.loli.net/2019/08/13/jDrKtBVpOiHXWhY.png" alt="1565658564(1).jpg"></center><br>完全图：任意两个点都有一条边相连。<br>有向完全图边数：n(n-1)<br>无向完全图边数：n(n-1)/2<br>稀疏图：有很少边或弧的图。<br>稠密图：有较多边或弧的图。<br>网：边/弧带权的图。<br>邻接：有边/弧相连的两个顶点之间的关系。存在(vi, vj)，则称vi和vj互为邻接点；存在&lt;vi, vj&gt;，则称vi邻接到vj， vj邻接于vi。<br>关联(依附)：边/弧与顶点之间的关系。存在(vi, vj)/ &lt;vi, vj&gt;， 则称该边/弧关联于vi和vj。<br>顶点的度：与该顶点相关联的边的数目，记为TD(v)<br>在有向图中, 顶点的度等于该顶点的入度与出度之和。<br>顶点 v 的入度是以 v 为终点的有向边的条数, 记作 ID(v)<br>顶点 v 的出度是以 v 为始点的有向边的条数, 记作OD(v)<br>路径：接续的边构成的顶点序列。<br>路径长度：路径上边或弧的数目/权值之和。<br>回路(环)：第一个顶点和最后一个顶点相同的路径。<br>简单路径：除路径起点和终点可以相同外，其余顶点均不相同的路径。<br>简单回路(简单环)：除路径起点和终点相同外，其余顶点均不相同的路径。  </p><p><center><img src="https://i.loli.net/2019/08/13/jACpbBO4NJFxMXz.png" alt="图片1.png"></center><br>在无（有）向图G=( V, E )中，若对任何两个顶点 v、u 都存在从v 到 u 的路径，则称G是连通图（强连通图）。  </p><p><center><img src="https://i.loli.net/2019/08/13/cAGOqHbg9ZmktjD.png" alt="tu.png"></center><br>权与网：图中边或弧所具有的相关数称为权。表明从一个顶点到另一个顶点的距离或耗费。带权的图称为网。<br>子图：设有两个图G=（V，{E}）、G1=（V1，{E1}），若V1  V，E1  E，则称 G1是G的子图。例:(b)、(c) 是 (a) 的子图。  </p><h2 id><a href="#" class="headerlink" title></a><center><img src="https://i.loli.net/2019/08/13/SMVnxFU8oTlirfZ.png" alt="ww.jpg"></center></h2><p>极大连通子图意思是：该子图是 G 连通子图，将G 的任何不在该子图中的顶点加入，子图不再连通。<br>有向图极大强连通子图意思是：该子图是G的强连通子图，将D的任何不在该子图中的顶点加入，子图不再是强连通的。<br>极小连通子图：该子图是G 的连通子图，在该子图中删除任何一条边，子图不再连通。<br>生成树：包含无向图G 所有顶点的极小连通子图。<br>生成森林：对非连通图，由各个连通分量的生成树的集合。        </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;图的基本概念&quot;&gt;&lt;a href=&quot;#图的基本概念&quot; class=&quot;headerlink&quot; title=&quot;  图的基本概念 &quot;&gt;&lt;/a&gt;&lt;center&gt;  图的基本概念 &lt;/center&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;图结构特点：&lt;/strong&gt;&lt;br&gt;图(Graph)是一种较线性表和树更为复杂的数据结构。在线性表中，数据元素之间仅有线性关系，即每个数据元素只有一个直接前驱和一个直接后继；在树形结构中，数据元素 之间有着明显的层次关系，虽然每一层上的数据元素可能和下一层中多个元素(孩子) 相关，但只能和上一层中一个元素(双亲)相关；而在图形结构中，结点之间 的关系可以是任意的，任意两个数据元素之间都可能相关。   &lt;/p&gt;
    
    </summary>
    
    
      <category term="Graph" scheme="http://peisenli.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>位运算-异或</title>
    <link href="http://peisenli.github.io/2019/08/12/%E4%BD%8D%E8%BF%90%E7%AE%97-%E5%BC%82%E6%88%96/"/>
    <id>http://peisenli.github.io/2019/08/12/位运算-异或/</id>
    <published>2019-08-12T03:39:52.000Z</published>
    <updated>2019-08-12T03:54:28.469Z</updated>
    
    <content type="html"><![CDATA[<p><strong>异或</strong>，英文为exclusive OR，缩写成xor<br>异或（xor）是一个数学运算符。它应用于逻辑运算。异或的数学符号  为“⊕”，计算机符号为“xor”。<br>其运算法则为：<br>a⊕b = (¬a ∧ b) ∨ (a ∧¬b)<br>如果a、b两个值不相同，则异或结果为1。<br>如果a、b两个值相同，异或结果为0。<br>异或也叫半加运算，其运算法则相当于不带进位的二进制加法：二进制下用1表示真，0表示假，则异或的运算法则为：<br>0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0（同为0，异为1），这些法则与加法是相同的，只是不带进位，所以异或常被认作不进位加法。<br><a id="more"></a><br><strong>运算法则：</strong>  </p><ol><li>a ⊕ a = 0  </li><li>a ⊕ b = b ⊕ a  </li><li>a ⊕ b ⊕ c = a ⊕ (b ⊕ c) = (a ⊕ b) ⊕ c;  </li><li>d = a ⊕ b ⊕ c 可以推出 a = d ⊕ b ⊕ c.  </li><li><p>a ⊕ b ⊕ a = b.<br>例：若x是二进制数0101，y是二进制数1011；则x⊕y=1110只有在两个比较的位不同时其结果是1，否则结果为0即“两个输入相同时为0，不同则为1。<br><strong>LeetCode136.只出现一次的数字</strong><br>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。<br>说明：<br>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？<br>示例 1:<br>输入: [2,2,1]<br>输出: 1<br>示例 2:<br>输入: [4,1,2,1,2]<br>输出: 4<br><strong>思路</strong>：一开始直接想的进行暴力破解，但是综合时间复杂度上，考虑位运算，异或具有很好的性质，如果相同的两个数异或则为零，零和任何元素异或为元素本身。那么数组种出现的某个单一元素直接就可以找出来。<br>python实现：</p><p> class Solution:</p><pre><code>def singleNumber(self, nums: List[int]) -&gt; int:    res = nums[0]    for i in range(1,len(nums)):        res ^= nums[i]    return res</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;异或&lt;/strong&gt;，英文为exclusive OR，缩写成xor&lt;br&gt;异或（xor）是一个数学运算符。它应用于逻辑运算。异或的数学符号  为“⊕”，计算机符号为“xor”。&lt;br&gt;其运算法则为：&lt;br&gt;a⊕b = (¬a ∧ b) ∨ (a ∧¬b)&lt;br&gt;如果a、b两个值不相同，则异或结果为1。&lt;br&gt;如果a、b两个值相同，异或结果为0。&lt;br&gt;异或也叫半加运算，其运算法则相当于不带进位的二进制加法：二进制下用1表示真，0表示假，则异或的运算法则为：&lt;br&gt;0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0（同为0，异为1），这些法则与加法是相同的，只是不带进位，所以异或常被认作不进位加法。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-求数组的子集</title>
    <link href="http://peisenli.github.io/2019/08/11/LeetCode-%E6%B1%82%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%90%E9%9B%86/"/>
    <id>http://peisenli.github.io/2019/08/11/LeetCode-求数组的子集/</id>
    <published>2019-08-11T06:07:33.000Z</published>
    <updated>2019-08-11T06:19:49.428Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LeetCode78-子集"><a href="#LeetCode78-子集" class="headerlink" title="LeetCode78.子集"></a>LeetCode78.子集</h3><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>说明：解集不能包含重复的子集。<br><a id="more"></a><br>示例:<br>输入: nums = [1,2,3]<br>输出:<br>[[3],[1],[2],[1,2,3],[1,3],[2,3],[1,2],[]]    </p><p>思路：在求取数组子集时，对每个数据元进行遍历后在原有的List上进行追加即可获得元素的子集。<br>python实现：  </p><pre><code>class Solution:def subsets(self, nums: List[int]) -&gt; List[List[int]]:    result = [[]]    nums.sort()    for num in nums:            result += [item+[num] for item in result]    return result</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;LeetCode78-子集&quot;&gt;&lt;a href=&quot;#LeetCode78-子集&quot; class=&quot;headerlink&quot; title=&quot;LeetCode78.子集&quot;&gt;&lt;/a&gt;LeetCode78.子集&lt;/h3&gt;&lt;p&gt;给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。&lt;br&gt;说明：解集不能包含重复的子集。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Sort-list</title>
    <link href="http://peisenli.github.io/2019/08/10/Sort-list/"/>
    <id>http://peisenli.github.io/2019/08/10/Sort-list/</id>
    <published>2019-08-10T12:55:44.000Z</published>
    <updated>2019-08-10T13:10:37.887Z</updated>
    
    <content type="html"><![CDATA[<p>常见的排序算法比较表如下所示：</p><p><center><img src="https://i.loli.net/2019/08/10/7y58PONKUuH2g4e.png" alt="1565437239(1).png"></center></p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。快速排序（Quicksort）是对冒泡排序的一种改进。<br><a id="more"></a></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。<br><strong>LeetCode148:排序链表</strong><br>在 O(nlogn) 时间复杂度和常数级空间复杂度下，对链表进行排序。<br>思考：对于题目要求了复杂度参照上表可使用的算法列表进行实现。  </p><ul><li>找到链表的中间结点  </li><li>递归对左半部分和右半部分排序  </li><li><p>合并排序好的两部分链表<br>python实现归并排序：</p><p>  class Solution: </p><pre><code>def sortList(self, head: ListNode) -&gt; ListNode:     if not head or not head.next: return head     slow, fast = head, head.next     while fast and fast.next:        fast, slow = fast.next.next, slow.next #fast步长为2，slow步长为1，实现中间节点的寻找    mid, slow.next = slow.next, None  #分为Head开头和Mid开头的两个链表     left, right = self.sortList(head), self.sortList(mid)     h = res = ListNode(0)  #中间及结果存储变量    while left and right:  #左右链表序列进行比较排序        if left.val &lt; right.val:             h.next, left = left, left.next         else:             h.next, right = right, right.next         h = h.next     h.next = left if left else right     return res.next</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的排序算法比较表如下所示：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src=&quot;https://i.loli.net/2019/08/10/7y58PONKUuH2g4e.png&quot; alt=&quot;1565437239(1).png&quot;&gt;&lt;/center&gt;&lt;/p&gt;
&lt;h3 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h3&gt;&lt;p&gt;通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。快速排序（Quicksort）是对冒泡排序的一种改进。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Greedy Algorithm</title>
    <link href="http://peisenli.github.io/2019/08/09/Greedy-Algorithm/"/>
    <id>http://peisenli.github.io/2019/08/09/Greedy-Algorithm/</id>
    <published>2019-08-09T07:12:09.000Z</published>
    <updated>2019-08-09T07:13:16.848Z</updated>
    
    <content type="html"><![CDATA[<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。<br>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。<br>贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止。<br><a id="more"></a></p><h3 id="LeetCode122"><a href="#LeetCode122" class="headerlink" title="LeetCode122"></a>LeetCode122</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br>示例 1:<br>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。<br>示例 2:<br>输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br>示例 3:<br>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。<br>算法思想：题目并不要求输出买入和卖出的日期，只要求输出最后受益，所以其实我们并不需要找到极小值和极大值的点，只需要知道它们的差值，而b-a=(b-c)+(c-a)，换句话说，可以通过极大值和极小值之间中间值，通过价格上涨的累加，算出最后的价格差值。<br>Python实现：</p><pre><code>class Solution:def maxProfit(self, prices: List[int]) -&gt; int:    earn=0    if len(prices)&lt;=1:        return earn    for i in range(len(prices)-1):        if prices[i+1]&gt;prices[i]:            earn+=(prices[i+1]-prices[i])    return earn</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;贪心算法&quot;&gt;&lt;a href=&quot;#贪心算法&quot; class=&quot;headerlink&quot; title=&quot;贪心算法&quot;&gt;&lt;/a&gt;贪心算法&lt;/h3&gt;&lt;p&gt;贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。&lt;br&gt;贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。&lt;br&gt;贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode23_sort-K-lists</title>
    <link href="http://peisenli.github.io/2019/08/07/Leetcode23-sort-K-lists/"/>
    <id>http://peisenli.github.io/2019/08/07/Leetcode23-sort-K-lists/</id>
    <published>2019-08-07T07:35:54.000Z</published>
    <updated>2019-08-07T07:41:13.436Z</updated>
    
    <content type="html"><![CDATA[<p><center><strong>堆-合并 k 个排序链表</strong></center><br>LeetCode23-合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。<br>示例：<br>输入:<br>    [<br>          1-&gt;4-&gt;5,<br>          1-&gt;3-&gt;4,<br>          2-&gt;6<br>    ]<br>输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<br>算法思路：利用一个size为K的优先级队列，每次把K个链表的当前头的val塞进优先级队列。  </p><ul><li>首先将list中的每个链表比较首元素，然后依次加入优先队列。  </li><li>然后判断这个优先队列是否为空，不为空，我们弹出队首元素，接着判断这个弹出的元素作为一个链表节点，其后是否还有元素，如果有元素，将元素加入新队列中。 </li></ul><a id="more"></a><p>python3实现：  </p><pre><code># Definition for singly-linked list.  # class ListNode:  #    def __init__(self, x):  #         self.val = x  #         self.next = None  from heapq import *  #python标准库模块堆操作class Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        pq = []      #队列列表        for i in range(len(lists)):            if lists[i]:                heappush(pq, (lists[i].val, i))    #以元组的方式加入堆，（链表Val，ith序列链表）                 lists[i] = lists[i].next #改变每个序列的链表指针        dummy = ListNode(1) #新序列节点        p = dummy          while pq:            val, idx = heappop(pq) #弹出pq堆中的最小值的元素值及index            p.next = ListNode(val) #指针指向下一个Val节点            p = p.next #更新指针节点            #重新以顺序进入链表序列            if lists[idx]:                 heappush(pq, (lists[idx].val, idx))                lists[idx] = lists[idx].next        return dummy.next</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;strong&gt;堆-合并 k 个排序链表&lt;/strong&gt;&lt;/center&gt;&lt;br&gt;LeetCode23-合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。&lt;br&gt;示例：&lt;br&gt;输入:&lt;br&gt;    [&lt;br&gt;          1-&amp;gt;4-&amp;gt;5,&lt;br&gt;          1-&amp;gt;3-&amp;gt;4,&lt;br&gt;          2-&amp;gt;6&lt;br&gt;    ]&lt;br&gt;输出: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6&lt;br&gt;算法思路：利用一个size为K的优先级队列，每次把K个链表的当前头的val塞进优先级队列。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先将list中的每个链表比较首元素，然后依次加入优先队列。  &lt;/li&gt;
&lt;li&gt;然后判断这个优先队列是否为空，不为空，我们弹出队首元素，接着判断这个弹出的元素作为一个链表节点，其后是否还有元素，如果有元素，将元素加入新队列中。 &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://peisenli.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Kth Largest</title>
    <link href="http://peisenli.github.io/2019/08/06/LeetCode-Kth-Largest/"/>
    <id>http://peisenli.github.io/2019/08/06/LeetCode-Kth-Largest/</id>
    <published>2019-08-06T07:21:07.000Z</published>
    <updated>2019-08-06T07:27:39.992Z</updated>
    
    <content type="html"><![CDATA[<p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br>示例 1:<br>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5<br>示例 2:<br>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4<br>说明：你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。<br>思路：对输入示例进行从大到小排序后进行输出第K大的数值即可。<br><a id="more"></a><br>C语言实现：  </p><pre><code>int findKthLargest(int* nums, int numsSize, int k){int i,j,temp;for (i=0;i&lt;numsSize-1;i++){    for(j=i+1;j&lt;numsSize;j++)    {        if(*(nums+i) &lt; *(nums+j))        {            temp = *(nums+i);            *(nums+i) = *(nums+j);            *(nums+j) = temp;        }    }}return *(nums+k-1);}</code></pre><p>python实现：</p><pre><code>class Solution:    def findKthLargest(self, nums: List[int], k: int) -&gt; int:        nums.sort()        return nums[-k]</code></pre><hr><p>堆是一种经过排序的树形数据结构，每个节点都有一个值，通常我们所说的堆的数据结构是指二叉树。所以堆在数据结构中通常可以被看做是一棵树的数组对象。而且堆需要满足一下两个性质：<br>（1）堆中某个节点的值总是不大于或不小于其父节点的值；<br>（2）堆总是一棵完全二叉树。<br>堆分为两种情况，有最大堆和最小堆。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。下图图一就是一个最大堆，图二就是一个最小堆。在一个摆放好元素的最小堆中，可以看到，父结点中的元素一定比子结点的元素要小，但对于左右结点的大小则没有规定谁大谁小。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。&lt;br&gt;示例 1:&lt;br&gt;输入: [3,2,1,5,6,4] 和 k = 2&lt;br&gt;输出: 5&lt;br&gt;示例 2:&lt;br&gt;输入: [3,2,3,1,2,4,5,5,6] 和 k = 4&lt;br&gt;输出: 4&lt;br&gt;说明：你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。&lt;br&gt;思路：对输入示例进行从大到小排序后进行输出第K大的数值即可。&lt;br&gt;
    
    </summary>
    
    
      <category term="Heap" scheme="http://peisenli.github.io/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>vaildparentheses</title>
    <link href="http://peisenli.github.io/2019/08/05/vaildparentheses/"/>
    <id>http://peisenli.github.io/2019/08/05/vaildparentheses/</id>
    <published>2019-08-05T04:23:02.000Z</published>
    <updated>2019-08-05T04:32:44.143Z</updated>
    
    <content type="html"><![CDATA[<p><center><strong>栈在括号匹配中的应用问题</strong></center><br>算法思想：  </p><ul><li>初始设置一个空栈，顺序读入括号  </li><li>若是右括号，则使之置于栈顶的最急迫期待得以消解，或者是不合法的情况（括号序列不匹配，退出程序）  </li><li><p>若是左括号，则作为新的更急迫的期待压入栈中，自然使原有的在栈中的所未消解的期待解决降了一级。算法结束时，栈为空，否则括号序列不匹配。   </p><a id="more"></a><p>Python实现：  </p><p>  class Solution:</p><pre><code>def isValid(self, s: str) -&gt; bool:    temp_str = []       #存放临时开括号    LeftParentheses = [&quot;(&quot;,&quot;[&quot;,&quot;{&quot;]    #左括号查找    vaildParentheses = [&quot;()&quot;,&quot;[]&quot;,&quot;{}&quot;]  #有效括号匹配    for cha in s:        if cha in LeftParentheses:       #如果是左括号就放入temp_str中            temp_str.append(cha)        else:            if not temp_str:             #如果temp_str为空，返回False                return False            else:                temp_cha = temp_str.pop() + cha     #出栈，组合                if temp_cha not in vaildParentheses:                    return False    if not temp_str:                      #判断是栈是否为空        return True    else:        return False</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;strong&gt;栈在括号匹配中的应用问题&lt;/strong&gt;&lt;/center&gt;&lt;br&gt;算法思想：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始设置一个空栈，顺序读入括号  &lt;/li&gt;
&lt;li&gt;若是右括号，则使之置于栈顶的最急迫期待得以消解，或者是不合法的情况（括号序列不匹配，退出程序）  &lt;/li&gt;
&lt;li&gt;&lt;p&gt;若是左括号，则作为新的更急迫的期待压入栈中，自然使原有的在栈中的所未消解的期待解决降了一级。算法结束时，栈为空，否则括号序列不匹配。   &lt;/p&gt;
    
    </summary>
    
    
      <category term="stack" scheme="http://peisenli.github.io/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>Mini-stack</title>
    <link href="http://peisenli.github.io/2019/08/04/Mini-stack/"/>
    <id>http://peisenli.github.io/2019/08/04/Mini-stack/</id>
    <published>2019-08-04T06:03:18.000Z</published>
    <updated>2019-08-04T06:49:04.801Z</updated>
    
    <content type="html"><![CDATA[<p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。<br>push(x) – 将元素 x 推入栈中。<br>pop() – 删除栈顶的元素。<br>top() – 获取栈顶元素。<br>getMin() – 检索栈中的最小元素。<br><a id="more"></a><br>示例:<br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   </p><pre><code>class MinStack(object):    def __init__(self):        &quot;&quot;&quot;        initialize your data structure here.        &quot;&quot;&quot;        self.stack = []                         # 定义一个基本栈，用于存储每个元素        self.min = []                           # 定义一个最小栈，其栈顶元素是当前基本栈中的最小值    def push(self, x):        self.stack.append(x)                    # 把元素压入栈中        if not self.min or x &lt; self.min[-1]:    # 如果最小栈为空或新元素比基本栈的最小值还要小            self.min.append(x)                  # 该元素是目前出现的最小值，压入最小栈        else:                                   # 否则            self.min.append(self.min[-1])       # 将最小栈中的栈顶元素复制一遍压入最小栈    def pop(self):        self.min.pop()                          # 弹出最小栈中的元素，保证两个栈元素个数相同        return self.stack.pop()                 # 弹出基本栈中的元素    def top(self):        return self.stack[-1]                   # 返回基本栈的栈顶元素    def getMin(self):        return self.min[-1]                     # 返回最小栈的栈顶元素</code></pre><p>另一种网上的方法但是运行出现问题：  </p><pre><code>class MinStack:      def __init__(self):        &quot;&quot;&quot;        initialize your data structure here.        &quot;&quot;&quot;        self.stack = []        self.min_list = []        self.min = None         def push(self, x: int):        self.stack.append(x)        if self.min == None or self.min &gt; x:            self.min = x    def pop(self):        popStack = self.stack.pop()        if len(self.stack) == 0:            self.min = None            return popStack        if popStack == self.min:            for i in self.stack: #此处出现问题，出栈后Min的始终没有发生改变。                if i &lt; self.min:                    self.min = i                    print(&quot;i&quot;,i)        return popStack               def top(self) :        return self.stack[-1]    def getMin(self):        print(&quot;Min&quot;,self.min)        return self.min</code></pre><p>运行结果如下所示：<br><img src="https://i.loli.net/2019/08/04/h1iKfALyT5CNJ9P.png" alt="1564898331(1).jpg"><br>对于出栈时存在了一个栈是否被弹出问题，需要进行更正，今天有点事情，之后进行修改。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。&lt;br&gt;push(x) – 将元素 x 推入栈中。&lt;br&gt;pop() – 删除栈顶的元素。&lt;br&gt;top() – 获取栈顶元素。&lt;br&gt;getMin() – 检索栈中的最小元素。&lt;br&gt;
    
    </summary>
    
    
      <category term="Mini-Stack" scheme="http://peisenli.github.io/tags/Mini-Stack/"/>
    
  </entry>
  
  <entry>
    <title>BiTree</title>
    <link href="http://peisenli.github.io/2019/07/25/BiTree/"/>
    <id>http://peisenli.github.io/2019/07/25/BiTree/</id>
    <published>2019-07-25T07:59:18.000Z</published>
    <updated>2019-07-25T08:14:01.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树型结构"><a href="#树型结构" class="headerlink" title="树型结构"></a><center><strong>树型结构</strong></center></h1><ol><li>树的定义<br>树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：  <ul><li>每个节点有零个或多个子节点</li><li>没有父节点的节点称为根节点；</li><li>每一个非根节点有且只有一个父节点；</li><li>除了根节点外，每个子节点可以分为多个不相交的子树。<a id="more"></a>  </li></ul></li><li>树的基本术语<br>若一个结点有子树，那么该结点称为子树根的”双亲”，子树的根是该结点的”孩子”。有相同双亲的结点互为”兄弟”。一个结点的所有子树上的任何结点都是该结点的后裔。从根结点到某个结点的路径上的所有结点都是该结点的祖先。<br>结点的度：结点拥有的子树的数目。<br>叶子：度为零的结点。<br>分支结点：度不为零的结点。<br>树的度：树中结点的最大的度。<br>层次：根结点的层次为1，其余结点的层次等于该结点的双亲结点的层次加1。<br>树的高度：树中结点的最大层次。<br>无序树：如果树中结点的各子树之间的次序是不重要的，可以交换位置。<br>有序树：如果树中结点的各子树之间的次序是重要的, 不可以交换位置。<br>森林：0个或多个不相交的树组成。对森林加上一个根，森林即成为树；删去根，树即成为森林。   </li><li>树的性质<ul><li>树中的结点数等于所有结点度数加1;</li><li>度为m的树中第i层上至多有m^(i-1)个结点（i&gt;=1）;</li><li>高度为h的m叉树至多有（m^h-1）/(m-1)个节点；</li><li>具有n个结点的m叉树的最小高度为logm(n(m-1)+1)的上界；    </li></ul></li><li>完全二叉树——若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。</li><li>满二叉树——除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。</li><li>平衡二叉树——平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。<br><img src="https://i.loli.net/2019/07/25/5d3960b20c6ad20993.jpg" alt="Cache_43cc6ab39bd2379b..jpg"><center>数据结构树形结构思维导图</center>  </li></ol><hr><p>##<strong>二叉树</strong>##</p><ol><li>二叉树的定义<br>二叉树是每个节点最多有两个子树的树结构。它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；或者左、右子树皆为空。  </li><li>二叉树的性质<br>二叉树有以下几个性质：TODO(上标和下标)<br>性质1：二叉树第i层上的结点数目最多为 2^(i-1) (i≥1)。<br>性质2：深度为k的二叉树至多有2^k-1个结点(k≥1)。<br>性质3：包含n个结点的二叉树的高度至少为log2(n+1)。<br>性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1。  </li><li>二叉树存储结构<ul><li>顺序存储：采用数组的方式进行存储</li><li>链式存储：包括三个域：数据域data、左指针域lchild和右指针域rchild;<br><code>typedef struct node<br>{<br>  ElemType data;<pre><code>struct node *lchild,*rchild; </code></pre>}BTNode;<br></code></li></ul></li><li>二叉树的遍历<br>二叉树的遍历本质上是将一个复杂的非线性结构转换为线性结构，使每个结点都有了唯一前驱和后继（第一个结点无前驱，最后一个结点无后继）。对于二叉树的一个结点，查找其左右子女是方便的，其前驱后继只有在遍历中得到。为了容易找到前驱和后继，有两种方法。一是在结点结构中增加向前和向后的指针，这种方法增加了存储开销，不可取；二是利用二叉树的空链指针。  <ul><li>前序遍历:若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。<br><code><br>void preScanf(TreeNode* t)<br>{<br>if (t == NULL)<br>{<br>  return;<br>}<br>cout &lt;&lt; t-&gt;val &lt;&lt;” “;<br>preScanf(t-&gt;left);<br>preScanf(t-&gt;right);<br>}</code>  </li><li>中序遍历:若二叉树为空，则空操作返回，否则从根结点开始，先中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。<br><code><br>//中序遍历二叉树：左—根—右<br>void middleScanf(TreeNode* t)<br>{<br>if (t == NULL)<br>{<br>  return;<br>}<br>middleScanf(t-&gt;left);<br>cout &lt;&lt; t-&gt;val &lt;&lt; “ “;<br>middleScanf(t-&gt;right);<br>}</code>  </li><li>后序遍历：若二叉树为空，则空操作返回，否则从根结点开始，先后序遍历根结点的左子树，再后序遍历根结点的右子树，最后访问根结点。<br><code>//后序遍历二叉树：左—右—根<br>void backScanf(TreeNode<em> t)<br>{<br>if (t == NULL)<br>{<br>  return;<br>}<br>backScanf(t-&gt;left);<br>backScanf(t-&gt;right);<br>cout &lt;&lt; t-&gt;val &lt;&lt;” “;<br>}  </em></code><br>-层次遍历： 若二叉树为空，则空操作返回，否则从二叉树的第一层也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。代码思路讲解：若要实现按层遍历，那么应该先访问根结点，然后再访问遍历结点的两个子节点，放入容器，按照从左到右的顺序遍历到左子节点时就把其的两个子节点放到容器，最后输出的时候，就是从容器中按照顺序输出，先进先出，所以想到可以用队列做为数据容器。从上到下打印二叉树的规律：每一次打印一个节点的时候，如果该结点有子结点，则把该结点的子结点放到一个队列的末尾，接下来从队列的头部取出最早进入队列的结点，重复输出，直至队列中所有结点都被打印出来。<br><code>//层序遍历二叉树：从上到下，从左到右<br>void fromTopToBottomScanf(TreeNode t)<br>{<br>if (t==NULL)<br>{<br>  return;<br>}<br>deque&lt;TreeNode<em>&gt; dequeTreeNode;<br>dequeTreeNode.push_back(t);<br>while (dequeTreeNode.size())<br>{<br>  TreeNode</em> pNode = dequeTreeNode.front(); //依次取出队列中的头部元素进行打印<br>  dequeTreeNode.pop_front(); //<br>  cout &lt;&lt; pNode-&gt;val &lt;&lt; “ “;<br>  if (pNode-&gt;left)<br>  {  <pre><code>dequeTreeNode.push_back(pNode-&gt;left);  </code></pre>  }<br>  if (pNode-&gt;right)<br>  {<pre><code>dequeTreeNode.push_back(pNode-&gt;right);  </code></pre>  }<br>}<br>}  </code></li></ul></li><li>线索二叉树<br>在二叉树的结点上加上线索的二叉树称为线索二叉树，对二叉树以某种遍历方式（如先序、中序、后序或层次等）进行遍历，使其变为线索二叉树的过程称为对二叉树进行线索化。<br>对于n个结点的二叉树，在二叉链存储结构中有n+1个空链域，利用这些空链域存放在某种遍历次序下该结点的前驱结点和后继结点的指针，这些指针称为线索，加上线索的二叉树称为线索二叉树。<br>这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种。<br>线索二叉树中的线索能记录每个结点前驱和后继信息。为了区别线索指针和孩子指针，在每个结点中设置两个标志ltag和rtag。<br>当tag和rtag为0时，leftChild和rightChild分别是指向左孩子和右孩子的指针；否则，leftChild是指向结点前驱的线索(pre)，rightChild是指向结点的后继线索(suc)。由于标志只占用一个二进位，每个结点所需要的存储空间节省很多。<br>现将二叉树的结点结构重新定义如下：lchild、ltag、data、rtag、rchild；其中：ltag=0 时lchild指向左儿子；ltag=1 时lchild指向前驱；rtag=0 时rchild指向右儿子；rtag=1 时rchild指向后继。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;树型结构&quot;&gt;&lt;a href=&quot;#树型结构&quot; class=&quot;headerlink&quot; title=&quot;树型结构&quot;&gt;&lt;/a&gt;&lt;center&gt;&lt;strong&gt;树型结构&lt;/strong&gt;&lt;/center&gt;&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;树的定义&lt;br&gt;树是一种数据结构，它是由n（n&amp;gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：  &lt;ul&gt;
&lt;li&gt;每个节点有零个或多个子节点&lt;/li&gt;
&lt;li&gt;没有父节点的节点称为根节点；&lt;/li&gt;
&lt;li&gt;每一个非根节点有且只有一个父节点；&lt;/li&gt;
&lt;li&gt;除了根节点外，每个子节点可以分为多个不相交的子树。
    
    </summary>
    
    
      <category term="Tree" scheme="http://peisenli.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Node2Vec</title>
    <link href="http://peisenli.github.io/2019/07/25/Node2Vec/"/>
    <id>http://peisenli.github.io/2019/07/25/Node2Vec/</id>
    <published>2019-07-25T00:46:51.000Z</published>
    <updated>2019-07-25T01:12:26.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node2Vec-Scalable-Feature-Learning-for-Networks"><a href="#Node2Vec-Scalable-Feature-Learning-for-Networks" class="headerlink" title=" Node2Vec: Scalable Feature Learning for Networks "></a><center> Node2Vec: Scalable Feature Learning for Networks </center></h1><p><strong>核心内容</strong>：Node2Vec是论文Scalable Feature Learning for Networks提出的一种对网络中的节点学习连续特征表达的框架。通过将节点映射到maximizes the likelihood of preserving network neighborhoods of nodes的低维特征空间。定义了一个目标函数来保存节点的局部邻居结构是一种方法。论文的目标是提出一个灵活的学习节点表示的算法，既能将属于相同的社区的节点学习得到相近的嵌入；又能对有相似功能的节点（如在社区中的连接结构相似）学得相似的嵌入。借鉴Word2Vec提出了Node2Vec，并利用二阶随机游走产生节点社区。<br><a id="more"></a><br><strong>解决问题</strong>：现阶段方式缺少一种能学习可控长度特征的合理的目标函数。传统的PCA，多维缩放等降维方法通过maximize转特征空间后数据的方差，缺点是需要特征值分解，而且得到的样本表示在多种预测任务上的效果还不好。<br><strong>核心工作</strong>：</p><ol><li>借鉴World2Vec，提出Node2Vec。在网络空间提取连续的特征表示。</li><li>Skip-gram是主要思路来源。相似的词总是出现在相近的位置，网络中相似的节点也有这种特点。通过对一系列节点进行采样将网络序列化。不同的采样方法得到不同的特征表示。</li><li>设定目标函数：  <center><img src="https://i.loli.net/2019/07/23/5d36c8fd7ebf511007.png" alt="@P`05B9KK0A8D[SGCKEVY]W.png"><br></center><br>本文的特征抽取方式类似于聚类分析的非监督方法，本质上都是利用相邻节点之间的联系。文中提到了网络中的节点一般有两种相似度量：1.内容相似性，2.结构相似性。其中内容相似性主要是相邻节点之间的相似性，而结构上相似的的点并不一定是相邻的，可能隔得很远，这也是文中为何要把BFS和DFS相结合来选择邻居节点的原因。<br>文章的主要想法就是，利用SkipGram的方法，来为Networks抽取Representation。那么，自然，根据SkipGram的思路，最重要的就是定义这个Context，或者说是Neighborhood。​从文本的角度来说，这个Neighborhood当然就是当前Word周围的字，这个定义非常自然。但是对于Graph或者Network来说就来得没那么容易了。<br>文章阐述了一般所采用Depth-First Search或者是Breadth-First Search来Sample一个Node的周边Node的问题。简单来说，BFS比较容易有一个Microscopic的View而DFS容易有一个Macro-view，两者都有Representative的问题。<br>文章的核心思想是采用Random Walk来代替DFS或者BFS。文章定义了一种二阶的Random Walk，拥有两个参数，来控制多大的概率反复经过一些Node和控制所谓的Inward和Outward。总之，整个Random Walk的目的就是在DFS和BFS之间采取某种平衡。<br>文章虽然提出的是关于Node Feature提取的算法，但是Edge Feature也可以很容易从Node Feature导出。<br><strong>Github代码</strong>：<a href="https://github.com/aditya-grover/node2vec" target="_blank" rel="noopener">https://github.com/aditya-grover/node2vec</a><br>参考地址：<a href="https://blog.csdn.net/wen_fei/article/details/82416141" target="_blank" rel="noopener">https://blog.csdn.net/wen_fei/article/details/82416141</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Node2Vec-Scalable-Feature-Learning-for-Networks&quot;&gt;&lt;a href=&quot;#Node2Vec-Scalable-Feature-Learning-for-Networks&quot; class=&quot;headerlink&quot; title=&quot; Node2Vec: Scalable Feature Learning for Networks &quot;&gt;&lt;/a&gt;&lt;center&gt; Node2Vec: Scalable Feature Learning for Networks &lt;/center&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;核心内容&lt;/strong&gt;：Node2Vec是论文Scalable Feature Learning for Networks提出的一种对网络中的节点学习连续特征表达的框架。通过将节点映射到maximizes the likelihood of preserving network neighborhoods of nodes的低维特征空间。定义了一个目标函数来保存节点的局部邻居结构是一种方法。论文的目标是提出一个灵活的学习节点表示的算法，既能将属于相同的社区的节点学习得到相近的嵌入；又能对有相似功能的节点（如在社区中的连接结构相似）学得相似的嵌入。借鉴Word2Vec提出了Node2Vec，并利用二阶随机游走产生节点社区。&lt;br&gt;
    
    </summary>
    
    
      <category term="Network Embedding" scheme="http://peisenli.github.io/tags/Network-Embedding/"/>
    
  </entry>
  
  <entry>
    <title>Resume</title>
    <link href="http://peisenli.github.io/2019/07/13/Resume/"/>
    <id>http://peisenli.github.io/2019/07/13/Resume/</id>
    <published>2019-07-13T11:21:08.000Z</published>
    <updated>2019-08-04T07:23:04.205Z</updated>
    
    <content type="html"><![CDATA[<p><div style="float:right"><img src="https://i.loli.net/2019/07/06/5d2091a117fd054997.png" width="200"></div>   </p><h4 id="PeisenLi"><a href="#PeisenLi" class="headerlink" title="PeisenLi"></a><span style="color:#e33a00"><strong>PeisenLi</strong></span></h4><p><strong>硕士/计算机科学与技术<br>本科/电子信息工程<br>Github：<a href="http://github.com/peisenli" target="_blank" rel="noopener">http://github.com/peisenli</a> </strong><br><strong>Skill：多项大学生创新创业项目及电子类全国大学生竞赛经验</strong></p><h6 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a><span style="color:#fd3300"><strong>联系方式</strong></span></h6><p><strong>Email：<a href="mailto:peisenli1@gmail.com" target="_blank" rel="noopener">peisenli1@gmail.com</a><br>QQ：577602601<br>电话：17628090959</strong><br><a id="more"></a></p><h3 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a><span style="color:#e33a00"><strong>项目经历</strong></span></h3><p><strong>• 2015年中央高校科研项目“移动式机械手臂的设计”<br>• 2015年大学生创新创业项目“基于MK60的智能车设计”<br>• 2016年大学生创新创业项目“基于STM32的智能探测机器”<br>• 2017年本科生科研项目“基于互联网语音技术的智能家居管理系统”</strong></p><h3 id="获奖证书"><a href="#获奖证书" class="headerlink" title="获奖证书"></a><span style="color:#e33a00"><strong>获奖证书</strong></span></h3><p><strong>• 优秀学生干部<br>• 2015年中国机器人大赛旅游类二等奖<br>• “博创杯”全国大学生嵌入式大赛一等奖<br>• 2015年全国大学生电子设计大赛省一等奖<br>• 2016年中国机器人大赛水下巡游组一等奖<br>• 2016年中国机器人大赛擂台标准组二等奖</strong></p><h3 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a><span style="color:#e33a00"><strong>专业技能</strong></span></h3><p><strong>• 熟练C/C++语言嵌入式程序设计<br>• 熟悉JAVA、Python、Android程序设计<br>• 熟练使用51单片机、MK60以及Cubieboard板卡<br>• 具有较强的专业英语阅读能力，轻松阅读国外专业相关文档<br>• 硬件检测员实习经验：需求设计测试用例，执行测试和收集测试结果，找出硬件问题并书写测试报告；发现并提出产品的功能和性能问题；</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div style=&quot;float:right&quot;&gt;&lt;img src=&quot;https://i.loli.net/2019/07/06/5d2091a117fd054997.png&quot; width=&quot;200&quot;&gt;&lt;/div&gt;   &lt;/p&gt;
&lt;h4 id=&quot;PeisenLi&quot;&gt;&lt;a href=&quot;#PeisenLi&quot; class=&quot;headerlink&quot; title=&quot;PeisenLi&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#e33a00&quot;&gt;&lt;strong&gt;PeisenLi&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;硕士/计算机科学与技术&lt;br&gt;本科/电子信息工程&lt;br&gt;Github：&lt;a href=&quot;http://github.com/peisenli&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://github.com/peisenli&lt;/a&gt; &lt;/strong&gt;&lt;br&gt;&lt;strong&gt;Skill：多项大学生创新创业项目及电子类全国大学生竞赛经验&lt;/strong&gt;&lt;/p&gt;
&lt;h6 id=&quot;联系方式&quot;&gt;&lt;a href=&quot;#联系方式&quot; class=&quot;headerlink&quot; title=&quot;联系方式&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#fd3300&quot;&gt;&lt;strong&gt;联系方式&lt;/strong&gt;&lt;/span&gt;&lt;/h6&gt;&lt;p&gt;&lt;strong&gt;Email：&lt;a href=&quot;mailto:peisenli1@gmail.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;peisenli1@gmail.com&lt;/a&gt;&lt;br&gt;QQ：577602601&lt;br&gt;电话：17628090959&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Resume" scheme="http://peisenli.github.io/tags/Resume/"/>
    
  </entry>
  
  <entry>
    <title>The application of machine learning in network security</title>
    <link href="http://peisenli.github.io/2019/07/13/The-application-of-machine-learning-in-network-security/"/>
    <id>http://peisenli.github.io/2019/07/13/The-application-of-machine-learning-in-network-security/</id>
    <published>2019-07-13T11:05:40.000Z</published>
    <updated>2019-07-22T08:52:24.304Z</updated>
    
    <content type="html"><![CDATA[<h2 id="机器学习在网络安全中的应用综述"><a href="#机器学习在网络安全中的应用综述" class="headerlink" title="机器学习在网络安全中的应用综述"></a><center>机器学习在网络安全中的应用综述</center></h2><p>摘要：随着互联网人口在线人数的增长，在互联网背景下各行业爆发了很多问题，例如信息的加密和治理，可疑的营销信息，特别是网络安全问题不断的锐化。机器学习和人工智能的诞生，对网络发展既是机遇也是挑战，它用于搜索引擎，图像分类，语音识别等，而利用网络上的安全问题融合机器学习算法，成为网络安全技术的一个新的研究领域，利用机器学习得到的模型和方法，对网络安全攻击行为自动进行判断和预测，进而进行防御，是非常具有利用前景和使用价值，本文是对当前机器学习在网络安全中的不同应用进行总结和概述。<br>关键词：机器学习 网络安全 入侵防御<br>Abstract: with the growth of the number of Internet online population, in the context of the Internet industry broke out a lot of problems, such as the encryption and governance of information, suspicious marketing information, especially the sharpening of network security issues. The birth of machine learning and artificial intelligence, is both opportunity and challenge of network development, which is used to search engine, image classification, speech recognition, etc., and the use of machine learning algorithm on the network security problem fusion, become a new research field of network security technology, using machine learning model and method of judgment and projections for network security attacks automatically, and defend, is very has the advantage of future and use value, this article is for the current machine learning summarize its application in network security.<br>Key words: machine learning; network security; defense<br><a id="more"></a><br>1.引言<br>网络安全问题的爆发在如今在大量用户使用下的背景下越来越引人关注，各种行业都没有实施足够的流程来确保的隐私和安全，被黑客攻击是相当普遍的，这并不奇怪。只需打开错误的电子邮件就可以捕获感染，在线信誉良好的公司共享信息可能会导致敏感的数据泄露，任何设备都可能成为僵尸网络中的僵尸而没有明显的迹象。对于这些问题的研究在大数据时代，人工智能、数据挖掘以及机器学习的相关内容不断发酵，为网络安全行为分析提供了很好的方法，对于机器学习驱动的安全算法在速度、准确性以及隐私安全方面得到了优化，速度方面机器学习训练此类算法比收集定义恶意行为者的规则要快得多，可以轻松分析大量数据; 因此可以提供更精确的结果并且还可以实现个性化。相比一些传统的方法，如深度包检测、DNS黑名单等，在模型建立之后不需要在对用户信息进行深度分析，优化了传统方法的隐私性。<br>机器学习技术以其独特的适应性、可扩展性和快速适应新挑战和未知挑战的潜力而被应用于科学中的许多领域。网络安全是一个快速发展的领域，在社交网络、云与web技术、网上银行、移动环境、智能电网等领域都取得了显著的进步，需要人们的高度关注。针对计算机安全领域中涉猎广泛的问题，人们成功地运用了多种机器学习方法用于解决计算机和信息安全方面的广泛问题。本文归纳了机器学习在网络安全中的不同应用。<br>2.机器学习概述<br>机器学习就是让计算机从数据中进行自动学习，得到某种知识。其通常指一类问题以及解决这类问题的方法，即如何从观测数据中寻找规律，并利用学习到的规律对未知或无法观测的数据进行预测。机器学习是对能通过经验自动改进的计算机算法的研究[1]。<br>机器学习算法可以分为线性模型和非线性模型；按照学习准则的不同，机器学习算法也可以分为统计方法和非统计方法。但一般来说，我们会按照训练样本提供的信息以及反馈方式的不同，将机器学习算法分为以下几类：<br>如果机器学习的目标是通过建模样本的特征x和标签y之间的关系： y = f(x, θ)，并且训练集中每个样本都有标签，那么这类机器学习称为监督学习。<br>无监督学习是指从不包含目标标签的训练样本中自动学习到一些有价值的信息。典型的无监督学习问题有聚类、 密度估计、特征学习、降维等。<br>强化学习是一类通过交互式来学习的机器学习算法。在强化学习中，智能体根据环境的状态做出一个动作，并得到即时或延时的奖励。智能体在和环境的交互中不断学习并调整策略，以取得最大化的期望总回报。<br>从机器学习的本质上来分析，广泛来讲机器学习是预测事物的过程，通常基于他们过去所做的事情。在大量数据集中的基础上通过对数学技术的引入，来构建机器行为模型，这个模型试图在您的数据中找到可以帮助您预测接下来会发生什么的关系。即机器在对各时段数据进行分析、运算的基础上，来实现对未来的科学预测。从技术上来讲，机器学习使用统计方法使用一组输入数据预测目标变量的值即尝试解决在给定特征集X的输入的情况下预测变量Y的值。这就是机器学习所研究的问题及内容。<br>机器学习在网络安全中应用主要体现在机器学习基于网络安全方面的数据进行分析，构建模型帮助用户来有效的对网络安全事件作出及时的响应，减少人力资料的浪费，更有助于清除产品中的恶意软件，进而确保网络系统的安全与稳定。<br>3.实际应用方法<br>3.1.网络安全中的应用<br>机器学习在网络安全中应用极为广泛，网络安全检测主要指对网络的安全状态或者面临的风险进行分析和检测，对不同接入网络的行为进行分析和控制，都需要用到机器学习算法，最后发现潜在的威胁或正在进行的攻击。机器学习技术在网络入侵检测技术、僵尸网络的检测以及恶意加密流量的识别中的研究都极其具有价值。<br>网络入侵检测系统用于识别导致网络中系统机密性、完整性或可用性受到破坏的恶意网络活动。许多入侵检测系统都是基于机器学习技术的，因为它们对新的未知攻击具有适应性。<br>在网络入侵检测中常用的机器学习算法包括神经网络、遗传算法、决策树以及支持向量机等[2]。对于机器学习算法主要的问题是对数据进行分析以及建立合适的模型，然后形成模型对未知问题进行处理，使用机器学习技术解决安全问题的第一步就是要进行问题的抽象和定义将安全问题映射为机器学习能够解决的分类、聚类及降维等问题[3]。<br>其主要问题在于应用这些算法需要有大量的数据，这些数据来自抽象的安全问题数据，如木马的检测、伪基站检测、虚拟化安全、信用卡欺诈、用户身份认证异常、恶意异常入侵检测、取证分析、网络舆情等一些结构化或者非结构化数据，要想应用到数据分析中还需要进行数据处理，数据清洗，得到结构化数据，简单来说就是保留最大的信息熵，维度较低的对分析有利的特征数据，这个过程就是提高数据的质量，保障构建模型学习的效果，对数据进行清洗及归一化等预处理过程，在这些安全问题数据构建模型前还需要进行大数据处理的基本其他数据分割、特征提取等步骤，之后处理后的数据才能构建模型[4]。模型构建是机器学习在网络安全应用的中心环节，这是算法实现的过程，也就是利用之前提及的机器学习方法进行实现，再利用中间构建的模型进行验证，根据评价标准投入使用，进行安全漏洞预测，常见的一下安全问题及处理方法如下图一所示。讲不同的安全入侵问题抽象成不同的处理方式，再利用相应的机器学习算法进行处理。<br><img src="https://i.loli.net/2019/05/12/5cd82f9828a2c.png" alt="图片1.png">  </p><p><center>图1 安全问题抽象  </center><br>目前在入侵检测中很多系统都是利用融合匹配度和遗传算法，对冗余规则进行裁剪，对有效规则进行过滤，在这种算法驱动的系统验证的时候可行性很高[5]。<br>上面所提及到的算法是现在最新的研究的一些基础支撑，在这之上还有许多改进的算法，传统支持向量机算法是利用已知标签的训练样本来进行预测或检测的监督学习算法. 与其他机器学习算法类似，传统方式也易受到利用系统来进行攻击的入侵者，文献[6]中提出了将博弈论与DSVM算法结合的网络入侵检测方法提高了正确性与性能。另外决策树和k邻近算法混合检测也是系统常用的机器学习算法，在网络安全问题抽象中，很多都是分类问题，对于这一方法的多分类问题也是网络安全研究的主要内容[7]。<br>而在现在较新的研究是将深度学习融入入侵检测，将入侵检测系统又提高了一个阶级。针对深度学习算法的安全检测，以及利用神经网络和支持向量机开发了一个针对分布式拒绝服务攻击的告警分类系统[9]，与集中式入侵检测系统相比，在训练数据不足的情况下，该方案的准确率较高。此外，所提出的方法声称可以减少能源消耗[10]。<br>基于神经网络的入侵检测方法中人工神经网络的灵感来自生物神经网络。它通过树突接收信号，并通过轴突进行输出。计算在核中进行，整个网络由一系列神经元组成，而深度学习中的每个神经元完成三个动作：一是以加权的方式累积来自各种其他神经元或输入的输入，第二个动作总结了所有输入信号，三是基于求和值，调用激活函数得到输出。这是神经网络的基本步骤，在文献[11]中进行了深度学习算法下的TOR匿名流量检测实验。<br>在进行流量检测中，对比各种分类器中，基于随机森林和深度学习的方法比其他方法表现更好，如表所示。此次实验中使用的数据集比典型的基于深度学习的系统要小。随着训练数据的增加，基于深度学习和随机森林分类器的性能将进一步提高。<br><img src="https://i.loli.net/2019/05/12/5cd82f97ebd04.png" alt="图片2.png">  </p><p><center> 表1 Tor流量检测实验 </center><br>僵尸网络由一系列被恶意软件感染的主机组成，受到一个被称为僵尸主控机远程控制。僵尸网络可以被用于执行一系列恶意活动，例如分布式拒绝服务攻击、发送垃圾邮件、窃取个人信息、执行分布式计算任务等[12]。从网络流量角度分析，僵尸网络的通信行为从流量角度分析具有一定的关联性和群体相似性，因此许多研究者通过聚类方法分析不同的网络流量特征，从而检测僵尸网络。<br>对于僵尸网络的检测，首先得进行特征提取，这些特征可以是网络流量特征，除了提取僵尸网络流量的流量特征外[13]，僵尸网络的通信行为往往和一些恶意事件在时间或空间上有关联。对于模型构建算法包括随机森林算法、随机游走聚类算法及自适应特征集和训练分类标签的LS-SVM算法[14]，都有很好的效果，但是对于目前日益增长的网络空间，对于其安全分析具有巨大挑战，因此随着僵尸网络传播、控制及攻击形式的多样化，如何对僵尸网络流量进行有效的特征提取、如何能够全面提高各种类型僵尸检测效率及精度，都是需要进一步深入研究的方向。<br>总的来说网络入侵检测、僵尸网络检测即根据网络流量数据或主机数据来判断系统的正常行为或异常行为，可以抽象为分类问题。根据入侵检测系统中检测引擎使用方法的不同，网络入侵检测分为误用检测、异常检测以及混合检测。误用检测是以已知攻击为特征，将入侵行为与异常行为按照已知的特征区分开来。而这些实现及算法都离不开机器学习，在目前的各种分类器中，基于随机森林和深度学习的方法的检测方法是值得研究的一个方向。<br>3.2.系统硬件及软件安全应用<br>系统硬件安全问题包括硬件设备身份认证安全问题、系统硬件与外部设备进行信息交换或通信时常常会遇到信息泄露、中间人攻击等问题，例如常见的物理层边信道攻击、伪基站， MAC地址伪造，而机器学习在硬件设备也有很广泛的 的应用。<br>设备身份认证技术是将信号分析与处理技术与机器学习技术相结合．目前该领域的相关研究成果主要基于暂态信号、调制信号、频谱响应以及传感器响应产生的指纹及人脸特征等其他生物特征进行设备身份识别，最大程度的确保了网络设备的硬件安全问题。现有的硬件设备主要利用单一或少量生物特征要素是一个重大的突破，但是对于现有方法在采集数据时可能都会涉及到用户隐私，因此在未来的研究中要加强用户隐私保护[15]。<br>对于检测伪基站，主要包括在线检测和离线学习两部分．在线检测由若干单类SVM、神经网络等构成的异常检测器组成，对于其监控和数据分析确保都有着重要的价值[16]。<br>路由系统和域名系统的安全性是网络安全中最基本的要素，异常路由的检测是通过提取当前BGP更新消息的特征或时序特征，将当前流量识别为正常路由或异常路由，该问题可以抽象为机器学习二分类问题，是机器学习算法的基本应用[14]。<br>基于机器学习的域名检测模型的建立主要基于网络特征，对于新地址空间映射的恶意域名无法进行检测。域名分析系统从多个来源的已知的域名数据中提取了短期域名、域名的访问比例、不同IP地址的个数、不同国家的数量、共享IP的数量、不同TTL值的数量、域名的长度等行为特征进行模型训练，在进行异常检测，取得了一定的成效[17]。<br>4.总结<br>在现如今的大量网络安全数据背景下，机器学习的应用已经成为一种趋势，特别是最近比较火热的人工智能和深度学习，这些人工智能系统通常有权以自动方式进行推算和决策，而无需人工参与日常工作，减少了人力资源浪费。另外，其进行大规模分析以找到大海捞针中的众所周知的针头并不是一个挑战。机器学习可以模拟安全分析师的相同手动过程，通过使用强大的算法创建学习行为模式的模型，提供对异常或风险活动的自动分析。但是，它们也可能会受到损害，而且很长一段时间都无法检测到。其次，机器学习或人工智能程序进行特定扣减和决策的原因并不总是对监督者立即明确。意味着即使检测到违规，其目的也可能保持不透明。也会对系统造成损害，对于这方面的研究还需要投入更多精力。<br>参考文献<br>[1]周志华. 机器学习. 清华大学出版社, 北京, 2016. ISBN 978-7-302-206853-6.<br>[2]张夏.基于机器学习算法的网络入侵检测[J].现代电子技术,2018,41(03):124-127.<br>[3]朱琨,张琪.机器学习在网络入侵检测中的应用[J].数据采集与处理,2017,32(03):479-488.<br>[4]张蕾,崔勇,刘静,江勇,吴建平.机器学习在网络空间安全研究中的应用[J].计算机学报,2018,41(09):1943-1975.<br>[5] N. Lu, S. Mabu, T. Wang, and K. Hirasawa, “An Efficient Class Association Rule-Pruning Method for Unified Intrusion Detection System using Genetic Algorithm”, in IEEJ Transactions on Electrical and Electronic Engineering, Vol. 8, Issue 2, pp. 164 – 172, January 2, 2013.<br>[6]Rui Zhang and Quanyan Zhu. A Game -Theoretic Approach to Design Secure and Resilient Distributed Support Vector Machines [J]. arXiv:1802.02907v1 [stat.ML] Feb., 2018.<br>[7]陈萍.网络入侵检测系统的研究与实现[D].山东大学,2008.<br>[8]成汶洲,张亮.浅谈分布式入侵检测系统[J].企业科技与发展,2018(07):93-94.<br>[9]王秀英.分布式网络时序关联入侵攻击行为检测系统设计[J].现代电子技术,2018,41(03):107-110.<br>[10]闫友彪,陈元琰.机器学习的主要策略综述[J].计算机应用研究,2004,21(7):4-10.<br>[11]Habibi Lashkari A., Draper Gil G., Mamun M. and Ghorbani A., “Characterization of Tor Traffic using Time based Features,” Proceedings of the 3rd International Conference on Information Systems Security and Privacy – Volume 1, pages 253-262, 2017.<br>[12]陈瑞东,赵凌园,张小松.基于模糊聚类的僵尸网络识别技术[J].计算机工程,2018,44(10):46-50.<br>[13]金渝筌,谢彬,朱毅.基于通信相似度的僵尸网络节点检测方法[J].网络与信息安全学报,2018,4(10):31-38.<br>[14]刘国璧,袁宏俊.人工蜂群算法优化LS-SVM的预测模型[J].湖南文理学院学报(自然科学版),2018,30(02):27-29+94.<br>[15]王金海,陈泓宇,崔军,戴华林.生物特征识别系统安全加固方法[J].计算机工程与设计,2018,39(12):3661-3666.<br>[16]孙旭敏. 伪基站信息检测与识别算法研究[D].内蒙古大学,2018.<br>[17]蒋磊.BGP路由协议的基本原理分析[J].江苏科技信息,2018,35(31):35-37.<br>[18]殷聪贤. 基于大数据分析的恶意域名检测技术研究与实现[D].北京邮电大学,2018<br>[19]刘阚蓉,李丹,裴梦迪,张家熹.机器学习算法在网络入侵检测中的应用综述[J].赤峰学院学报(自然科学版),2018,34(12):44-46.<br>[20]张舒婷.机器学习在网络安全中的应用[J].电子技术与软件工程,2018(19):212.<br>[21]陈捷,丛键,张海燕.基于机器学习的行为分析技术在下一代智能化网络安全体系中的应用[J].通信技术,2018,51(08):1956-1960.<br>[22]马若龙. 基于卷积神经网络的未知和加密流量识别的研究与实现[D].北京邮电大学,2018.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;机器学习在网络安全中的应用综述&quot;&gt;&lt;a href=&quot;#机器学习在网络安全中的应用综述&quot; class=&quot;headerlink&quot; title=&quot;机器学习在网络安全中的应用综述&quot;&gt;&lt;/a&gt;&lt;center&gt;机器学习在网络安全中的应用综述&lt;/center&gt;&lt;/h2&gt;&lt;p&gt;摘要：随着互联网人口在线人数的增长，在互联网背景下各行业爆发了很多问题，例如信息的加密和治理，可疑的营销信息，特别是网络安全问题不断的锐化。机器学习和人工智能的诞生，对网络发展既是机遇也是挑战，它用于搜索引擎，图像分类，语音识别等，而利用网络上的安全问题融合机器学习算法，成为网络安全技术的一个新的研究领域，利用机器学习得到的模型和方法，对网络安全攻击行为自动进行判断和预测，进而进行防御，是非常具有利用前景和使用价值，本文是对当前机器学习在网络安全中的不同应用进行总结和概述。&lt;br&gt;关键词：机器学习 网络安全 入侵防御&lt;br&gt;Abstract: with the growth of the number of Internet online population, in the context of the Internet industry broke out a lot of problems, such as the encryption and governance of information, suspicious marketing information, especially the sharpening of network security issues. The birth of machine learning and artificial intelligence, is both opportunity and challenge of network development, which is used to search engine, image classification, speech recognition, etc., and the use of machine learning algorithm on the network security problem fusion, become a new research field of network security technology, using machine learning model and method of judgment and projections for network security attacks automatically, and defend, is very has the advantage of future and use value, this article is for the current machine learning summarize its application in network security.&lt;br&gt;Key words: machine learning; network security; defense&lt;br&gt;
    
    </summary>
    
    
      <category term="network security" scheme="http://peisenli.github.io/tags/network-security/"/>
    
  </entry>
  
  <entry>
    <title>MPI Programming Project</title>
    <link href="http://peisenli.github.io/2019/05/11/MPI-Programming-Project/"/>
    <id>http://peisenli.github.io/2019/05/11/MPI-Programming-Project/</id>
    <published>2019-05-11T13:44:31.000Z</published>
    <updated>2019-07-13T10:53:48.149Z</updated>
    
    <content type="html"><![CDATA[<p>一、实验目的<br>1、掌握分布式并行计算基础<br>2、掌握MPI分布式并行基本操作<br>3、利用MPI进行程序设计，寻找1000000000以内的素数<br>二、实验环境<br>PC、Ubuntu16.04、MPICH<br>三、实验要求<br>Part 1: Modify the parallel Sieve of Eratosthenes program in class so that the program  does NOT set aside memory for even integers.<br><a id="more"></a><br>Part 2: Modify the parallel Sieve of Eratosthenes program in Part 1 so that each process of the program finds its own sieving primes via local computations instead of broadcasts.<br>四、实验步骤<br>1、在进行MPI程序设计之前确保Ubuntu、GCC环境可用之后再进行MPICH安装，如下所示安装GCC环境后确保正常。<br><img src="https://i.loli.net/2019/05/11/5cd6d2bbde6c0.png" alt="1.png"><br>2、进行MPI程序设计需要进行MPICH安装，直接使用sudo apt-get install –y mpich,如下图所示，已经安装完成。<br><img src="https://i.loli.net/2019/05/11/5cd6d2bb5e7b7.png" alt="图片1.png"><br>安装完成后进行MPI环境测试，确保正常使用，使用mpicc –v进行查看是否安装成功。<br><img src="https://i.loli.net/2019/05/11/5cd6d2bbeee22.png" alt="图片2.png"><br>3、使用老师所给的例程进行环境测试，进行编译运行，编译如下：<br><img src="https://i.loli.net/2019/05/11/5cd6d2bb9a97f.png" alt="图片3.png"><br>使用mpicc sieve0.c –o sieve0.o –lm命令后生成可执行文件sieve.o，使用mpirun –np 8 ./sieve.o 10000000000进行测试出现一下情况。<br><img src="https://i.loli.net/2019/05/11/5cd6d2bbb5feb.png" alt="图片4.png"><br>需要在使用此命令行时添加参数–allow-run-as-root后正常，环境安装完成。当改变参数时发现程序运行时间无多大变化，如下所示：<br><img src="https://i.loli.net/2019/05/11/5cd6d2bbb31a7.png" alt="图片5.png"><br>进行排查后发现自己的电脑的参数无法达到8进程所以使用4进程和8进程时间无多大区别，弄清自己PC的型号最大为4个进程再进行实验设计。<br><img src="https://i.loli.net/2019/05/11/5cd6d39d6f679.png" alt="图片6.png"><br>4、根据实验要求进行程序设计，完成Part1内容，预先对寻求素数中的偶数进行移除处理，不再为偶数进行计算。当移除偶数时，需要对每个进程中存取数组进行从新定义，每个进程的最低值和最高值如下所示：<br><img src="https://i.loli.net/2019/05/11/5cd6d39d71936.png" alt="图片7.png"><br>由于数据每个进程分配会出现不一致性，其处理方式如下所示：</p><pre><code>proc0_size = (n - 1) / p;if ((3 + 2*(proc0_size-1)) &lt; (int) sqrt((double) (3+2*(n-1)))) {  if (!id) printf (&quot;Too many processes\n&quot;);  MPI_Finalize();  exit (1);}</code></pre><p>Part1之中去除偶数之后在进程中进行计算的核心代码如下所示：<br><img src="https://i.loli.net/2019/05/11/5cd6d39d864d7.png" alt="图片8.png"><br>5、根据实验要求对Part2进行程序设计，其主要修改如下图所示，对每个进程的分配如下所示：<br><img src="https://i.loli.net/2019/05/11/5cd6d39d82ba9.png" alt="图片9.png"><br>在原来设计的基础之上不进行数据广播，需要进行进程本地内存使用保存数据，在每个进程中进行素数检查。<br><img src="https://i.loli.net/2019/05/11/5cd6d39d952df.png" alt="图片10.png"><br>6、根据具体的实验进行对比，完成MPI实验报告设计<br>五、实验结果<br>根据不同的实验方法进行程序设计，在具体的实验中得到实验结果，时间(s)效果如下所示：<br>|process     |Sieve0         |Part1            | Part2       |<br>| ——–   | —–:        | :—-:       | :—–:     |<br>|2             |209.828280     |108.456367    |343.496301   |<br>|4             |182.311808     |96.609751        |202.671327   |<br><img src="https://i.loli.net/2019/05/11/5cd6d39dbbfe0.png" alt="图片11.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、实验目的&lt;br&gt;1、掌握分布式并行计算基础&lt;br&gt;2、掌握MPI分布式并行基本操作&lt;br&gt;3、利用MPI进行程序设计，寻找1000000000以内的素数&lt;br&gt;二、实验环境&lt;br&gt;PC、Ubuntu16.04、MPICH&lt;br&gt;三、实验要求&lt;br&gt;Part 1: Modify the parallel Sieve of Eratosthenes program in class so that the program  does NOT set aside memory for even integers.&lt;br&gt;
    
    </summary>
    
    
      <category term="MPICH  分布式" scheme="http://peisenli.github.io/tags/MPICH-%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Chat based on Socket</title>
    <link href="http://peisenli.github.io/2019/05/11/Chat-based-on-Socket/"/>
    <id>http://peisenli.github.io/2019/05/11/Chat-based-on-Socket/</id>
    <published>2019-05-11T13:35:33.000Z</published>
    <updated>2019-07-13T10:53:48.147Z</updated>
    
    <content type="html"><![CDATA[<p>套接字库加载：<br>Socket socket=new Socket();<br>ServerSocket server=new ServerSocket();<br><a id="more"></a><br>套接字初始化：<br>客户端：</p><p>public void setUpNet(){</p><pre><code>    try{        Socket s=new Socket(ipInput.getText(),25003);        InputStreamReader StreamReader=new InputStreamReader(s.getInputStream());        reader=new BufferedReader(StreamReader);        writer=new PrintWriter(s.getOutputStream());        System.out.println(&quot;connect is vivasible!&quot;);        JOptionPane.showMessageDialog(null, &quot;连接成功&quot;);    }catch(IOException ex){        ex.printStackTrace();        JOptionPane.showMessageDialog(null, &quot;连接失败&quot;);    }}  </code></pre><p>服务端： </p><p>openServiceBtn.addActionListener(new ActionListener(){</p><pre><code>@Overridepublic void actionPerformed(ActionEvent e) {    // TODO Auto-generated method stub    try{        ServerSocket ss=new ServerSocket(25003);        while(true){            Socket s=ss.accept();            socketList.add(s);            final DataInputStream bufIn = new DataInputStream(                    s.getInputStream());            final BufferedOutputStream bufOut= new BufferedOutputStream(                    s.getOutputStream());            new Thread(new ServerThread(s)).start();            }    }catch(Exception e3){        JOptionPane.showConfirmDialog(null,&quot;&quot;);    }}});</code></pre><p>接收聊天内容线程：</p><p>public class ClientThread implements Runnable {</p><pre><code>@Overridepublic void run() {    // TODO Auto-generated method stub</code></pre><p>String content;<br>try{</p><pre><code>while((content=reader.readLine())!=null){    System.out.println(&quot;read:&quot;+content);    chatJText.append(content+&quot;\n&quot;);}</code></pre><p>}catch(Exception e){<br>    e.printStackTrace();<br>}<br>        }</p><pre><code>}</code></pre><p>聊天内容发送按钮：(类本身作为监听器)  </p><p>if(e.getSource()==sendBtn){<br>            try{<br>    //读取TextFiled中获取数据<br>        writer.println(nameInput.getText()+”说：”+inputTfd.getText());<br>        writer.flush();}<br>            catch(Exception ex){<br>                ex.printStackTrace();<br>            }<br>            inputTfd.setText(“”);<br>            inputTfd.requestFocus();<br>        }</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;套接字库加载：&lt;br&gt;Socket socket=new Socket();&lt;br&gt;ServerSocket server=new ServerSocket();&lt;br&gt;
    
    </summary>
    
    
      <category term="Socket" scheme="http://peisenli.github.io/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>手机通信录备份设计</title>
    <link href="http://peisenli.github.io/2019/05/10/%E6%89%8B%E6%9C%BA%E9%80%9A%E4%BF%A1%E5%BD%95%E5%A4%87%E4%BB%BD%E8%AE%BE%E8%AE%A1/"/>
    <id>http://peisenli.github.io/2019/05/10/手机通信录备份设计/</id>
    <published>2019-05-10T07:32:32.000Z</published>
    <updated>2019-07-13T10:53:48.151Z</updated>
    
    <content type="html"><![CDATA[<p>一、设计目的  </p><ol><li>利用课程所学知识进行面向对象程序设计，理解类、对象、封装等概念。  </li><li>熟练掌握C++程序设计  </li><li>学会使用UML分析  </li><li>完成手机通信录备份设计<a id="more"></a>       二、设计要求<br>手机通信录备份：  </li><li>实现可以将通信录备份到预先设定的服务器数据库中。  </li><li>数据库使用SQLite。  </li><li>同时备份到TF卡中。  </li><li>Android下通信部分用C++完成，界面用JAVA完成，之间采用JNI调用。  </li><li>需要有完整的设计文档。  </li></ol><p>三、设计需求<br>实验环境：Android Studio3.2、Linux服务器、SQLite<br>设计语言：C++、Java<br>四、设计步骤<br>在进行系统设计之前进行系统分析，确定人员分工，分工完成后进行通信录备份系统设计。  </p><p>1.安卓端设计<br>安卓端设计采用Android Studio3.2，设计使用的版本是Android6.0，根据设计要求首先需要进行本地文件备份，然后进行通信录数据上传到服务器中，界面包含两个Button按钮，两个TextView以及一个ListView，其中点击第一个Button按钮进行通信录数据读取后写入Txt文件并存入本地TF卡中，第二个Button按键将Txt文件通过网络通信传到服务器中，TextView用于显示备份状态，另外ListView显示上传的通信录信息，并显示是否通信成功，初始界面如下所示：<br>通信录读取过程主要是对安卓客户端的通信录的数据库进行读取，读取和写入TF卡都需要进行权限申请，注意Android6.0以上的权限需要进行动态申请。设计动态申请权限包括内存读写以及通信录读写。实现如下所示：<br><code>codes</code><br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST_EXTERNAL_STORAGE = <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String[] PERMISSIONS_STORAGE = &#123;  </span><br><span class="line">        <span class="string">"android.permission.READ_EXTERNAL_STORAGE"</span>,  </span><br><span class="line">        <span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>,  </span><br><span class="line">        <span class="string">"android.permission.READ_CONTACTS"</span>,  </span><br><span class="line">        <span class="string">"android.permission.WRITE_CONTACTS"</span>&#125;;  </span><br><span class="line"><span class="comment">//确定动态权限获取  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> verifyStoragePermissions(Activity activity) &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="comment">//检测是否有写的权限  </span></span><br><span class="line">        <span class="keyword">int</span> permission = ActivityCompat.checkSelfPermission(activity,  </span><br><span class="line">                <span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (permission != PackageManager.PERMISSION_GRANTED) &#123;  </span><br><span class="line">            <span class="comment">// 没有写的权限，去申请写的权限，会弹出对话框  </span></span><br><span class="line">            ActivityCompat.requestPermissions(activity, PERMISSIONS_STORAGE, REQUEST_EXTERNAL_STORAGE);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (ContextCompat.checkSelfPermission(context,android.Manifest.permission.READ_CONTACTS)  </span><br><span class="line">                !=PackageManager.PERMISSION_GRANTED) &#123;  </span><br><span class="line">            ActivityCompat.requestPermissions((Activity) context,  </span><br><span class="line">                    <span class="keyword">new</span> String[]&#123;android.Manifest.permission.READ_CONTACTS&#125;,  </span><br><span class="line">                    <span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">        e.printStackTrace();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//另外，在安卓中的XML文件AndroidManifest.xml也需要加入权限：  </span></span><br><span class="line">&lt;uses-permission <span class="string">android:</span>name=<span class="string">"android.permission.READ_CONTACTS"</span>/&gt;  </span><br><span class="line">&lt;uses-permission <span class="string">android:</span>name=<span class="string">"android.permission.WRITE_CONTACTS"</span>/&gt;  </span><br><span class="line">&lt;uses-permission <span class="string">android:</span>name=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;  </span><br><span class="line">&lt;uses-permission <span class="string">android:</span>name=<span class="string">"android.permission.INTERNET"</span></span><br></pre></td></tr></table></figure></p><p>Android手机的通讯录联系人全部都存在系统的数据库中，如果须要获得通讯里联系人的信息就须要访问系统的数据库，才能将信息拿出来。对数据库查询代码主要如下所示：<br><code>codes</code><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Cursor <span class="built_in">cursor</span> = context  </span><br><span class="line">        .getContentResolver()  </span><br><span class="line">        .query(ContactsContract.Data.CONTENT_URI,  </span><br><span class="line">                <span class="keyword">new</span> <span class="keyword">String</span>[]&#123;StructuredName.DISPLAY_NAME,  </span><br><span class="line">                       Data.RAW_CONTACT_ID&#125;, Data.MIMETYPE + <span class="string">"= ?"</span>,  </span><br><span class="line">                <span class="keyword">new</span> <span class="keyword">String</span>[]&#123;StructuredName.CONTENT_ITEM_TYPE&#125;, <span class="keyword">null</span>);  </span><br><span class="line"><span class="comment">// 得到电话号码的游标  </span></span><br><span class="line">Cursor mobileCursor = context.getContentResolver().query(  </span><br><span class="line">        ContactsContract.Data.CONTENT_URI,  </span><br><span class="line">        <span class="keyword">new</span> <span class="keyword">String</span>[]&#123;Phone.NUMBER&#125;,  </span><br><span class="line">        Data.RAW_CONTACT_ID + <span class="string">" = "</span> + id + <span class="string">" AND "</span> + Data.DATA2  </span><br><span class="line">                + <span class="string">" = "</span> + <span class="number">2</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);  </span><br><span class="line"><span class="keyword">String</span> mobileNum = <span class="string">""</span>;  </span><br><span class="line"><span class="keyword">if</span> (mobileCursor.moveToNext()) &#123;  </span><br><span class="line">    mobileNum = mobileCursor.getString(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">mobileCursor.close();  </span><br><span class="line"><span class="comment">// 得到家庭电话  </span></span><br><span class="line">Cursor homeCursor = context.getContentResolver().query(  </span><br><span class="line">        ContactsContract.Data.CONTENT_URI,  </span><br><span class="line">        <span class="keyword">new</span> <span class="keyword">String</span>[]&#123;Phone.NUMBER&#125;,  </span><br><span class="line">        Data.RAW_CONTACT_ID + <span class="string">" = "</span> + id + <span class="string">" AND "</span> + Data.DATA2  </span><br><span class="line">                + <span class="string">" = "</span> + <span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p><p>将读取到的文件进行本地存储，写入到TF卡，其权限在使用之前已经进行申请，其写入主要代码如下所示：<br>private void writeFile(String path, String info) {<br>    try {<br>        File file = new File(path);<br>        FileWriter writer = new FileWriter(file, false);<br>        writer.write(info);<br>        writer.close();<br>    } catch (IOException e) {<br>        e.printStackTrace();<br>    }<br>}  </p><p>2.JNI配置<br>JNI的全称就是Java Native Interface，顾名思义，就是Java和C/C++相互通信的接口，就好比买卖房子都需要找中介一样，这里的JNI就是Java和C/C++通信的中介，一个中间人。<br>首先创建JNI类：<br><img src="https://i.loli.net/2019/05/10/5cd52b25bb387.png" alt="图片1.png"><br>配置 Anroid Studio 外部工具，File-&gt;Setting-&gt;Tools-&gt;External Tools-&gt;“+”，进入配置，完成之后如下图所示，先配置Javah。<br><img src="https://i.loli.net/2019/05/10/5cd52bcab9ff0.png" alt="图片2.png"><br>以相同的方式配置ndk-build。配置完成之后如图所示：<br><img src="https://i.loli.net/2019/05/10/5cd52bcabc4c5.png" alt="图片3.png"><br>修改app下的build.gradle文件, 如下图所示：<br><img src="https://i.loli.net/2019/05/10/5cd52bcab194a.png" alt="图片4.png"><br>并在项目下的gradle.properties文件添加代码：android.useDeprecatedNdk=true 生成JNI程序文件，点击JNI类文件，开始生成.h文件，选中JNI类右键-&gt;New-&gt;External Tools-&gt;javah，文件生成后如下所示：<br><img src="https://i.loli.net/2019/05/10/5cd52bcabe481.png" alt="图片5.png"><br>选中JNI类右键-&gt;New-&gt;External Tools-&gt;ndk-build，结果如图：<br><img src="https://i.loli.net/2019/05/10/5cd52bcac0a06.png" alt="图片6.png"><br>生成.h文件之后,根据生成的接口进行程序设计，接口函数如下所示：<br><img src="https://i.loli.net/2019/05/10/5cd52d056329a.png" alt="图片12.png"><br>新建立一个C++文件，在其中加入通信部分相关代码：<br><img src="https://i.loli.net/2019/05/10/5cd52bcaf07c3.png" alt="图片7.png"></p><p>安卓端整个设计完毕，最后进行调试生成相应的App应用，进行测试和完善，完成整体的设计。<br>3.服务器配置<br>服务器使用C++进行程序设计，服务器采用Centos6.8，配置好GCC-C++、SQLite环境之后，客户端使用Socket接口进行访问。将通信录信息传递到服务后进行相应的处理，存入数据库。启动界面如下图所示：<br><img src="https://i.loli.net/2019/05/10/5cd52bcac29b2.png" alt="图片8.png"><br>服务器程序中数据库存储部分具体见通信部分。<br>4.系统设计UML图<br>用户打开安卓界面，安卓获取本机通讯录打包好将信息给C++接口程序，同时保存数据到SD卡；C++接口程序通过Socket连接远程服务器，上传数据；服务器端接收数据，并插入到本地数据库，UML如图所示：<br><img src="https://i.loli.net/2019/05/10/5cd52bcacdd51.png" alt="图片9.png"><br>五、实验结果<br>根据设计要求，完成相应的工作，并进行测试，当用户进行使用时，首先开启服务器端接收部分进行监听，当安卓客户端点击备份和上传时，测试结果如下所示，客户端显示如下：<br><img src="https://i.loli.net/2019/05/10/5cd52bcad11c7.png" alt="图片10.png"><br>服务器测试如下所示：<br><img src="https://i.loli.net/2019/05/10/5cd52bcac897a.png" alt="图片11.png"><br>六、设计总结<br>本次设计深入了解面向对象设计方法，学习了JNI相关知识以及UML的设计，对C++程序又了进一步的了解，设计有所不足，服务器未考虑到多用户并发数据备份，另外安卓客户端比较简单，需要更多的优化设计。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、设计目的  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用课程所学知识进行面向对象程序设计，理解类、对象、封装等概念。  &lt;/li&gt;
&lt;li&gt;熟练掌握C++程序设计  &lt;/li&gt;
&lt;li&gt;学会使用UML分析  &lt;/li&gt;
&lt;li&gt;完成手机通信录备份设计
    
    </summary>
    
    
      <category term="Android C++ JNI" scheme="http://peisenli.github.io/tags/Android-C-JNI/"/>
    
  </entry>
  
</feed>
