<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>帅的如此过分</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://peisenli.github.io/"/>
  <updated>2019-09-04T08:14:02.870Z</updated>
  <id>http://peisenli.github.io/</id>
  
  <author>
    <name>空空</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode15-三数之和</title>
    <link href="http://peisenli.github.io/2019/09/03/LeetCode15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://peisenli.github.io/2019/09/03/LeetCode15-三数之和/</id>
    <published>2019-09-03T07:28:43.000Z</published>
    <updated>2019-09-04T08:14:02.870Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。<br>例如, 给定数组<br>nums = [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]<br><a id="more"></a><br>思路：</p><ul><li>先将数组进行排序</li><li>从左侧开始，选定一个值为 定值 ，右侧进行求解，获取与其相加为 0 的两个值</li><li><p>类似于快排，定义首和尾<br>首尾与 定值 相加<br>等于 00，记录这三个值<br>小于 00，首部右移<br>大于 00，尾部左移<br>定值右移，重复该步骤  </p><pre><code>class Solution(object):def threeSum(self, nums):    &quot;&quot;&quot;    :type nums: List[int]    :rtype: List[List[int]]    &quot;&quot;&quot;nums.sort()res =[]i = 0for i in range(len(nums)):    if i == 0 or nums[i]&gt;nums[i-1]:        l = i+1        r = len(nums)-1        while l &lt; r:            s = nums[i] + nums[l] +nums[r]            if s ==0:                res.append([nums[i],nums[l],nums[r]])                l +=1                r -=1                while l &lt; r and nums[l] == nums[l-1]:                    l += 1                while r &gt; l and nums[r] == nums[r+1]:                    r -= 1            elif s&gt;0:                r -=1            else :                l +=1return res</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。&lt;br&gt;注意：答案中不可以包含重复的三元组。&lt;br&gt;例如, 给定数组&lt;br&gt;nums = [-1, 0, 1, 2, -1, -4]，&lt;br&gt;满足要求的三元组集合为：&lt;br&gt;[&lt;br&gt;  [-1, 0, 1],&lt;br&gt;  [-1, -1, 2]&lt;br&gt;]&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode11-盛水最多的容器</title>
    <link href="http://peisenli.github.io/2019/09/02/LeetCode11-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>http://peisenli.github.io/2019/09/02/LeetCode11-盛水最多的容器/</id>
    <published>2019-09-02T09:19:44.000Z</published>
    <updated>2019-09-02T10:53:12.256Z</updated>
    
    <content type="html"><![CDATA[<p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>说明：你不能倾斜容器，且 n 的值至少为 2。<br><img src="https://i.loli.net/2019/09/02/eMRhmZK6SI9C2Lu.jpg" alt="question_11.jpg"><br>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。<br>示例:<br>输入: [1,8,6,2,5,4,8,3,7]<br>输出: 49<br><a id="more"></a><br>思路：采用暴力法简单地考虑每对可能出现的线段组合并找出这些情况之下的最大面积，但是在进行提交时出现运行超时。</p><pre><code>class Solution(object):    def maxArea(self, height):        &quot;&quot;&quot;        :type height: List[int]        :rtype: int        &quot;&quot;&quot;        MaxArea = 0        for i in range(0,len(height)):            for j in range(i+1,len(height)):                MaxArea = max(MaxArea,min(height[i],height[j])*(j-i))        return MaxArea</code></pre><p>双指针法<br>这种方法背后的思路在于，两线段之间形成的区域总是会受到其中较短那条长度的限制。此外，两线段距离越远，得到的面积就越大。<br>我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 此外，我们会使用变量 maxareamaxarea 来持续存储到目前为止所获得的最大面积。 在每一步中，我们会找出指针所指向的两条线段形成的区域，更新 maxareamaxarea，并将指向较短线段的指针向较长线段那端移动一步。  </p><pre><code>class Solution(object):    def maxArea(self, height):        &quot;&quot;&quot;        :type height: List[int]        :rtype: int        &quot;&quot;&quot;        MaxArea = 0        i = 0        j = len(height) - 1         while(i &lt; j):            MaxArea = max(MaxArea,min(height[i],height[j])*(j-i))            if height[i] &lt; height[j]:                i += 1            else:                j -= 1        return MaxArea</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。&lt;br&gt;说明：你不能倾斜容器，且 n 的值至少为 2。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2019/09/02/eMRhmZK6SI9C2Lu.jpg&quot; alt=&quot;question_11.jpg&quot;&gt;&lt;br&gt;图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。&lt;br&gt;示例:&lt;br&gt;输入: [1,8,6,2,5,4,8,3,7]&lt;br&gt;输出: 49&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode53-最大子序和</title>
    <link href="http://peisenli.github.io/2019/09/01/LeetCode53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <id>http://peisenli.github.io/2019/09/01/LeetCode53-最大子序和/</id>
    <published>2019-09-01T11:14:06.000Z</published>
    <updated>2019-09-01T11:22:28.719Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>示例:<br>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br><a id="more"></a><br>思路：<br>动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 ans<br>如果 sum &gt; 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字<br>如果 sum &lt;= 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字<br>每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果  </p><pre><code>class Solution(object):    def maxSubArray(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: int        &quot;&quot;&quot;        for i in range(1, len(nums)):            ans = max(nums[i-1], 0)            nums[i]= nums[i] + ans        return max(nums)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;br&gt;示例:&lt;br&gt;输入: [-2,1,-3,4,-1,2,1,-5,4],&lt;br&gt;输出: 6&lt;br&gt;解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode26-删除排序数组中的重复项</title>
    <link href="http://peisenli.github.io/2019/08/30/LeetCode26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>http://peisenli.github.io/2019/08/30/LeetCode26-删除排序数组中的重复项/</id>
    <published>2019-08-30T07:45:39.000Z</published>
    <updated>2019-08-30T07:49:07.073Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br>示例 1:<br>给定数组 nums = [1,1,2],<br>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。<br>你不需要考虑数组中超出新长度后面的元素。<br>示例 2:<br>给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br><strong>思路：</strong>用两个指针，指向第一个和第二个元素，如果他们相等，删除第二个元素。指针还指向原来的位置，继续比较。不等的话，两个指针位置都加一。遍历结束即可。<br><a id="more"></a></p><pre><code>class Solution(object):    def removeDuplicates(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: int        &quot;&quot;&quot;        if not nums:            return 0        j = 0        for i in range(1,len(nums)):            if nums[i] != nums[j]:                j += 1                nums[j] = nums[i]        return j+1        </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。&lt;br&gt;不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。&lt;br&gt;示例 1:&lt;br&gt;给定数组 nums = [1,1,2],&lt;br&gt;函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。&lt;br&gt;你不需要考虑数组中超出新长度后面的元素。&lt;br&gt;示例 2:&lt;br&gt;给定 nums = [0,0,1,1,1,2,2,3,3,4],&lt;br&gt;函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。&lt;br&gt;&lt;strong&gt;思路：&lt;/strong&gt;用两个指针，指向第一个和第二个元素，如果他们相等，删除第二个元素。指针还指向原来的位置，继续比较。不等的话，两个指针位置都加一。遍历结束即可。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode4.寻找两个有序数组的中位数</title>
    <link href="http://peisenli.github.io/2019/08/29/LeetCode4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://peisenli.github.io/2019/08/29/LeetCode4-寻找两个有序数组的中位数/</id>
    <published>2019-08-29T09:30:32.000Z</published>
    <updated>2019-08-29T09:38:44.566Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。<br>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。<br>你可以假设 nums1 和 nums2 不会同时为空。<br>示例 1:<br>nums1 = [1, 3]<br>nums2 = [2]<br>则中位数是 2.0<br>示例 2:<br>nums1 = [1, 2]<br>nums2 = [3, 4]<br>则中位数是 (2 + 3)/2 = 2.5  </p><p><strong>思路：</strong>题目要求时间复杂度为O(log(m + n))。基本可以确定本题应该用二分查找，对于数组arr的中位数，如果数组长度为len，<br>len为奇数，则中位数为第（len+1）/2 位，如果len为偶数，我们需要知道第 len/2和 len/2+1 个数。<br><a id="more"></a></p><pre><code>class Solution(object):    def findMedianSortedArrays(self, A, B):        &quot;&quot;&quot;        :type nums1: List[int]        :type nums2: List[int]        :rtype: float        &quot;&quot;&quot;        m, n = len(A), len(B)        if m &gt; n:            A, B, m, n = B, A, n, m        if n == 0:            raise ValueError        imin, imax, half_len = 0, m, (m + n + 1) / 2        while imin &lt;= imax:            i = (imin + imax) / 2            j = half_len - i            if i &lt; m and B[j-1] &gt; A[i]:                # i is too small, must increase it                imin = i + 1            elif i &gt; 0 and A[i-1] &gt; B[j]:                # i is too big, must decrease it                imax = i - 1            else:                # i is perfect                if i == 0: max_of_left = B[j-1]                elif j == 0: max_of_left = A[i-1]                else: max_of_left = max(A[i-1], B[j-1])                if (m + n) % 2 == 1:                    return max_of_left                if i == m: min_of_right = B[j]                elif j == n: min_of_right = A[i]                else: min_of_right = min(A[i], B[j])                return (max_of_left + min_of_right) / 2.0</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。&lt;br&gt;请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。&lt;br&gt;你可以假设 nums1 和 nums2 不会同时为空。&lt;br&gt;示例 1:&lt;br&gt;nums1 = [1, 3]&lt;br&gt;nums2 = [2]&lt;br&gt;则中位数是 2.0&lt;br&gt;示例 2:&lt;br&gt;nums1 = [1, 2]&lt;br&gt;nums2 = [3, 4]&lt;br&gt;则中位数是 (2 + 3)/2 = 2.5  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;题目要求时间复杂度为O(log(m + n))。基本可以确定本题应该用二分查找，对于数组arr的中位数，如果数组长度为len，&lt;br&gt;len为奇数，则中位数为第（len+1）/2 位，如果len为偶数，我们需要知道第 len/2和 len/2+1 个数。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>图-拓扑排序</title>
    <link href="http://peisenli.github.io/2019/08/28/%E5%9B%BE-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>http://peisenli.github.io/2019/08/28/图-拓扑排序/</id>
    <published>2019-08-28T08:59:21.000Z</published>
    <updated>2019-08-28T09:14:59.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p><strong>1.定义</strong><br>给出有向图G=(V,E)，对于V中的顶点的线性序列(vi1,vi2,…,vin)，如果满足如下条件：若在G中从顶点 vi 到vj有一条路经，则在序列中顶点vi必在顶点 vj之前；则称该序列为 G的一个拓扑序列(Topological order)。构造有向图的一个拓扑序列的过程称为拓扑排序(Topological sort)。<br><strong>2.说明</strong><br>(1)在AOV网中，若不存在回路，则所有活动可排成一个线性序列，使得每个活动的所有前驱活动都排在该活动的前面，那么该序列为拓扑序列。<br>(2)拓扑序列不是唯一的。<br>(3)AOV网不一定都存在拓扑序列。<br>在AOV网中，&lt;i,j&gt;有向边表示i活动应先于j活动开始，即i活动必须完成后，j活动才可以开始，并称i为j的直接前驱，j为i的直接后继。这种前驱与后继的关系有传递性，此外，任何活动i不能以它自己作为自己的前驱或后继，这叫做反自反性。从前驱和后继的传递性和反自反性来看，AOV网中不能出现有向回路(或称有向环)。在AOV网中如果出现了有向环，则意味着某项活动应以自己作为先决条件，工程将无法进行。对程序流程而言，将出现死循环。<br>因此，对给定的AOV网，应先判断它是否存在有向环。判断AOV网是否有有向环的方法是对该AOV网进行拓扑排序，将AOV网中顶点排列成一个线性有序序列，若该线性序列中包含AOV网全部顶点，则AOV网无环，否则，AOV网中存在有向环，该AOV网所代表的工程是不可行的。<br><a id="more"></a><br><strong>3、拓扑序列的实际意义是:</strong><br>如果按照拓扑序列中的顶点次序进行每一项活动，就能够保证在开始每一项活动时，他的所有前驱活动均已完成，从而使整个工程顺序执行。  </p><h3 id="拓扑排序方法"><a href="#拓扑排序方法" class="headerlink" title="拓扑排序方法"></a>拓扑排序方法</h3><p>(1)在AOV网中选一个入度为0的顶点(没有前驱)且输出之；<br>(2)从AOV网中删除此顶点及该顶点发出来的所有有向边；<br>(3)重复(1)、(2)两步，直到AOV网中所有顶点都被输出或网中不存在入度为0的顶点。<br>从拓扑排序步骤可知，若在第3步中，网中所有顶点都被输出，则表明网中无有向环，拓扑排序成功。若仅输出部分顶点，网中已不存在入度为0的顶点，则表明网中有有向环，拓扑排序不成功。因此，一个AOV网的拓扑序列是不唯一的。  </p><p>###算法步骤###<br>在执行拓扑排序的过程中，当某个顶点的入度为零时，就将此顶点输出，同时将该顶点的所有后续顶点的入度减1，为了避免重复检测入度为零的顶点，设立一个栈，以存放入度为零的顶点。执行拓扑排序的算法步骤如下：<br>（1）输入有向边的序列，建立相应的邻接表。<br>（2）查找邻接表中入度为零的顶点，让入度为零的顶点入栈。<br>（3）当栈不空时<br>（a）使用退栈操作，取得栈顶的顶点j并输出。<br>（b）在邻接表的第j个链表中，查找顶点j的所有后续顶点k，将顶点k的入度减1。若顶点k的入度变为零，则顶点k进栈，转步骤（3）<br>（4）当栈空时，若有向图的所有顶点都输出，则拓扑排序过程正常结束，否则，有向图存在回路。<br>如果给定的有向图有n个顶点和m条边，那么建立邻接表的时间为O(m)，在拓扑排序的过程中，查找入度为零的顶点的时间为O(n)，顶点进栈及退栈输出共执行n次，入度减1的操作执行m次，所以，总的执行时间为O(m+n)。  </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;拓扑排序&quot;&gt;&lt;a href=&quot;#拓扑排序&quot; class=&quot;headerlink&quot; title=&quot;拓扑排序&quot;&gt;&lt;/a&gt;拓扑排序&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.定义&lt;/strong&gt;&lt;br&gt;给出有向图G=(V,E)，对于V中的顶点的线性序列(vi1,vi2,…,vin)，如果满足如下条件：若在G中从顶点 vi 到vj有一条路经，则在序列中顶点vi必在顶点 vj之前；则称该序列为 G的一个拓扑序列(Topological order)。构造有向图的一个拓扑序列的过程称为拓扑排序(Topological sort)。&lt;br&gt;&lt;strong&gt;2.说明&lt;/strong&gt;&lt;br&gt;(1)在AOV网中，若不存在回路，则所有活动可排成一个线性序列，使得每个活动的所有前驱活动都排在该活动的前面，那么该序列为拓扑序列。&lt;br&gt;(2)拓扑序列不是唯一的。&lt;br&gt;(3)AOV网不一定都存在拓扑序列。&lt;br&gt;在AOV网中，&amp;lt;i,j&amp;gt;有向边表示i活动应先于j活动开始，即i活动必须完成后，j活动才可以开始，并称i为j的直接前驱，j为i的直接后继。这种前驱与后继的关系有传递性，此外，任何活动i不能以它自己作为自己的前驱或后继，这叫做反自反性。从前驱和后继的传递性和反自反性来看，AOV网中不能出现有向回路(或称有向环)。在AOV网中如果出现了有向环，则意味着某项活动应以自己作为先决条件，工程将无法进行。对程序流程而言，将出现死循环。&lt;br&gt;因此，对给定的AOV网，应先判断它是否存在有向环。判断AOV网是否有有向环的方法是对该AOV网进行拓扑排序，将AOV网中顶点排列成一个线性有序序列，若该线性序列中包含AOV网全部顶点，则AOV网无环，否则，AOV网中存在有向环，该AOV网所代表的工程是不可行的。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>图-最短路径问题</title>
    <link href="http://peisenli.github.io/2019/08/28/%E5%9B%BE-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <id>http://peisenli.github.io/2019/08/28/图-最短路径问题/</id>
    <published>2019-08-28T06:48:01.000Z</published>
    <updated>2019-08-28T06:50:14.646Z</updated>
    
    <content type="html"><![CDATA[<p><strong>最短路径问题</strong>是图论研究中的一个经典算法问题， 旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法能得出最短路径的最优解，但由于它遍历计算的节点很多，所以效率低。<br>单源点最短路径是指：给定一个出发点(单源点)和一个有向网G=(V，E),求出源点到其它各顶点之间的最短路径。<br>迪杰斯特拉(Dijkstra)在做了大量观察后,首先提出了按路径长度递增序产生各顶点的最短路径算法,我们称之为<strong>迪杰斯特拉算法</strong>。<br><strong>算法的基本思想是:</strong>把图中顶点集合分成两组，第一组为集合S，存放已求出其最短路径的顶点，第二组为尚未确定最短路径的顶点集合是V-S（用U表示），其中V为网中所有顶点集合。按最短路径长度递增的顺序逐个把U中的顶点加到S中，直到S中包含全部顶点，而U为空。在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。<br>（1）初始时，S只包含源点，S={v}，v的距离为0。U包含除v外的其他顶点，U中顶点的距离为顶点的权或∞ 。<br>（2）从U中选取一个距离最小的顶点k，把k加入到S中<br>（3）以k 作为新考虑的中间点，修改U中各顶点的距离。<br>（4）重复步骤（2）、（3）直到所有顶点都包含在S中。<br>时间复杂度：O（V^3）<br><a id="more"></a></p><center><img src="https://i.loli.net/2019/08/28/UwrRpzbHsENFiaY.png" alt="TIM图片20190828143649.png"><br><img src="https://i.loli.net/2019/08/28/J4hFigydBtOeLQp.png" alt="TIM图片20190828143701.png">  </center><pre><code>//有权图的Dijikstra(遍历整个数组寻找最小路径顶点)bool Dijikstra(int vertex){    //根据初始结点初始化距离数组与路径数组     for(int i = 0 ; i &lt; this-&gt;Nv+1 ; i++){        //在构造函数里dist已经全部初始化为MAX        //G存在边时为权重，没有边时为MAX         this-&gt;dist[i] = this-&gt;G[vertex][i];        if(this-&gt;dist[i] &lt; MAX){            this-&gt;path[i] = vertex;        }    }    this-&gt;dist[vertex] = 0;        //初始结点的距离为０    this-&gt;collected[vertex] = 1;    //初始结点标记为已收录     while(1){        //V是未被收录定点中dist最小者         int V = this-&gt;FindMinVertex();         if(V == -1){//未找到这样的V则跳出循环             break;        }         this-&gt;collected[V] = 1;//标记为已经被收录         //遍历图中每个顶点         for(int w = 1 ; w &lt; this-&gt;Nv+1 ; w++){            //若w是V的邻接点且未被收录             if(this-&gt;collected[w] == 0 &amp;&amp; this-&gt;G[V][w] &lt; MAX){                if(this-&gt;G[V][w] &lt; 0){//存在负边时                     return false;    //结束算法                 }                //若收录V使得dist[w]变小                 if(this-&gt;dist[V] + this-&gt;G[V][w] &lt; this-&gt;dist[w]){                    //更新dist[w]                     this-&gt;dist[w] = this-&gt;dist[V] = this-&gt;G[V][w];                     this-&gt;path[w] = V;//更新路径                 }             }         }     }    return true;}</code></pre><p>最短路径算法中的<strong>Floyd算法</strong>，这是针对多源最短路径的一个经典算法。<br><strong>算法思想：</strong><br>Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）。<br>从任意节点i到任意节点j的最短路径不外乎2种可能，一是直接从i到j，二是从i经过若干个节点k到j。所以，我们假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，我们检查Dis(i,k) + Dis(k,j) &lt; Dis(i,j)是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，我们便设置Dis(i,j) = Dis(i,k) + Dis(k,j)，这样一来，当我们遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。<br>时间复杂度：O（V^3）<br><strong>算法过程：</strong><br>1）首先把初始化距离dist数组为图的邻接矩阵，路径数组path初始化为-1。其中对于邻接矩阵中的数首先初始化为正无穷，如果两个顶点存在边则初始化为权重。<br>2）对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短。如果是就更新它。<br>状态转移方程为<br>如果 dist[i][k]+dist[k][j] &lt; dist[i][j]<br>则   dist[i][j] = dist[i][k]+dist[k][j]  </p><pre><code>bool Floyd(){    for(int k = 1 ; k &lt; this-&gt;Nv+1 ; k++){    //k代表中间顶点         for(int i = 1  ; i &lt; this-&gt;Nv+1 ; i++){//i代表起始顶点             for(int j = 1 ; j &lt; this-&gt;Nv+1 ; j++){//j代表终点                 if(this-&gt;dist[i][k] + this-&gt;dist[k][j] &lt; this-&gt;dist[i][j]){                    this-&gt;dist[i][j] = this-&gt;dist[i][k] + this-&gt;dist[k][j];                    if(i == j &amp;&amp; this-&gt;dist[i][j] &lt; 0){//发现了负值圈                         return false;                    }                    this-&gt;path[i][j] = k;                }                                }        }    }    return true; }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;最短路径问题&lt;/strong&gt;是图论研究中的一个经典算法问题， 旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法能得出最短路径的最优解，但由于它遍历计算的节点很多，所以效率低。&lt;br&gt;单源点最短路径是指：给定一个出发点(单源点)和一个有向网G=(V，E),求出源点到其它各顶点之间的最短路径。&lt;br&gt;迪杰斯特拉(Dijkstra)在做了大量观察后,首先提出了按路径长度递增序产生各顶点的最短路径算法,我们称之为&lt;strong&gt;迪杰斯特拉算法&lt;/strong&gt;。&lt;br&gt;&lt;strong&gt;算法的基本思想是:&lt;/strong&gt;把图中顶点集合分成两组，第一组为集合S，存放已求出其最短路径的顶点，第二组为尚未确定最短路径的顶点集合是V-S（用U表示），其中V为网中所有顶点集合。按最短路径长度递增的顺序逐个把U中的顶点加到S中，直到S中包含全部顶点，而U为空。在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。&lt;br&gt;（1）初始时，S只包含源点，S={v}，v的距离为0。U包含除v外的其他顶点，U中顶点的距离为顶点的权或∞ 。&lt;br&gt;（2）从U中选取一个距离最小的顶点k，把k加入到S中&lt;br&gt;（3）以k 作为新考虑的中间点，修改U中各顶点的距离。&lt;br&gt;（4）重复步骤（2）、（3）直到所有顶点都包含在S中。&lt;br&gt;时间复杂度：O（V^3）&lt;br&gt;
    
    </summary>
    
    
      <category term="Data Struct" scheme="http://peisenli.github.io/tags/Data-Struct/"/>
    
  </entry>
  
  <entry>
    <title>图的生成树问题</title>
    <link href="http://peisenli.github.io/2019/08/28/%E5%9B%BE%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98/"/>
    <id>http://peisenli.github.io/2019/08/28/图的生成树问题/</id>
    <published>2019-08-28T02:48:15.000Z</published>
    <updated>2019-08-28T02:56:18.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、无向图的连通分量和生成树"><a href="#一、无向图的连通分量和生成树" class="headerlink" title="一、无向图的连通分量和生成树"></a>一、无向图的连通分量和生成树</h2><p>若图是连通的或强连通的，则从图中某一个顶点出发可以访问到图中所有顶点；<br>若图是非连通的或非强连通图，则需从图中多个顶点出发搜索访问。而每一次从一个新的起始点出发进行搜索过程中得到的顶点访问序列恰为每个连通分量中的顶点集。  </p><h3 id="1、生成树"><a href="#1、生成树" class="headerlink" title="1、生成树"></a>1、生成树</h3><p>深度优先搜索遍历算法及广度优先搜索遍历算法中遍历图过程中历经边的集合和顶点集合一起构成连通图的极小连通子图。它是连通图的一颗生成树。<br>生成树：是一个极小连通子图，它含有图中全部n个顶点，但只有n-1条边。<br>由深度优先搜索遍历得到的生成树，称为深度优先生成树，由广度优先搜索遍历得到的生成树，称为广度优先生成树。图中无向图G7的两种生成树见 图(a)、(b)。<br><img src="https://i.loli.net/2019/08/28/Q6cGY2loXtgzDxe.png" alt="生成shu.png"><br><a id="more"></a></p><h3 id="2．生成森林"><a href="#2．生成森林" class="headerlink" title="2．生成森林"></a>2．生成森林</h3><p>若一个图是非连通图或非强连通图，但有若干个连通分量或若干个强连通分量，则通过深度优先搜索遍历或广度优先搜索遍历，不可以得到生成树，但可以得到生成森林，且若非连通图有 n 个顶点，m 个连通分量或强连通分量，则可以遍历得到m棵生成树，合起来为生成森林，森林中包含n-m条树边。<br>生成森林可以利用非连通图的深度优先搜索遍历或非连通图的广度优先搜索遍历算法得到。   </p><h3 id="3．最小生成树"><a href="#3．最小生成树" class="headerlink" title="3．最小生成树"></a>3．最小生成树</h3><p>在一般情况下，图中的每条边若给定了权，这时，我们所关心的不是生成树，而是生成树中边上权值之和。若生成树中每条边上权值之和达到最小，称为最小生成树。  </p><h2 id="二、求最小生成树"><a href="#二、求最小生成树" class="headerlink" title="二、求最小生成树"></a>二、求最小生成树</h2><p><strong>首先明确：</strong>  </p><ul><li>使用不同的遍历图的方法，可以得到不同的生成树；从不同的顶点出发，也可能得到不同的生成树。  </li><li>按照生成树的定义，n 个顶点的连通网络的生成树有 n 个顶点、n-1 条边。<br><strong>目标：</strong><br>在网络的多个生成树中，寻找一个各边权值之和最小的生成树。<br><strong>构造最小生成树的准则</strong>  </li><li>必须只使用该网络中的边来构造最小生成树；  </li><li>必须使用且仅使用n-1条边来联结网络中的n个顶点；  </li><li><p>不能使用产生回路的边。  </p><h3 id="1-克鲁斯卡尔算法基本思想"><a href="#1-克鲁斯卡尔算法基本思想" class="headerlink" title="1. 克鲁斯卡尔算法基本思想"></a>1. 克鲁斯卡尔算法基本思想</h3><p>克鲁斯卡尔算法的基本思想是：将图中所有边按权值递增顺序排列，依次选定取权值较小的边，但要求后面选取的边不能与前面选取的边构成回路，若构成回路，则放弃该条边，再去选后面权值较大的边，n个顶点的图中，选够n-1条边即可。  </p><p>  #定义<br>  typedef struct  Edge                //定义边集数组元素，v1,v2存顶点，weight存权重。<br>  {</p><pre><code>int v1;int v2;int weight;</code></pre><p>  }Edge;</p><p>  typedef struct ALGraph        //定义图的结构，peak存顶点的数量，edge存边的数量<br>  {                                            //指针p作为边集数组，指针m为作为顶点数组</p><pre><code>int peak;int edge;Edge *p;int *m;</code></pre><p>  }ALGraph;<br>  #创建图<br>  void CreatALGraph(ALGraph *G)<br>  {</p><pre><code>int i,j;printf(&quot;输入图的顶点数量和边的数量：&quot;);scanf(&quot;%d %d&quot;,&amp;G-&gt;peak,&amp;G-&gt;edge);G-&gt;p=(Edge *)malloc(sizeof(Edge)*(G-&gt;edge+1));G-&gt;m=(int *)malloc(sizeof(int)*G-&gt;peak);for(i=0;i&lt;G-&gt;peak;i++){      printf(&quot;请输入输入顶点：&quot;);      scanf(&quot;%d&quot;,&amp;G-&gt;m[i]);}for(i=0;i&lt;G-&gt;edge;i++){    printf(&quot;请输入(vi-vj)和权重：&quot;);    scanf(&quot;%d %d %d&quot;,&amp;G-&gt;p[i].v1,&amp;G-&gt;p[i].v2,&amp;G-&gt;p[i].weight);}for(i=0 ;i&lt;G-&gt;edge;i++)                //冒泡排序法，权重从小到大存在边集数组中{    for(j=G-&gt;edge-1;j&gt;i;j--)    {        if(G-&gt;p[i].weight&gt;G-&gt;p[j].weight)        {            G-&gt;p[G-&gt;edge]=G-&gt;p[i];            G-&gt;p[i]=G-&gt;p[j];            G-&gt;p[j]=G-&gt;p[G-&gt;edge];        }    }}</code></pre><p>  }<br>  #克鲁斯卡尔算法<br>  int Find(int *parent,int g)                //通过parent[]找到可连接的边<br>  {</p><pre><code>while(parent[g]!=0){    g=parent[g];}return g;</code></pre><p>  }<br>  int Finish(ALGraph <em>G,int </em>parent)        //判断生成树是否完成，完成的标志是生成树的边等于顶点的数量减1<br>  {</p><pre><code>int i,n=0;for(i=0;i&lt;G-&gt;peak;i++){    if(parent[i])    {        n++;    }}if(n==G-&gt;peak-1){    return 1;}return 0;</code></pre><p>  }<br>  int FindPeak(ALGraph *G,int g)        //找到顶点的下标<br>  {</p><pre><code>int i;for(i=0;i&lt;G-&gt;peak;i++){    if(G-&gt;m[i]==g)        return i;}return -1;</code></pre><p>  }<br>  void MinTree_Kruskal(ALGraph *G)<br>  {</p><pre><code>int i,a,b;int parent[G-&gt;peak];for(i=0;i&lt;G-&gt;peak;i++)        //初始化parent[]{    parent[i]=0;}for(i=0;i&lt;G-&gt;edge;i++){    a=Find(parent,FindPeak(G,G-&gt;p[i].v1));    b=Find(parent,FindPeak(G,G-&gt;p[i].v2));    if(a!=b)                //如果a==b则表是a和b在同一颗生成树上，如果a和b连接则为生成环，不符合生成树    {        parent[a]=b;        printf(&quot;%d-&gt;%d   %d\n&quot;,G-&gt;p[i].v1,G-&gt;p[i].v2,G-&gt;p[i].weight);    }    if(Finish(G,parent))        //完成后返回    {        return;    }}</code></pre><p>  }</p></li></ul><h3 id="2-普里姆-prim-算法思想"><a href="#2-普里姆-prim-算法思想" class="headerlink" title="2. 普里姆(prim)算法思想"></a>2. 普里姆(prim)算法思想</h3><p>普里姆方法的思想是：在图中任取一个顶点K作为开始点，令U={k}，W=V-U，其中V为图中所有顶点集，然后找一个顶点在U中，另一个顶点在W中的边中最短的一条，找到后，将该边作为最小生成树的树边保存起来，并将该边顶点全部加入U集合中，并从W中删去这些顶点，然后重新调整U中顶点到W中顶点的距离, 使之保持最小，再重复此过程，直到W为空集止。  </p><pre><code>#define INFINITE 9999#define MAXN 100void prim(int cost[][MAXN],int n,int v){      int lowcost[MAXN],min,closest[MAXN],i,j,k;    for(i=1;i&lt;=n;i++)    {          lowcost[i]=cost[v][i];        closest[i]=v;    }       for(i=1;i&lt;n;i++)    {          min=INFINITE;        for(j=1;j&lt;=n;j++)            if(lowcost[j]!=0&amp;&amp;lowcost[j]&lt;min))            {                  min=lowcost[j];                k=j;               }             printf(“%d%d%d”,closest[k],k,min);             lowcost[k]=0;             for(j=1;j&lt;=n;j++)                if((cost[k][j]!=0)&amp;&amp;(cost[k][j]&lt;lowcost[j]))                   {                      lowcost[j]=cost[k][j];                       closest[j]=k;                  }     }}#时间复杂度为O(n2)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、无向图的连通分量和生成树&quot;&gt;&lt;a href=&quot;#一、无向图的连通分量和生成树&quot; class=&quot;headerlink&quot; title=&quot;一、无向图的连通分量和生成树&quot;&gt;&lt;/a&gt;一、无向图的连通分量和生成树&lt;/h2&gt;&lt;p&gt;若图是连通的或强连通的，则从图中某一个顶点出发可以访问到图中所有顶点；&lt;br&gt;若图是非连通的或非强连通图，则需从图中多个顶点出发搜索访问。而每一次从一个新的起始点出发进行搜索过程中得到的顶点访问序列恰为每个连通分量中的顶点集。  &lt;/p&gt;
&lt;h3 id=&quot;1、生成树&quot;&gt;&lt;a href=&quot;#1、生成树&quot; class=&quot;headerlink&quot; title=&quot;1、生成树&quot;&gt;&lt;/a&gt;1、生成树&lt;/h3&gt;&lt;p&gt;深度优先搜索遍历算法及广度优先搜索遍历算法中遍历图过程中历经边的集合和顶点集合一起构成连通图的极小连通子图。它是连通图的一颗生成树。&lt;br&gt;生成树：是一个极小连通子图，它含有图中全部n个顶点，但只有n-1条边。&lt;br&gt;由深度优先搜索遍历得到的生成树，称为深度优先生成树，由广度优先搜索遍历得到的生成树，称为广度优先生成树。图中无向图G7的两种生成树见 图(a)、(b)。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2019/08/28/Q6cGY2loXtgzDxe.png&quot; alt=&quot;生成shu.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Data Struct" scheme="http://peisenli.github.io/tags/Data-Struct/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-LRU缓存机制</title>
    <link href="http://peisenli.github.io/2019/08/27/LeetCode-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://peisenli.github.io/2019/08/27/LeetCode-LRU缓存机制/</id>
    <published>2019-08-27T12:32:19.000Z</published>
    <updated>2019-08-27T12:34:12.667Z</updated>
    
    <content type="html"><![CDATA[<p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。<br>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。<br>进阶:<br>你是否可以在 O(1) 时间复杂度内完成这两种操作？<br>示例:<br>LRUCache cache = new LRUCache( 2 /<em> 缓存容量 </em>/ );<br>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       // 返回  1<br>cache.put(3, 3);    // 该操作会使得密钥 2 作废<br>cache.get(2);       // 返回 -1 (未找到)<br>cache.put(4, 4);    // 该操作会使得密钥 1 作废<br>cache.get(1);       // 返回 -1 (未找到)<br>cache.get(3);       // 返回  3<br>cache.get(4);       // 返回  4   </p><a id="more"></a><p>###LRU简介###<br>LRU是Least Recently Used的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。<br><strong>寄存器</strong><br>为了记录某进程在内存中各页的使用情况，须为每个在内存中的页面配置一个移位寄存器，可表示为<br>R = Rn-1 Rn-2 Rn-3 … R2 R1 R0<br>当进程访问某物理块时，要将相应寄存器的 R n -1 位置成 1。此时，定时信号将每隔一定时间(例如 100 ms)将寄存器右移一位。 如果我们把 n 位寄存器的数看做是一个整数， 那么，具有最小数值的寄存器所对应的页面，就是最近最久未使用的页面。图2示出了某进程在内存中具有 8 个页面，为每个内存页面配置一个 8 位寄存器时的 LRU 访问情况。这里，把 8 个内存页面的序号分别定为 1～8。由图可以看出，第 3 个内存页面的 R 值最小，当发生缺页时，首先将它置换出去。<br><strong>栈</strong><br>可利用一个特殊的栈来保存当前使用的各个页面的页面号。每当进程访问某页面时，便将该页面的页面号从栈中移出，将它压入栈顶。因此，栈顶始终是最新被访问页面的编号，而栈底则是最近最久未使用页面的页面号。假定现有一进程所访问的页面的页面号序列为：<br>4，7，0，7，1，0，1，2，1，2，6<br>随着进程的访问， 栈中页面号的变化情况如图 3 所示。 在访问页面 6 时发生了缺页，此时页面 4 是最近最久未被访问的页，应将它置换出去。  </p><pre><code>from collections import OrderedDictclass LRUCache(OrderedDict):    def __init__(self, capacity: int):        self.capacity = capacity    def get(self, key: int) -&gt; int:        if key not in self:            return -1        self.move_to_end(key)        return self[key]    def put(self, key: int, value: int) -&gt; None:        if key in self:            self.move_to_end(key)        self[key] = value        if len(self) &gt; self.capacity:            self.popitem(last = False)</code></pre><p><code>    </code></p><pre><code># Your LRUCache object will be instantiated and called as such:  # obj = LRUCache(capacity)   # param_1 = obj.get(key)  # obj.put(key,value)  </code></pre><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。&lt;br&gt;获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。&lt;br&gt;写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。&lt;br&gt;进阶:&lt;br&gt;你是否可以在 O(1) 时间复杂度内完成这两种操作？&lt;br&gt;示例:&lt;br&gt;LRUCache cache = new LRUCache( 2 /&lt;em&gt; 缓存容量 &lt;/em&gt;/ );&lt;br&gt;cache.put(1, 1);&lt;br&gt;cache.put(2, 2);&lt;br&gt;cache.get(1);       // 返回  1&lt;br&gt;cache.put(3, 3);    // 该操作会使得密钥 2 作废&lt;br&gt;cache.get(2);       // 返回 -1 (未找到)&lt;br&gt;cache.put(4, 4);    // 该操作会使得密钥 1 作废&lt;br&gt;cache.get(1);       // 返回 -1 (未找到)&lt;br&gt;cache.get(3);       // 返回  3&lt;br&gt;cache.get(4);       // 返回  4   &lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode236-二叉树的最近公共祖先</title>
    <link href="http://peisenli.github.io/2019/08/22/LeetCode236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>http://peisenli.github.io/2019/08/22/LeetCode236-二叉树的最近公共祖先/</id>
    <published>2019-08-22T12:23:12.000Z</published>
    <updated>2019-08-22T12:31:07.009Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]<br><img src="https://i.loli.net/2019/08/22/6OtxHWUQA4CvMnX.png" alt="1566476957(1).jpg"><br>示例 1:<br>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出: 3<br>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。<br>示例 2:<br>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>输出: 5<br>解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。<br>说明:<br>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉树中。<br><a id="more"></a><br>解决思路：<br>首先在二叉树中搜索给定的节点 p 和 q，然后找到它们的最近共同祖先。我们可以使用普通的树遍历来搜索这两个节点。一旦我们达到所需的节点 p 和 q，我们就可以回溯并找到最近的共同祖先。   </p><ul><li>先分析自己，自己是p,q,None中的一者，自然返回自己。  </li><li>然后分析左右子树的返回值，如果其中一个是None，则返回另一个，作为传递，无论是传递最终的答案，还是传递p和q。  </li><li>如果左右子树返回p和q，当然返回root。 Python中的None即C/C++/Java 中的Null/null  </li></ul><hr><p><code></code></p><pre><code># Definition for a binary tree node.  # class TreeNode:  #     def __init__(self, x):  #         self.val = x  #         self.left = None  #         self.right = None  class Solution:    def lowestCommonAncestor(self, root: &apos;TreeNode&apos;, p: &apos;TreeNode&apos;, q: &apos;TreeNode&apos;) -&gt; &apos;TreeNode&apos;:        if root in (None ,p,q):            return root         L = self.lowestCommonAncestor(root.left,p,q)        R =self.lowestCommonAncestor(root.right,p,q)        return R if None==L else L if None==R else root</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;
&lt;p&gt;百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”&lt;/p&gt;
&lt;p&gt;例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2019/08/22/6OtxHWUQA4CvMnX.png&quot; alt=&quot;1566476957(1).jpg&quot;&gt;&lt;br&gt;示例 1:&lt;br&gt;输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1&lt;br&gt;输出: 3&lt;br&gt;解释: 节点 5 和节点 1 的最近公共祖先是节点 3。&lt;br&gt;示例 2:&lt;br&gt;输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4&lt;br&gt;输出: 5&lt;br&gt;解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。&lt;br&gt;说明:&lt;br&gt;所有节点的值都是唯一的。&lt;br&gt;p、q 为不同节点且均存在于给定的二叉树中。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode235-二叉搜索树的最近公共祖先</title>
    <link href="http://peisenli.github.io/2019/08/21/LeetCode235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>http://peisenli.github.io/2019/08/21/LeetCode235-二叉搜索树的最近公共祖先/</id>
    <published>2019-08-21T12:07:00.000Z</published>
    <updated>2019-08-21T13:28:14.457Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]<br><img src="https://i.loli.net/2019/08/21/e4NzuaE9J1jXqn5.png" alt="binarysearchtree_improved.png"><br>示例 1:<br>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。<br>示例 2:<br>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。<br>说明:<br>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉搜索树中。<br><a id="more"></a><br>算法<br>从根节点开始遍历树<br>如果节点 p 和节点 q 都在右子树上，那么以右孩子为根节点继续 1 的操作<br>如果节点 p 和节点 q 都在左子树上，那么以左孩子为根节点继续 1 的操作<br>如果条件 2 和条件 3 都不成立，这就意味着我们已经找到节 p 和节点 q 的 LCA 了  </p><pre><code># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def lowestCommonAncestor(self, root: &apos;TreeNode&apos;, p: &apos;TreeNode&apos;, q: &apos;TreeNode&apos;) -&gt; &apos;TreeNode&apos;:        # Value of current node or parent node.        parent_val = root.val        # Value of p        p_val = p.val        # Value of q        q_val = q.val        # If both p and q are greater than parent        if p_val &gt; parent_val and q_val &gt; parent_val:                return self.lowestCommonAncestor(root.right, p, q)        # If both p and q are lesser than parent        elif p_val &lt; parent_val and q_val &lt; parent_val:                return self.lowestCommonAncestor(root.left, p, q)        # We have found the split point, i.e. the LCA node.        else:            return root  </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。&lt;br&gt;百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”&lt;br&gt;例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2019/08/21/e4NzuaE9J1jXqn5.png&quot; alt=&quot;binarysearchtree_improved.png&quot;&gt;&lt;br&gt;示例 1:&lt;br&gt;输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8&lt;br&gt;输出: 6&lt;br&gt;解释: 节点 2 和节点 8 的最近公共祖先是 6。&lt;br&gt;示例 2:&lt;br&gt;输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4&lt;br&gt;输出: 2&lt;br&gt;解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。&lt;br&gt;说明:&lt;br&gt;所有节点的值都是唯一的。&lt;br&gt;p、q 为不同节点且均存在于给定的二叉搜索树中。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode230-二叉搜索树中第k小的元素</title>
    <link href="http://peisenli.github.io/2019/08/19/LeetCode230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>http://peisenli.github.io/2019/08/19/LeetCode230-二叉搜索树中第k小的元素/</id>
    <published>2019-08-19T10:51:40.000Z</published>
    <updated>2019-08-19T11:11:51.452Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。<br>说明：<br>你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。<br>示例 1:<br>输入: root = [3,1,4,null,2], k = 1  </p><pre><code>  3 / \1   4 \  2</code></pre><p>输出: 1<br>示例 2:<br>输入: root = [5,3,6,2,4,null,null,1], k = 3  </p><pre><code>      5     / \    3   6   / \  2   4 /1</code></pre><p>输出: 3<br>进阶：<br>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？<br>思路分析：利用“二叉搜索树”在“中序遍历”以后，得到的是有序数组，那么我们就中序遍历好了，遍历到第k个数即可。<br><a id="more"></a></p><pre><code># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def kthSmallest(self, root: TreeNode, k: int) -&gt; int:        # 模拟系统栈的方式实现，是一种比较通用的做法，        # 可以作为二叉树的三种非递归遍历        # 0 表示当前遍历到它，1 表示压入栈        # 刚开始是 1 ，不要写成 0 了        stack = [(1, root)]        while stack:            command, node = stack.pop()            if node is None:                # 不能写 return ，这不是递归                continue            if command == 0:                k -= 1                if k == 0:                    return node.val            else:                # 此时 command == 1 的时候，表示递归遍历到的                # 注意：写的时候倒过来写                stack.append((1, node.right))                stack.append((0, node))                stack.append((1, node.left))</code></pre><hr><p>二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。&lt;br&gt;说明：&lt;br&gt;你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。&lt;br&gt;示例 1:&lt;br&gt;输入: root = [3,1,4,null,2], k = 1  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  3
 / \
1   4
 \
  2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出: 1&lt;br&gt;示例 2:&lt;br&gt;输入: root = [5,3,6,2,4,null,null,1], k = 3  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;      5
     / \
    3   6
   / \
  2   4
 /
1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出: 3&lt;br&gt;进阶：&lt;br&gt;如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？&lt;br&gt;思路分析：利用“二叉搜索树”在“中序遍历”以后，得到的是有序数组，那么我们就中序遍历好了，遍历到第k个数即可。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode124-二叉树中最大路径和</title>
    <link href="http://peisenli.github.io/2019/08/18/LeetCode124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://peisenli.github.io/2019/08/18/LeetCode124-二叉树中最大路径和/</id>
    <published>2019-08-18T06:21:54.000Z</published>
    <updated>2019-08-18T06:41:29.862Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非空二叉树，返回其最大路径和。</p><p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p><p>示例 1:</p><p>输入: [1,2,3]</p><pre><code>  1 / \2   3</code></pre><p>输出: 6</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-maximum-path-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><a id="more"></a><br>思路：<br>对于任意一个节点, 如果最大和路径包含该节点, 那么只可能是两种情况:   </p><ol><li>其左右子树中所构成的和路径值较大的那个加上该节点的值后向父节点回溯构成最大路径  </li><li>左右子树都在最大路径中, 加上该节点的值构成了最终的最大路径      </li></ol><p><code></code></p><pre><code># Definition for a binary tree node.  # class TreeNode:  #     def __init__(self, x):  #         self.val = x  #         self.left = None  #         self.right = None    class Solution:    res = float(&apos;-inf&apos;)    def maxPathSum(self, root: TreeNode) -&gt; int:        self.getMax(root)        return self.res    def getMax(self,root):        if not root:            return 0        # 如果子树路径和为负则应当置0表示最大路径不包含子树        left = max(0, self.getMax(root.left))        right = max(0, self.getMax(root.right))        # 以当前节点为根节点,判断在该节点包含左右子树的路径和是否大于当前最大路径和        self.res = max(self.res, root.val + left + right)        # 当前节点作为父节点的一个子节点和父节点连接的话则需取【单端的最大值】返回        return max(left, right) + root.val</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个非空二叉树，返回其最大路径和。&lt;/p&gt;
&lt;p&gt;本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: [1,2,3]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  1
 / \
2   3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出: 6&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-maximum-path-sum&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/binary-tree-maximum-path-sum&lt;/a&gt;&lt;br&gt;著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode104-二叉树的最大深度</title>
    <link href="http://peisenli.github.io/2019/08/16/LeetCode104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>http://peisenli.github.io/2019/08/16/LeetCode104-二叉树的最大深度/</id>
    <published>2019-08-16T09:22:45.000Z</published>
    <updated>2019-08-16T09:28:36.792Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。<br>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，  </p><pre><code>  3   / \  9  20    /  \   15   7  </code></pre><p>返回它的最大深度 3 。<br><a id="more"></a><br>python递归实现：</p><pre><code># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def maxDepth(self, root: TreeNode) -&gt; int:        if not root:            return 0        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))# 方法二 迭代class Solution:    &quot;&quot;&quot;    迭代法    &quot;&quot;&quot;    def maxDepth(self, root):        stack = []                                              # 定义一个空栈，栈中的元素是结点及其对应的深度        if root:                                                # 如果根结点不为空            stack.append((root, 1))                             # 则将根节点及其对应深度1组成的元组入栈        max_depth = 0                                           # 初始化最大深度为零        while stack:                                            # 当栈非空时            tree_node, cur_depth = stack.pop()                  # 弹出栈顶结点及其对应的深度            if tree_node:                                       # 如果该结点不为空                max_depth = max(max_depth, cur_depth)           # 更新当前最大深度，如果该结点深度更大的话                stack.append((tree_node.left, cur_depth+1))     # 将该结点的左孩子结点及其对应深度压入栈中                stack.append((tree_node.right, cur_depth+1))    # 将该结点的右孩子结点及其对应深度压入栈中        return max_depth</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉树，找出其最大深度。&lt;br&gt;二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。&lt;br&gt;说明: 叶子节点是指没有子节点的节点。&lt;br&gt;示例：&lt;br&gt;给定二叉树 [3,9,20,null,null,15,7]，  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  3  
 / \  
9  20  
  /  \  
 15   7  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;返回它的最大深度 3 。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode231-2的幂</title>
    <link href="http://peisenli.github.io/2019/08/14/LeetCode231-2%E7%9A%84%E5%B9%82/"/>
    <id>http://peisenli.github.io/2019/08/14/LeetCode231-2的幂/</id>
    <published>2019-08-14T02:54:54.000Z</published>
    <updated>2019-08-14T03:08:09.628Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。<br>示例 1:<br>输入: 1<br>输出: true<br>解释: 20 = 1<br>示例 2:<br>输入: 16<br>输出: true<br>解释: 24 = 16<br>示例 3:<br>输入: 218<br>输出: false<br><a id="more"></a><br>解题思路：<br><strong>1.位运算</strong><br>如果是2的幂，则二进制应该只有最高位上是1，其他都是0；<br>基于上面的结论，n-1应该除了最高位是0（与n最高位对应的位置），其他都是1；<br>因此，n&amp;(n-1) 应该等于0。  </p><pre><code>class Solution:def isPowerOfTwo(self, n: int) -&gt; bool:    if n &gt; 0 and n&amp;(n-1) == 0:        return True    else:        return False</code></pre><p><strong>2.迭代法</strong><br>用此数一直除以2，判断是否整除。</p><pre><code>class Solution:def isPowerOfTwo(self, n: int) -&gt; bool:    if n&lt;=0: return False    while n&gt;1:        if n%2==0:            n /= 2        else:            return False    return True</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数，编写一个函数来判断它是否是 2 的幂次方。&lt;br&gt;示例 1:&lt;br&gt;输入: 1&lt;br&gt;输出: true&lt;br&gt;解释: 20 = 1&lt;br&gt;示例 2:&lt;br&gt;输入: 16&lt;br&gt;输出: true&lt;br&gt;解释: 24 = 16&lt;br&gt;示例 3:&lt;br&gt;输入: 218&lt;br&gt;输出: false&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>图的遍历代码</title>
    <link href="http://peisenli.github.io/2019/08/13/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E4%BB%A3%E7%A0%81/"/>
    <id>http://peisenli.github.io/2019/08/13/图的遍历代码/</id>
    <published>2019-08-13T07:50:03.000Z</published>
    <updated>2019-08-13T07:53:17.212Z</updated>
    
    <content type="html"><![CDATA[<h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>1.准备工作：创建一个visited数组，用来记录已被访问过的顶点；创建一个队列，用来存放每一层的顶点；初始化图G。<br>2.从图中的v0开始访问，将的visited[v0]数组的值设置为true，同时将v0入队。<br>3.只要队列不空，则重复如下操作：<br>(1)队头顶点u出队。<br>(2)依次检查u的所有邻接顶点w，若visited[w]的值为false，则访问w，并将visited[w]置为true，同时将w入队。<br><a id="more"></a><br><strong>用邻接矩阵表示图的广度优先搜索</strong></p><pre><code>/*一些量的定义*/queue&lt;char&gt; q;                //定义一个队列，使用库函数queue#define MVNum 100            //表示最大顶点个数bool visited[MVNum];                //定义一个visited数组，记录已被访问的顶点/*邻接矩阵存储表示*/typedef struct AMGraph{    char vexs[MVNum];            //顶点表    int arcs[MVNum][MVNum];      //邻接矩阵    int vexnum, arcnum;          //当前的顶点数和边数}AMGraph;/*找到顶点v的对应下标*/int LocateVex(AMGraph &amp;G, char v){    int i;    for (i = 0; i &lt; G.vexnum; i++)        if (G.vexs[i] == v)            return i;}/*采用邻接矩阵表示法，创建无向图G*/int CreateUDG_1(AMGraph &amp;G){    int i, j, k;    char v1, v2;    scanf(&quot;%d%d&quot;, &amp;G.vexnum, &amp;G.arcnum);                    //输入总顶点数，总边数    getchar();                               //获取&apos;\n’，防止其对之后的字符输入造成影响    for (i = 0; i &lt; G.vexnum; i++)                    scanf(&quot;%c&quot;, &amp;G.vexs[i]);            //依次输入点的信息    for (i = 0; i &lt; G.vexnum; i++)        for (j = 0; j &lt; G.vexnum; j++)            G.arcs[i][j] = 0;            //初始化邻接矩阵边，0表示顶点i和j之间无边    for (k = 0; k &lt; G.arcnum; k++)    {        getchar();        scanf(&quot;%c%c&quot;, &amp;v1, &amp;v2);            //输入一条边依附的顶点        i = LocateVex(G, v1);                //找到顶点i的下标        j = LocateVex(G, v2);                //找到顶点j的下标        G.arcs[i][j] = G.arcs[j][i] = 1;            //1表示顶点i和j之间有边，无向图不区分方向    }    return 1;}/*采用邻接矩阵表示图的广度优先遍历*/void BFS_AM(AMGraph &amp;G,char v0){    /*从v0元素开始访问图*/    int u,i,v,w;    v = LocateVex(G,v0);                 //找到v0对应的下标    printf(&quot;%c &quot;, v0);                   //打印v0    visited[v] = 1;                         //顶点v0已被访问    q.push(v0);                            //将v0入队    while (!q.empty())    {        u = q.front();                //将队头元素u出队，开始访问u的所有邻接点        v = LocateVex(G, u);            //得到顶点u的对应下标        q.pop();                //将顶点u出队        for (i = 0; i &lt; G.vexnum; i++)        {            w = G.vexs[i];            if (G.arcs[v][i] &amp;&amp; !visited[i])//顶点u和w间有边，且顶点w未被访问            {                printf(&quot;%c &quot;, w);    //打印顶点w                q.push(w);        //将顶点w入队                visited[i] = 1;        //顶点w已被访问            }        }    }}   </code></pre><p><strong>用邻接表表示图的广度优先搜索</strong>  </p><pre><code>/*找到顶点对应的下标*/int LocateVex(ALGraph &amp;G, char v){    int i;    for (i = 0; i &lt; G.vexnum; i++)        if (v == G.vertices[i].data)            return i;}/*邻接表存储表示*/typedef struct ArcNode            //边结点{    int adjvex;        //该边所指向的顶点的位置    ArcNode *nextarc;    //指向下一条边的指针    int info;        //和边相关的信息，如权值}ArcNode;typedef struct VexNode        //表头结点{    char data;                    ArcNode *firstarc;    //指向第一条依附该顶点的边的指针}VexNode,AdjList[MVNum];    //AbjList表示一个表头结点表typedef struct ALGraph{    AdjList vertices;    int vexnum, arcnum;}ALGraph;/*采用邻接表表示法，创建无向图G*/int CreateUDG_2(ALGraph &amp;G){    int i, j, k;    char v1, v2;    scanf(&quot;%d%d&quot;, &amp;G.vexnum, &amp;G.arcnum);            //输入总顶点数，总边数    getchar();    for (i = 0; i &lt; G.vexnum; i++)            //输入各顶点，构造表头结点表    {        scanf(&quot;%c&quot;, &amp;G.vertices[i].data);    //输入顶点值        G.vertices[i].firstarc = NULL;        //初始化每个表头结点的指针域为NULL    }    for (k = 0; k &lt; G.arcnum; k++)            //输入各边，构造邻接表    {        getchar();        scanf(&quot;%c%c&quot;, &amp;v1, &amp;v2);            //输入一条边依附的两个顶点        i = LocateVex(G, v1);                //找到顶点i的下标        j = LocateVex(G, v2);                //找到顶点j的下标        ArcNode *p1 = new ArcNode;            //创建一个边结点*p1        p1-&gt;adjvex = j;                        //其邻接点域为j        p1-&gt;nextarc = G.vertices[i].firstarc; G.vertices[i].firstarc = p1; // 将新结点*p插入到顶点v1的边表头部        ArcNode *p2 = new ArcNode;            //生成另一个对称的新的表结点*p2        p2-&gt;adjvex = i;        p2-&gt;nextarc = G.vertices[j].firstarc;        G.vertices[j].firstarc = p1;    }    return 1;}/*采用邻接表表示图的广度优先遍历*/void BFS_AL(ALGraph &amp;G, char v0){    int u,w,v;    ArcNode *p;    printf(&quot;%c &quot;, v0);                                                //打印顶点v0    v = LocateVex(G, v0);                                                    //找到v0对应的下标    visited[v] = 1;                                                    //顶点v0已被访问    q.push(v0);                                                //将顶点v0入队    while (!q.empty())    {        u = q.front();                                                //将顶点元素u出队，开始访问u的所有邻接点        v = LocateVex(G, u);                                            //得到顶点u的对应下标        q.pop();            //将顶点u出队        for (p = G.vertices[v].firstarc; p; p = p-&gt;nextarc)        //遍历顶点u的邻接点        {            w = p-&gt;adjvex;                if (!visited[w])    //顶点p未被访问            {                printf(&quot;%c &quot;, G.vertices[w].data);            //打印顶点p                visited[w] = 1;                        //顶点p已被访问                q.push(G.vertices[w].data);            //将顶点p入队            }        }    }}</code></pre><hr><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>深度优先搜索类似于树的先序遍历，具体过程如下：<br>创建一个visited数组，用于记录所有被访问过的顶点。<br>1.从图中v0出发，访问v0。<br>2.找出v0的第一个未被访问的邻接点，访问该顶点。以该顶点为新顶点，重复此步骤，直至刚访问过的顶点没有未被访问的邻接点为止。<br>3.返回前一个访问过的仍有未被访问邻接点的顶点，继续访问该顶点的下一个未被访问领接点。<br>4.重复2,3步骤，直至所有顶点均被访问，搜索结束。<br><strong>用邻接矩阵表示图的深度优先搜索</strong></p><pre><code>void DFS_AM(AMGraph &amp;G, int v){    int w;    printf(&quot;%c &quot;, G.vexs[v]);    visited[v] = 1;    for (w = 0; w &lt; G.vexnum; w++)        if (G.arcs[v][w]&amp;&amp;!visited[w]) //递归调用            DFS_AM(G,w);}</code></pre><p><strong>用邻接表表示图的深度优先搜素</strong></p><pre><code>void DFS_AL(ALGraph &amp;G, int v){    int w;    printf(&quot;%c &quot;, G.vertices[v].data);    visited[v] = 1;    ArcNode *p = new ArcNode;    p = G.vertices[v].firstarc;    while (p)    {        w = p-&gt;adjvex;        if (!visited[w]) DFS_AL(G, w);        p = p-&gt;nextarc;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;广度优先搜索&quot;&gt;&lt;a href=&quot;#广度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;广度优先搜索&quot;&gt;&lt;/a&gt;广度优先搜索&lt;/h3&gt;&lt;p&gt;1.准备工作：创建一个visited数组，用来记录已被访问过的顶点；创建一个队列，用来存放每一层的顶点；初始化图G。&lt;br&gt;2.从图中的v0开始访问，将的visited[v0]数组的值设置为true，同时将v0入队。&lt;br&gt;3.只要队列不空，则重复如下操作：&lt;br&gt;(1)队头顶点u出队。&lt;br&gt;(2)依次检查u的所有邻接顶点w，若visited[w]的值为false，则访问w，并将visited[w]置为true，同时将w入队。&lt;br&gt;
    
    </summary>
    
    
      <category term="Data Struct" scheme="http://peisenli.github.io/tags/Data-Struct/"/>
    
  </entry>
  
  <entry>
    <title>图的遍历问题</title>
    <link href="http://peisenli.github.io/2019/08/13/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98/"/>
    <id>http://peisenli.github.io/2019/08/13/图的遍历问题/</id>
    <published>2019-08-13T07:04:08.000Z</published>
    <updated>2019-08-13T07:22:31.705Z</updated>
    
    <content type="html"><![CDATA[<p>图的遍历：从图中某个顶点出发游历图，访遍图中其余顶点，并且使图中的每个顶点仅被访问一次的过程。我们可以设置一个全局型标志数组visited来标志某个顶点是否被访问过，未访问的值为0，访问过的值为1。<br><a id="more"></a></p><h3 id="深度优先搜索遍历"><a href="#深度优先搜索遍历" class="headerlink" title="深度优先搜索遍历"></a>深度优先搜索遍历</h3><p>深度优先搜索遍历类似于树的先序遍历。假定给定图G的初态是所有顶点均未被访问过，在G中任选一个顶点i作为遍历的初始点，则深度优先搜索遍历可定义如下：<br>(1)首先访问顶点i，并将其访问标记置为访问过，即visited[i]=1；<br>(2)然后搜索与顶点i有边相连的下一个顶点j，若j未被访问过，则访问它，并将j的访问标记置为访问过，visited[j]=1，然后从j开始重复此过程，若j已访问，再看与i有边相连的其它顶点；<br>(3)若与i有边相连的顶点都被访问过，则退回到前一个访问顶点并重复刚才过程，直到图中所有顶点都被访问完为止。<br>若图是连通的或强连通的，则从图中某一个顶点出发可以访问到图中所有顶点，否则只能访问到一部分顶点。另外，从刚才写出的遍历结果可以看出，从某一个顶点出发的遍历结果是不唯一的。但是,若我们给定图的存贮结构,则从某一顶点出发的遍历结果应是唯一的。<br><strong>用邻接矩阵实现图的深度优先搜索</strong></p><pre><code>void dfs (int i)          /* 从顶点i 出发遍历*/{       int j;                                                               visit(i);               /*输出访问顶点*/    visited[i]=1;       /*全局数组访问标记置1表示已经访问*/    for(j=1; j&lt;=n; j++)         if((A[i][j]==1)&amp;&amp;(!visited[j]))        dfs(j);        }</code></pre><p>时间复杂度为:O(n2)<br><strong>用邻接表实现图的深度优先搜索</strong></p><pre><code>void  dfs1(int i){      link *p;       visit(head[i]) ;       //输出访问顶点    visted[i]=1;        //全局数组访问标记置为1表示已访问    p=head[i].link;    while (p!=NULL)    {          if(!visited[p-&gt;adjvex]) //如果p指向的邻接点未被访问过            dfs1(p-&gt;adjvex);           p=p-&gt;next;    }}</code></pre><p>而当以邻接表作图的存储结构时，找邻接点所需时间为O(e)，其中e为无向图中边的数或有向图中弧的数。由此，当以邻接表作存储结构时，深度优先搜索遍历图的时间复杂度为O(n＋e)。<br><strong>非连通图的深度优先搜索</strong><br>若图是非连通的或非强连通图，则从图中某一个顶点出发。不能用深度优先搜索访问到图中所有顶点，而只能访问到一个连通子图（既连通分量）或只能访问到一个强连通子图（即强连通分量）。这时，可以在每个连通分量或每个强连通分量中都选一个顶点，进行深度优先搜索遍历，最后将每个连通分量或每个强连通分量的遍历结果合起来，则得到整个非连通图的遍历结果。<br>遍历算法实现与连通图的只有一点不同，即对所有顶点进行循环，反复调用连通图的深度优先搜索遍历算法即可。</p><hr><h3 id="广度优先搜索遍历"><a href="#广度优先搜索遍历" class="headerlink" title="广度优先搜索遍历"></a>广度优先搜索遍历</h3><p>广度优先搜索遍历类似于树的按层次遍历。设图G的初态是所有顶点均未访问，在G 中任选一顶点i作为初始点，则广度优先搜索的基本思想是：<br>(1)首先访问顶点i，并将其访问标志置为已被访问，即visited[i]=1；<br>(2)接着依次访问与顶点i有边相连的所有顶点W1，W2，…，Wt；<br>(3)然后再按顺序访问与W1，W2，…，Wt有边相连又未曾访问过的顶点；<br>依此类推，直到图中所有顶点都被访问完为止 。   </p><pre><code>void bfs(Graph g ,vtx * v）{   visit(v); visited[v]=1; INIQUEUE(Q);ENQUEUE(Q,v); while (!EMPTY(Q)){     DLQUEUE(Q,v); //队头元素出队     w=FIRSTADJ(g,v);        //求v的邻接点    while (w!=0)    {         if(!visited[w])         {             visit(w);             visited[w]=1;                        ENQUEUE(Q,w);         }         w=NEXTADJ(g,v,w);//求下一邻接点     } } }//bfs </code></pre><p><strong>用邻接矩阵实现图的广度优先搜索遍历</strong><br>算法描述如下：</p><pre><code>void  bfs(int  i)      //从顶点i出发遍历{      int  Q[n+1] ;       //Q为队列    int  f,r,j ;        // f,r分别为队列头，尾指针    f=r=0 ;             //设置空队列    visit(v[i]) ;       // 输出访问顶点    visited[i]=1 ;      //全局数组标记置1表示已经访问    r++; q[r]=i ;       //入队列    while (f&lt;r)     {           f++;         i=q[f] ;       //出队列           for (j=1; j&lt;=n; j++)               if ((A[i][j]==1)&amp;&amp;(!visited[j]))            {                  visit(v[j]);                     visited[j]=1;                     r++; q[r]=j;            }    }   }</code></pre><p><strong>用邻接表实现图的广序优先搜索遍历</strong><br>算法描述如下：</p><pre><code>void  BFSl(int i){      int  q[n+1] ;                               //定义队列    int  f,r ;      E_NODE *p ;             //P为搜索指针    f=r=0 ;      visit(head[i]) ;    visited[i]=1; r++; q[r]=i ;                //进队    while (f&lt;r)       {         f++ ; i=q[f] ;    //出队  p=head[i].link ;          while  (p!=NULL)        {               if(!visited[p-&gt;adjvex])                 {                      visit(head[p-&gt;adjvex].vertex;                    visited[p-&gt;adjvex]=1;                       r++;q[r]=p-&gt;adjvex;                 }            p=p-&gt;next;         }    }  }</code></pre><p><strong>非连通图的广度优先搜索</strong><br>若图是非连通的或非强连通图，则从图中某一个顶点出发。不能用广度优先搜索遍历访问到图中所有顶点，而只能访问到一个连通子图（既连通分量）或只能访问到一个强连通子图（既强连通分量）。这时，可以在每个连通分量或每个强连通分量中都选一个顶点，进行广度优先搜索遍历，最后将每个连通分量或每个强连通分量的遍历结果合起来，则得到整个非连通图或非强连通图的广度优先搜索遍历序列。<br>遍历算法实现与连通图的只有一点不同，即对所有顶点进行循环，反复调用连通图的广度优先搜索遍历算法即可。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图的遍历：从图中某个顶点出发游历图，访遍图中其余顶点，并且使图中的每个顶点仅被访问一次的过程。我们可以设置一个全局型标志数组visited来标志某个顶点是否被访问过，未访问的值为0，访问过的值为1。&lt;br&gt;
    
    </summary>
    
    
      <category term="Data Struct" scheme="http://peisenli.github.io/tags/Data-Struct/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode169.求众数</title>
    <link href="http://peisenli.github.io/2019/08/13/LeetCode169-%E6%B1%82%E4%BC%97%E6%95%B0/"/>
    <id>http://peisenli.github.io/2019/08/13/LeetCode169-求众数/</id>
    <published>2019-08-13T03:04:28.000Z</published>
    <updated>2019-08-13T03:34:55.541Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊n/2⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在众数。<br>示例 1:<br>输入: [3,2,3]<br>输出: 3<br>示例 2:<br>输入: [2,2,1,1,1,2,2]<br>输出: 2<br>来源：力扣（LeetCode）<br>解题思路：摩尔投票算法<br>从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，总能找到最多的那个。<br><a id="more"></a><br>python实现：    </p><pre><code>class Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        MostF = nums[0]        count = 1;        for i in range(1,len(nums)):            if MostF == nums[i]:                count += 1            else:                count -=1                if count == 0:                      MostF = nums[i + 1]        return MostF</code></pre><p>Boyer-Moore majority vote algorithm(摩尔投票算法)是一种在线性时间O(n)和空间复杂度的情况下，在一个元素序列中查找包含最多的元素。它是以Robert S.Boyer和J Strother Moore命名的，1981年发明的，是一种典型的流算法(streaming algorithm)。<br>在它最简单的形式就是，查找最多的元素，也就是在输入中重复出现超过一半以上(n/2)的元素。如果序列中没有最多的元素，算法不能检测到正确结果，将输出其中的一个元素之一。<br>当元素重复的次数比较小的时候，对于流算法不能在小于线性空间的情况下查找频率最高的元素。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊n/2⌋ 的元素。&lt;br&gt;你可以假设数组是非空的，并且给定的数组总是存在众数。&lt;br&gt;示例 1:&lt;br&gt;输入: [3,2,3]&lt;br&gt;输出: 3&lt;br&gt;示例 2:&lt;br&gt;输入: [2,2,1,1,1,2,2]&lt;br&gt;输出: 2&lt;br&gt;来源：力扣（LeetCode）&lt;br&gt;解题思路：摩尔投票算法&lt;br&gt;从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，总能找到最多的那个。&lt;br&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://peisenli.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>图的存储结构</title>
    <link href="http://peisenli.github.io/2019/08/13/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
    <id>http://peisenli.github.io/2019/08/13/图的存储结构/</id>
    <published>2019-08-13T02:41:59.000Z</published>
    <updated>2019-08-13T02:48:19.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a><center>图的存储结构</center></h2><p>由于图的结构比较复杂，任意两个顶点之间都可能存在关系，因此无法以数据元素在存储区中的物理位置来表示元素之间关系，即图没有顺序映象的存储结构。<br>另一方面，用多重链表表示图是自然的事，它是一种最简单的链式映象结构，即以一个由一个数据域和多个指针域组成的结点表示图中一个顶点，其中数据域存储该顶点的信息，指针域存储指向其邻接点的指针。  </p><p><center><img src="https://i.loli.net/2019/08/13/YLTV6NISDibzh53.png" alt="多重.jpg"><br>图1 有向图多重链表<br><img src="https://i.loli.net/2019/08/13/MRQzS3pCLbJFoZO.png" alt="表.jpg"><br>图2 无向图的多重链表</center><br>我们一般采用一些改进的方式来存储图，常用的有邻接矩阵、邻接表和十字链表及邻接多重表等。除了要存储图中各个顶点本身的信息外，同时还要存储顶点与顶点之间的所有关系（边的信息）。存储方法的选择，取决于具体的应用。  </p><a id="more"></a><hr><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>在邻接矩阵表示中，除了存放顶点本身信息外，还用一个矩阵表示各个顶点之间的关系。若(i,j)∈E(G)或&lt;i,j&gt;∈E(G),则矩阵中第i行 第j列元素值为1，否则为0 。<br><strong>无向图：  </strong>  </p><p><center><img src="https://i.loli.net/2019/08/13/eo1HNckBwgzQDiM.png" alt="邻阶矩阵.jpg"><br>图3 无向图的邻接矩阵表示</center><br>分析1：无向图的邻接矩阵是对称的；<br>分析2：顶点i 的度＝第 i 行 (列) 中1 的个数；<br>特别：完全图的邻接矩阵中，对角元素为0，其余1。<br>结论：<br>（1）矩阵是对称的，可压缩存储(上(下)三角);<br>（2）第i行或第i 列中1的个数为顶点i 的度;<br>（3）矩阵中1的个数的一半为图中边的数目;<br>（4）很容易判断顶点i和顶点j之间是否有边相连(看矩阵中i行j列值是否为1)。   </p><hr><p><strong>有向图：</strong>  </p><p><center><img src="https://i.loli.net/2019/08/13/jsqWJYnwrG9HM3X.png" alt="1565661031(1).jpg"><br>有向图的邻接矩阵表示</center><br>分析1：有向图的邻接矩阵可能是不对称的。<br>分析2：顶点的出度=第i行元素之和，顶点的入度=第i列元素之和，顶点的度=第i行元素之和+第i列元素之和。<br>结论：<br>（1） 矩阵不一定是对称的;<br>（2） 第i 行中1的个数为顶点i 的出度;<br>（3） 第i列中1的个数为顶点 i的入度;<br>（4） 矩阵中1的个数为图中弧的数目;<br>（5） 很容易判断顶点i 和顶点j 是否有弧相连.<br>邻接矩阵法优点：<br>容易实现图的操作，如：求某顶点的度、判断顶点之间是否有边（弧）、找顶点的邻接点等等。<br>邻接矩阵法缺点：<br>n个顶点需要n*n个单元存储边(弧);空间效率为O(n2)。 对稀疏图而言尤其浪费空间。</p><pre><code>#define INFINITE 9999       /* 假设的无穷大数 */void  creatadj(int n,int e,int t) /*n为顶点数,e为边数,t为1~4,分别表示无向图、有向图、带权无向图、带权有向图*/{      int i,j,k,w;    for(i=1;i&lt;=n;i++)     {          printf(“输入第%d顶点信息”,i);        v[i]=getchar();      }    for(i=1;i&lt;=n;i++)          for(j=1;j&lt;=n;j++)            if(t&gt;2)                 A[i][j]=INFINITE;            else                     A[i][j]=0;      for(k=1;k&lt;=e;k++)     {          scanf(“%d,%d”,&amp;i,&amp;j);         if(i&gt;n ||j&gt;n)  exit(0);         if(t&gt;2)            {                 scanf(“%d”,&amp;w);            A[i][j]=w;               if(t==3) A[j][i]=w;          }        else                 {             A[i][j]=1;            if(t==1)  A[j][i]=1;          }      }} </code></pre><hr><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>图的邻接表存储方法是一种顺序分配与链式分配相结合的存储方法，它包括两部分：一部分是单链表，用来存放边的信息；另一部分是数组，主要用来存放顶点本身的数据信息。<br><strong>有向图：</strong>  </p><p><center><img src="https://i.loli.net/2019/08/13/sz1qmV6A5EdBNKb.png" alt="1565662180(1).jpg"><br>有向图的邻接表表示</center><br>出度：OD(Vi)＝单链出边表中链接的结点数<br>入度：ID(Vi)＝邻接点域为Vi的弧个数<br>结论：<br>（1）第i 个链表中结点数目为顶点i的出度；<br>（2）所有链表中结点数目为图中弧数；<br>（3）占用的存储单元数目为n+e 。<br><strong>无向图：</strong>  </p><p><center><img src="https://i.loli.net/2019/08/13/9MOj6Fop7kiV1qG.png" alt="1565662132(1).jpg"><br>无向图的邻接表表示</center><br>注：邻接表不唯一，因各个边结点的链入顺序是任意的<br>空间效率为O(n+2e)。<br>若是稀疏图(e&lt;&lt;n2)，比邻接矩阵表示法O(n2)省空间。<br>结论：<br>（1）第i 个链表中结点数目为顶点i的度；<br>（2）所有链表中结点数目的一半为图中边数；<br>（3）占用的存储单元数目为n+2e 。<br><strong>邻接表优缺点：</strong><br>优：空间效率高；容易寻找顶点的邻接点；<br>缺：判断两顶点间是否有边或弧，需搜索两结点对应的单链表，没有邻接矩阵方便。<br><strong>与邻接矩阵对比：</strong><br>① 对于任一确定的无向图，邻接矩阵是唯一的（行列号与顶点编号一致），但邻接表不唯一（链接次序与顶点编号无关）。<br>② 邻接矩阵的空间复杂度为O(n2),而邻接表的空间复杂度为O(n+e)。<br>③ 邻接矩阵多用于稠密图；而邻接表多用于稀疏图</p><h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p>C语言实现及定义：<br><img src="https://i.loli.net/2019/08/13/fT7IYKbRoOXiqQN.png" width="250" hegiht="100" align="left">  </p><pre><code>弧结点：typedef  struct  arcnode{       int   tailvex,  headvex;        //弧尾、弧头在表头数组中位置     struct   arcnode   *hlink；//指向弧头相同的下一条弧     struct   arcnode   *tlink;    //指向弧尾相同的下一条弧}AD;    顶点结点：typedef  struct  dnode{       int   data;  //存与顶点有关信息     struct   arcnode   *firstin；//指向以该顶点为弧头的第一个弧结点     struct   arcnode   *firstout; //指向以该顶点为弧尾的第一个弧结点}DD;</code></pre><h3 id="多重链表"><a href="#多重链表" class="headerlink" title="多重链表"></a>多重链表</h3><p>C语言实现及定义：<br><img src="https://i.loli.net/2019/08/13/tEPCrjLlOzBwXY5.png" width="250" hegiht="200" align="left">  </p><pre><code>边结点：typedef   struct  node{       int  mark;   //标志域     int  ivex, jvex;  //该边依附的两个顶点在表头数组中位置     struct  node   *ilink,  *jlink;  //分别指向依附于ivex和jvex的下一条边}JD;顶点结点：typedef   struct  dnode{        int   data;   //存与顶点有关的信息    struct   node  *firstedge;  //指向第一条依附于该顶点的边}DD;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;图的存储结构&quot;&gt;&lt;a href=&quot;#图的存储结构&quot; class=&quot;headerlink&quot; title=&quot;图的存储结构&quot;&gt;&lt;/a&gt;&lt;center&gt;图的存储结构&lt;/center&gt;&lt;/h2&gt;&lt;p&gt;由于图的结构比较复杂，任意两个顶点之间都可能存在关系，因此无法以数据元素在存储区中的物理位置来表示元素之间关系，即图没有顺序映象的存储结构。&lt;br&gt;另一方面，用多重链表表示图是自然的事，它是一种最简单的链式映象结构，即以一个由一个数据域和多个指针域组成的结点表示图中一个顶点，其中数据域存储该顶点的信息，指针域存储指向其邻接点的指针。  &lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src=&quot;https://i.loli.net/2019/08/13/YLTV6NISDibzh53.png&quot; alt=&quot;多重.jpg&quot;&gt;&lt;br&gt;图1 有向图多重链表&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2019/08/13/MRQzS3pCLbJFoZO.png&quot; alt=&quot;表.jpg&quot;&gt;&lt;br&gt;图2 无向图的多重链表&lt;/center&gt;&lt;br&gt;我们一般采用一些改进的方式来存储图，常用的有邻接矩阵、邻接表和十字链表及邻接多重表等。除了要存储图中各个顶点本身的信息外，同时还要存储顶点与顶点之间的所有关系（边的信息）。存储方法的选择，取决于具体的应用。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Data Struct" scheme="http://peisenli.github.io/tags/Data-Struct/"/>
    
  </entry>
  
  <entry>
    <title>图的基本概念</title>
    <link href="http://peisenli.github.io/2019/08/13/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://peisenli.github.io/2019/08/13/图的基本概念/</id>
    <published>2019-08-13T01:28:03.000Z</published>
    <updated>2019-08-13T01:32:16.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="  图的基本概念 "></a><center>  图的基本概念 </center></h2><p><strong>图结构特点：</strong><br>图(Graph)是一种较线性表和树更为复杂的数据结构。在线性表中，数据元素之间仅有线性关系，即每个数据元素只有一个直接前驱和一个直接后继；在树形结构中，数据元素 之间有着明显的层次关系，虽然每一层上的数据元素可能和下一层中多个元素(孩子) 相关，但只能和上一层中一个元素(双亲)相关；而在图形结构中，结点之间 的关系可以是任意的，任意两个数据元素之间都可能相关。   </p><a id="more"></a><hr><p><strong>图的定义：</strong><br>Graph=(V,E)，V：顶点(数据元素)的有穷非空集合；E：边的有穷集合。<br>无向图：每条边都是无方向的<br>有向图：每条边都是有方向的  </p><p><center><img src="https://i.loli.net/2019/08/13/jDrKtBVpOiHXWhY.png" alt="1565658564(1).jpg"></center><br>完全图：任意两个点都有一条边相连。<br>有向完全图边数：n(n-1)<br>无向完全图边数：n(n-1)/2<br>稀疏图：有很少边或弧的图。<br>稠密图：有较多边或弧的图。<br>网：边/弧带权的图。<br>邻接：有边/弧相连的两个顶点之间的关系。存在(vi, vj)，则称vi和vj互为邻接点；存在&lt;vi, vj&gt;，则称vi邻接到vj， vj邻接于vi。<br>关联(依附)：边/弧与顶点之间的关系。存在(vi, vj)/ &lt;vi, vj&gt;， 则称该边/弧关联于vi和vj。<br>顶点的度：与该顶点相关联的边的数目，记为TD(v)<br>在有向图中, 顶点的度等于该顶点的入度与出度之和。<br>顶点 v 的入度是以 v 为终点的有向边的条数, 记作 ID(v)<br>顶点 v 的出度是以 v 为始点的有向边的条数, 记作OD(v)<br>路径：接续的边构成的顶点序列。<br>路径长度：路径上边或弧的数目/权值之和。<br>回路(环)：第一个顶点和最后一个顶点相同的路径。<br>简单路径：除路径起点和终点可以相同外，其余顶点均不相同的路径。<br>简单回路(简单环)：除路径起点和终点相同外，其余顶点均不相同的路径。  </p><p><center><img src="https://i.loli.net/2019/08/13/jACpbBO4NJFxMXz.png" alt="图片1.png"></center><br>在无（有）向图G=( V, E )中，若对任何两个顶点 v、u 都存在从v 到 u 的路径，则称G是连通图（强连通图）。  </p><p><center><img src="https://i.loli.net/2019/08/13/cAGOqHbg9ZmktjD.png" alt="tu.png"></center><br>权与网：图中边或弧所具有的相关数称为权。表明从一个顶点到另一个顶点的距离或耗费。带权的图称为网。<br>子图：设有两个图G=（V，{E}）、G1=（V1，{E1}），若V1  V，E1  E，则称 G1是G的子图。例:(b)、(c) 是 (a) 的子图。  </p><h2 id><a href="#" class="headerlink" title></a><center><img src="https://i.loli.net/2019/08/13/SMVnxFU8oTlirfZ.png" alt="ww.jpg"></center></h2><p>极大连通子图意思是：该子图是 G 连通子图，将G 的任何不在该子图中的顶点加入，子图不再连通。<br>有向图极大强连通子图意思是：该子图是G的强连通子图，将D的任何不在该子图中的顶点加入，子图不再是强连通的。<br>极小连通子图：该子图是G 的连通子图，在该子图中删除任何一条边，子图不再连通。<br>生成树：包含无向图G 所有顶点的极小连通子图。<br>生成森林：对非连通图，由各个连通分量的生成树的集合。        </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;图的基本概念&quot;&gt;&lt;a href=&quot;#图的基本概念&quot; class=&quot;headerlink&quot; title=&quot;  图的基本概念 &quot;&gt;&lt;/a&gt;&lt;center&gt;  图的基本概念 &lt;/center&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;图结构特点：&lt;/strong&gt;&lt;br&gt;图(Graph)是一种较线性表和树更为复杂的数据结构。在线性表中，数据元素之间仅有线性关系，即每个数据元素只有一个直接前驱和一个直接后继；在树形结构中，数据元素 之间有着明显的层次关系，虽然每一层上的数据元素可能和下一层中多个元素(孩子) 相关，但只能和上一层中一个元素(双亲)相关；而在图形结构中，结点之间 的关系可以是任意的，任意两个数据元素之间都可能相关。   &lt;/p&gt;
    
    </summary>
    
    
      <category term="Graph" scheme="http://peisenli.github.io/tags/Graph/"/>
    
  </entry>
  
</feed>
