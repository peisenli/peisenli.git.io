<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>帅的如此过分</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://peisenli.github.io/"/>
  <updated>2019-08-26T11:54:51.153Z</updated>
  <id>http://peisenli.github.io/</id>
  
  <author>
    <name>空空</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode146-LRU缓存机制</title>
    <link href="http://peisenli.github.io/2019/08/26/LeetCode146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://peisenli.github.io/2019/08/26/LeetCode146-LRU缓存机制/</id>
    <published>2019-08-26T11:43:56.000Z</published>
    <updated>2019-08-26T11:54:51.153Z</updated>
    
    <content type="html"><![CDATA[<p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。<br>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。<br>进阶:<br>你是否可以在 O(1) 时间复杂度内完成这两种操作？<br>示例:<br>LRUCache cache = new LRUCache( 2 /<em> 缓存容量 </em>/ );<br>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       // 返回  1<br>cache.put(3, 3);    // 该操作会使得密钥 2 作废<br>cache.get(2);       // 返回 -1 (未找到)<br>cache.put(4, 4);    // 该操作会使得密钥 1 作废<br>cache.get(1);       // 返回 -1 (未找到)<br>cache.get(3);       // 返回  3<br>cache.get(4);       // 返回  4   </p><a id="more"></a><p>思路</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。&lt;br&gt;获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。&lt;br&gt;写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。&lt;br&gt;进阶:&lt;br&gt;你是否可以在 O(1) 时间复杂度内完成这两种操作？&lt;br&gt;示例:&lt;br&gt;LRUCache cache = new LRUCache( 2 /&lt;em&gt; 缓存容量 &lt;/em&gt;/ );&lt;br&gt;cache.put(1, 1);&lt;br&gt;cache.put(2, 2);&lt;br&gt;cache.get(1);       // 返回  1&lt;br&gt;cache.put(3, 3);    // 该操作会使得密钥 2 作废&lt;br&gt;cache.get(2);       // 返回 -1 (未找到)&lt;br&gt;cache.put(4, 4);    // 该操作会使得密钥 1 作废&lt;br&gt;cache.get(1);       // 返回 -1 (未找到)&lt;br&gt;cache.get(3);       // 返回  3&lt;br&gt;cache.get(4);       // 返回  4   &lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode236-二叉树的最近公共祖先</title>
    <link href="http://peisenli.github.io/2019/08/22/LeetCode236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>http://peisenli.github.io/2019/08/22/LeetCode236-二叉树的最近公共祖先/</id>
    <published>2019-08-22T12:23:12.000Z</published>
    <updated>2019-08-22T12:31:07.009Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]<br><img src="https://i.loli.net/2019/08/22/6OtxHWUQA4CvMnX.png" alt="1566476957(1).jpg"><br>示例 1:<br>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出: 3<br>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。<br>示例 2:<br>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>输出: 5<br>解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。<br>说明:<br>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉树中。<br><a id="more"></a><br>解决思路：<br>首先在二叉树中搜索给定的节点 p 和 q，然后找到它们的最近共同祖先。我们可以使用普通的树遍历来搜索这两个节点。一旦我们达到所需的节点 p 和 q，我们就可以回溯并找到最近的共同祖先。   </p><ul><li>先分析自己，自己是p,q,None中的一者，自然返回自己。  </li><li>然后分析左右子树的返回值，如果其中一个是None，则返回另一个，作为传递，无论是传递最终的答案，还是传递p和q。  </li><li>如果左右子树返回p和q，当然返回root。 Python中的None即C/C++/Java 中的Null/null  </li></ul><hr><p><code></code></p><pre><code># Definition for a binary tree node.  # class TreeNode:  #     def __init__(self, x):  #         self.val = x  #         self.left = None  #         self.right = None  class Solution:    def lowestCommonAncestor(self, root: &apos;TreeNode&apos;, p: &apos;TreeNode&apos;, q: &apos;TreeNode&apos;) -&gt; &apos;TreeNode&apos;:        if root in (None ,p,q):            return root         L = self.lowestCommonAncestor(root.left,p,q)        R =self.lowestCommonAncestor(root.right,p,q)        return R if None==L else L if None==R else root</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;
&lt;p&gt;百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”&lt;/p&gt;
&lt;p&gt;例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2019/08/22/6OtxHWUQA4CvMnX.png&quot; alt=&quot;1566476957(1).jpg&quot;&gt;&lt;br&gt;示例 1:&lt;br&gt;输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1&lt;br&gt;输出: 3&lt;br&gt;解释: 节点 5 和节点 1 的最近公共祖先是节点 3。&lt;br&gt;示例 2:&lt;br&gt;输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4&lt;br&gt;输出: 5&lt;br&gt;解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。&lt;br&gt;说明:&lt;br&gt;所有节点的值都是唯一的。&lt;br&gt;p、q 为不同节点且均存在于给定的二叉树中。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode235-二叉搜索树的最近公共祖先</title>
    <link href="http://peisenli.github.io/2019/08/21/LeetCode235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>http://peisenli.github.io/2019/08/21/LeetCode235-二叉搜索树的最近公共祖先/</id>
    <published>2019-08-21T12:07:00.000Z</published>
    <updated>2019-08-21T13:28:14.457Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]<br><img src="https://i.loli.net/2019/08/21/e4NzuaE9J1jXqn5.png" alt="binarysearchtree_improved.png"><br>示例 1:<br>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。<br>示例 2:<br>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。<br>说明:<br>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉搜索树中。<br><a id="more"></a><br>算法<br>从根节点开始遍历树<br>如果节点 p 和节点 q 都在右子树上，那么以右孩子为根节点继续 1 的操作<br>如果节点 p 和节点 q 都在左子树上，那么以左孩子为根节点继续 1 的操作<br>如果条件 2 和条件 3 都不成立，这就意味着我们已经找到节 p 和节点 q 的 LCA 了  </p><pre><code># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def lowestCommonAncestor(self, root: &apos;TreeNode&apos;, p: &apos;TreeNode&apos;, q: &apos;TreeNode&apos;) -&gt; &apos;TreeNode&apos;:        # Value of current node or parent node.        parent_val = root.val        # Value of p        p_val = p.val        # Value of q        q_val = q.val        # If both p and q are greater than parent        if p_val &gt; parent_val and q_val &gt; parent_val:                return self.lowestCommonAncestor(root.right, p, q)        # If both p and q are lesser than parent        elif p_val &lt; parent_val and q_val &lt; parent_val:                return self.lowestCommonAncestor(root.left, p, q)        # We have found the split point, i.e. the LCA node.        else:            return root  </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。&lt;br&gt;百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”&lt;br&gt;例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2019/08/21/e4NzuaE9J1jXqn5.png&quot; alt=&quot;binarysearchtree_improved.png&quot;&gt;&lt;br&gt;示例 1:&lt;br&gt;输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8&lt;br&gt;输出: 6&lt;br&gt;解释: 节点 2 和节点 8 的最近公共祖先是 6。&lt;br&gt;示例 2:&lt;br&gt;输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4&lt;br&gt;输出: 2&lt;br&gt;解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。&lt;br&gt;说明:&lt;br&gt;所有节点的值都是唯一的。&lt;br&gt;p、q 为不同节点且均存在于给定的二叉搜索树中。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode230-二叉搜索树中第k小的元素</title>
    <link href="http://peisenli.github.io/2019/08/19/LeetCode230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>http://peisenli.github.io/2019/08/19/LeetCode230-二叉搜索树中第k小的元素/</id>
    <published>2019-08-19T10:51:40.000Z</published>
    <updated>2019-08-19T11:11:51.452Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。<br>说明：<br>你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。<br>示例 1:<br>输入: root = [3,1,4,null,2], k = 1  </p><pre><code>  3 / \1   4 \  2</code></pre><p>输出: 1<br>示例 2:<br>输入: root = [5,3,6,2,4,null,null,1], k = 3  </p><pre><code>      5     / \    3   6   / \  2   4 /1</code></pre><p>输出: 3<br>进阶：<br>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？<br>思路分析：利用“二叉搜索树”在“中序遍历”以后，得到的是有序数组，那么我们就中序遍历好了，遍历到第k个数即可。<br><a id="more"></a></p><pre><code># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def kthSmallest(self, root: TreeNode, k: int) -&gt; int:        # 模拟系统栈的方式实现，是一种比较通用的做法，        # 可以作为二叉树的三种非递归遍历        # 0 表示当前遍历到它，1 表示压入栈        # 刚开始是 1 ，不要写成 0 了        stack = [(1, root)]        while stack:            command, node = stack.pop()            if node is None:                # 不能写 return ，这不是递归                continue            if command == 0:                k -= 1                if k == 0:                    return node.val            else:                # 此时 command == 1 的时候，表示递归遍历到的                # 注意：写的时候倒过来写                stack.append((1, node.right))                stack.append((0, node))                stack.append((1, node.left))</code></pre><hr><p>二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。&lt;br&gt;说明：&lt;br&gt;你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。&lt;br&gt;示例 1:&lt;br&gt;输入: root = [3,1,4,null,2], k = 1  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  3
 / \
1   4
 \
  2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出: 1&lt;br&gt;示例 2:&lt;br&gt;输入: root = [5,3,6,2,4,null,null,1], k = 3  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;      5
     / \
    3   6
   / \
  2   4
 /
1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出: 3&lt;br&gt;进阶：&lt;br&gt;如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？&lt;br&gt;思路分析：利用“二叉搜索树”在“中序遍历”以后，得到的是有序数组，那么我们就中序遍历好了，遍历到第k个数即可。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode124-二叉树中最大路径和</title>
    <link href="http://peisenli.github.io/2019/08/18/LeetCode124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://peisenli.github.io/2019/08/18/LeetCode124-二叉树中最大路径和/</id>
    <published>2019-08-18T06:21:54.000Z</published>
    <updated>2019-08-18T06:41:29.862Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非空二叉树，返回其最大路径和。</p><p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p><p>示例 1:</p><p>输入: [1,2,3]</p><pre><code>  1 / \2   3</code></pre><p>输出: 6</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-maximum-path-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><a id="more"></a><br>思路：<br>对于任意一个节点, 如果最大和路径包含该节点, 那么只可能是两种情况:   </p><ol><li>其左右子树中所构成的和路径值较大的那个加上该节点的值后向父节点回溯构成最大路径  </li><li>左右子树都在最大路径中, 加上该节点的值构成了最终的最大路径      </li></ol><p><code></code></p><pre><code># Definition for a binary tree node.  # class TreeNode:  #     def __init__(self, x):  #         self.val = x  #         self.left = None  #         self.right = None    class Solution:    res = float(&apos;-inf&apos;)    def maxPathSum(self, root: TreeNode) -&gt; int:        self.getMax(root)        return self.res    def getMax(self,root):        if not root:            return 0        # 如果子树路径和为负则应当置0表示最大路径不包含子树        left = max(0, self.getMax(root.left))        right = max(0, self.getMax(root.right))        # 以当前节点为根节点,判断在该节点包含左右子树的路径和是否大于当前最大路径和        self.res = max(self.res, root.val + left + right)        # 当前节点作为父节点的一个子节点和父节点连接的话则需取【单端的最大值】返回        return max(left, right) + root.val</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个非空二叉树，返回其最大路径和。&lt;/p&gt;
&lt;p&gt;本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: [1,2,3]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  1
 / \
2   3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出: 6&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-maximum-path-sum&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/binary-tree-maximum-path-sum&lt;/a&gt;&lt;br&gt;著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode104-二叉树的最大深度</title>
    <link href="http://peisenli.github.io/2019/08/16/LeetCode104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>http://peisenli.github.io/2019/08/16/LeetCode104-二叉树的最大深度/</id>
    <published>2019-08-16T09:22:45.000Z</published>
    <updated>2019-08-16T09:28:36.792Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。<br>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，  </p><pre><code>  3   / \  9  20    /  \   15   7  </code></pre><p>返回它的最大深度 3 。<br><a id="more"></a><br>python递归实现：</p><pre><code># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def maxDepth(self, root: TreeNode) -&gt; int:        if not root:            return 0        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))# 方法二 迭代class Solution:    &quot;&quot;&quot;    迭代法    &quot;&quot;&quot;    def maxDepth(self, root):        stack = []                                              # 定义一个空栈，栈中的元素是结点及其对应的深度        if root:                                                # 如果根结点不为空            stack.append((root, 1))                             # 则将根节点及其对应深度1组成的元组入栈        max_depth = 0                                           # 初始化最大深度为零        while stack:                                            # 当栈非空时            tree_node, cur_depth = stack.pop()                  # 弹出栈顶结点及其对应的深度            if tree_node:                                       # 如果该结点不为空                max_depth = max(max_depth, cur_depth)           # 更新当前最大深度，如果该结点深度更大的话                stack.append((tree_node.left, cur_depth+1))     # 将该结点的左孩子结点及其对应深度压入栈中                stack.append((tree_node.right, cur_depth+1))    # 将该结点的右孩子结点及其对应深度压入栈中        return max_depth</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉树，找出其最大深度。&lt;br&gt;二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。&lt;br&gt;说明: 叶子节点是指没有子节点的节点。&lt;br&gt;示例：&lt;br&gt;给定二叉树 [3,9,20,null,null,15,7]，  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  3  
 / \  
9  20  
  /  \  
 15   7  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;返回它的最大深度 3 。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode231-2的幂</title>
    <link href="http://peisenli.github.io/2019/08/14/LeetCode231-2%E7%9A%84%E5%B9%82/"/>
    <id>http://peisenli.github.io/2019/08/14/LeetCode231-2的幂/</id>
    <published>2019-08-14T02:54:54.000Z</published>
    <updated>2019-08-14T03:08:09.628Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。<br>示例 1:<br>输入: 1<br>输出: true<br>解释: 20 = 1<br>示例 2:<br>输入: 16<br>输出: true<br>解释: 24 = 16<br>示例 3:<br>输入: 218<br>输出: false<br><a id="more"></a><br>解题思路：<br><strong>1.位运算</strong><br>如果是2的幂，则二进制应该只有最高位上是1，其他都是0；<br>基于上面的结论，n-1应该除了最高位是0（与n最高位对应的位置），其他都是1；<br>因此，n&amp;(n-1) 应该等于0。  </p><pre><code>class Solution:def isPowerOfTwo(self, n: int) -&gt; bool:    if n &gt; 0 and n&amp;(n-1) == 0:        return True    else:        return False</code></pre><p><strong>2.迭代法</strong><br>用此数一直除以2，判断是否整除。</p><pre><code>class Solution:def isPowerOfTwo(self, n: int) -&gt; bool:    if n&lt;=0: return False    while n&gt;1:        if n%2==0:            n /= 2        else:            return False    return True</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数，编写一个函数来判断它是否是 2 的幂次方。&lt;br&gt;示例 1:&lt;br&gt;输入: 1&lt;br&gt;输出: true&lt;br&gt;解释: 20 = 1&lt;br&gt;示例 2:&lt;br&gt;输入: 16&lt;br&gt;输出: true&lt;br&gt;解释: 24 = 16&lt;br&gt;示例 3:&lt;br&gt;输入: 218&lt;br&gt;输出: false&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>图的遍历代码</title>
    <link href="http://peisenli.github.io/2019/08/13/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E4%BB%A3%E7%A0%81/"/>
    <id>http://peisenli.github.io/2019/08/13/图的遍历代码/</id>
    <published>2019-08-13T07:50:03.000Z</published>
    <updated>2019-08-13T07:53:17.212Z</updated>
    
    <content type="html"><![CDATA[<h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>1.准备工作：创建一个visited数组，用来记录已被访问过的顶点；创建一个队列，用来存放每一层的顶点；初始化图G。<br>2.从图中的v0开始访问，将的visited[v0]数组的值设置为true，同时将v0入队。<br>3.只要队列不空，则重复如下操作：<br>(1)队头顶点u出队。<br>(2)依次检查u的所有邻接顶点w，若visited[w]的值为false，则访问w，并将visited[w]置为true，同时将w入队。<br><a id="more"></a><br><strong>用邻接矩阵表示图的广度优先搜索</strong></p><pre><code>/*一些量的定义*/queue&lt;char&gt; q;                //定义一个队列，使用库函数queue#define MVNum 100            //表示最大顶点个数bool visited[MVNum];                //定义一个visited数组，记录已被访问的顶点/*邻接矩阵存储表示*/typedef struct AMGraph{    char vexs[MVNum];            //顶点表    int arcs[MVNum][MVNum];      //邻接矩阵    int vexnum, arcnum;          //当前的顶点数和边数}AMGraph;/*找到顶点v的对应下标*/int LocateVex(AMGraph &amp;G, char v){    int i;    for (i = 0; i &lt; G.vexnum; i++)        if (G.vexs[i] == v)            return i;}/*采用邻接矩阵表示法，创建无向图G*/int CreateUDG_1(AMGraph &amp;G){    int i, j, k;    char v1, v2;    scanf(&quot;%d%d&quot;, &amp;G.vexnum, &amp;G.arcnum);                    //输入总顶点数，总边数    getchar();                               //获取&apos;\n’，防止其对之后的字符输入造成影响    for (i = 0; i &lt; G.vexnum; i++)                    scanf(&quot;%c&quot;, &amp;G.vexs[i]);            //依次输入点的信息    for (i = 0; i &lt; G.vexnum; i++)        for (j = 0; j &lt; G.vexnum; j++)            G.arcs[i][j] = 0;            //初始化邻接矩阵边，0表示顶点i和j之间无边    for (k = 0; k &lt; G.arcnum; k++)    {        getchar();        scanf(&quot;%c%c&quot;, &amp;v1, &amp;v2);            //输入一条边依附的顶点        i = LocateVex(G, v1);                //找到顶点i的下标        j = LocateVex(G, v2);                //找到顶点j的下标        G.arcs[i][j] = G.arcs[j][i] = 1;            //1表示顶点i和j之间有边，无向图不区分方向    }    return 1;}/*采用邻接矩阵表示图的广度优先遍历*/void BFS_AM(AMGraph &amp;G,char v0){    /*从v0元素开始访问图*/    int u,i,v,w;    v = LocateVex(G,v0);                 //找到v0对应的下标    printf(&quot;%c &quot;, v0);                   //打印v0    visited[v] = 1;                         //顶点v0已被访问    q.push(v0);                            //将v0入队    while (!q.empty())    {        u = q.front();                //将队头元素u出队，开始访问u的所有邻接点        v = LocateVex(G, u);            //得到顶点u的对应下标        q.pop();                //将顶点u出队        for (i = 0; i &lt; G.vexnum; i++)        {            w = G.vexs[i];            if (G.arcs[v][i] &amp;&amp; !visited[i])//顶点u和w间有边，且顶点w未被访问            {                printf(&quot;%c &quot;, w);    //打印顶点w                q.push(w);        //将顶点w入队                visited[i] = 1;        //顶点w已被访问            }        }    }}   </code></pre><p><strong>用邻接表表示图的广度优先搜索</strong>  </p><pre><code>/*找到顶点对应的下标*/int LocateVex(ALGraph &amp;G, char v){    int i;    for (i = 0; i &lt; G.vexnum; i++)        if (v == G.vertices[i].data)            return i;}/*邻接表存储表示*/typedef struct ArcNode            //边结点{    int adjvex;        //该边所指向的顶点的位置    ArcNode *nextarc;    //指向下一条边的指针    int info;        //和边相关的信息，如权值}ArcNode;typedef struct VexNode        //表头结点{    char data;                    ArcNode *firstarc;    //指向第一条依附该顶点的边的指针}VexNode,AdjList[MVNum];    //AbjList表示一个表头结点表typedef struct ALGraph{    AdjList vertices;    int vexnum, arcnum;}ALGraph;/*采用邻接表表示法，创建无向图G*/int CreateUDG_2(ALGraph &amp;G){    int i, j, k;    char v1, v2;    scanf(&quot;%d%d&quot;, &amp;G.vexnum, &amp;G.arcnum);            //输入总顶点数，总边数    getchar();    for (i = 0; i &lt; G.vexnum; i++)            //输入各顶点，构造表头结点表    {        scanf(&quot;%c&quot;, &amp;G.vertices[i].data);    //输入顶点值        G.vertices[i].firstarc = NULL;        //初始化每个表头结点的指针域为NULL    }    for (k = 0; k &lt; G.arcnum; k++)            //输入各边，构造邻接表    {        getchar();        scanf(&quot;%c%c&quot;, &amp;v1, &amp;v2);            //输入一条边依附的两个顶点        i = LocateVex(G, v1);                //找到顶点i的下标        j = LocateVex(G, v2);                //找到顶点j的下标        ArcNode *p1 = new ArcNode;            //创建一个边结点*p1        p1-&gt;adjvex = j;                        //其邻接点域为j        p1-&gt;nextarc = G.vertices[i].firstarc; G.vertices[i].firstarc = p1; // 将新结点*p插入到顶点v1的边表头部        ArcNode *p2 = new ArcNode;            //生成另一个对称的新的表结点*p2        p2-&gt;adjvex = i;        p2-&gt;nextarc = G.vertices[j].firstarc;        G.vertices[j].firstarc = p1;    }    return 1;}/*采用邻接表表示图的广度优先遍历*/void BFS_AL(ALGraph &amp;G, char v0){    int u,w,v;    ArcNode *p;    printf(&quot;%c &quot;, v0);                                                //打印顶点v0    v = LocateVex(G, v0);                                                    //找到v0对应的下标    visited[v] = 1;                                                    //顶点v0已被访问    q.push(v0);                                                //将顶点v0入队    while (!q.empty())    {        u = q.front();                                                //将顶点元素u出队，开始访问u的所有邻接点        v = LocateVex(G, u);                                            //得到顶点u的对应下标        q.pop();            //将顶点u出队        for (p = G.vertices[v].firstarc; p; p = p-&gt;nextarc)        //遍历顶点u的邻接点        {            w = p-&gt;adjvex;                if (!visited[w])    //顶点p未被访问            {                printf(&quot;%c &quot;, G.vertices[w].data);            //打印顶点p                visited[w] = 1;                        //顶点p已被访问                q.push(G.vertices[w].data);            //将顶点p入队            }        }    }}</code></pre><hr><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>深度优先搜索类似于树的先序遍历，具体过程如下：<br>创建一个visited数组，用于记录所有被访问过的顶点。<br>1.从图中v0出发，访问v0。<br>2.找出v0的第一个未被访问的邻接点，访问该顶点。以该顶点为新顶点，重复此步骤，直至刚访问过的顶点没有未被访问的邻接点为止。<br>3.返回前一个访问过的仍有未被访问邻接点的顶点，继续访问该顶点的下一个未被访问领接点。<br>4.重复2,3步骤，直至所有顶点均被访问，搜索结束。<br><strong>用邻接矩阵表示图的深度优先搜索</strong></p><pre><code>void DFS_AM(AMGraph &amp;G, int v){    int w;    printf(&quot;%c &quot;, G.vexs[v]);    visited[v] = 1;    for (w = 0; w &lt; G.vexnum; w++)        if (G.arcs[v][w]&amp;&amp;!visited[w]) //递归调用            DFS_AM(G,w);}</code></pre><p><strong>用邻接表表示图的深度优先搜素</strong></p><pre><code>void DFS_AL(ALGraph &amp;G, int v){    int w;    printf(&quot;%c &quot;, G.vertices[v].data);    visited[v] = 1;    ArcNode *p = new ArcNode;    p = G.vertices[v].firstarc;    while (p)    {        w = p-&gt;adjvex;        if (!visited[w]) DFS_AL(G, w);        p = p-&gt;nextarc;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;广度优先搜索&quot;&gt;&lt;a href=&quot;#广度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;广度优先搜索&quot;&gt;&lt;/a&gt;广度优先搜索&lt;/h3&gt;&lt;p&gt;1.准备工作：创建一个visited数组，用来记录已被访问过的顶点；创建一个队列，用来存放每一层的顶点；初始化图G。&lt;br&gt;2.从图中的v0开始访问，将的visited[v0]数组的值设置为true，同时将v0入队。&lt;br&gt;3.只要队列不空，则重复如下操作：&lt;br&gt;(1)队头顶点u出队。&lt;br&gt;(2)依次检查u的所有邻接顶点w，若visited[w]的值为false，则访问w，并将visited[w]置为true，同时将w入队。&lt;br&gt;
    
    </summary>
    
    
      <category term="Data Struct" scheme="http://peisenli.github.io/tags/Data-Struct/"/>
    
  </entry>
  
  <entry>
    <title>图的遍历问题</title>
    <link href="http://peisenli.github.io/2019/08/13/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98/"/>
    <id>http://peisenli.github.io/2019/08/13/图的遍历问题/</id>
    <published>2019-08-13T07:04:08.000Z</published>
    <updated>2019-08-13T07:22:31.705Z</updated>
    
    <content type="html"><![CDATA[<p>图的遍历：从图中某个顶点出发游历图，访遍图中其余顶点，并且使图中的每个顶点仅被访问一次的过程。我们可以设置一个全局型标志数组visited来标志某个顶点是否被访问过，未访问的值为0，访问过的值为1。<br><a id="more"></a></p><h3 id="深度优先搜索遍历"><a href="#深度优先搜索遍历" class="headerlink" title="深度优先搜索遍历"></a>深度优先搜索遍历</h3><p>深度优先搜索遍历类似于树的先序遍历。假定给定图G的初态是所有顶点均未被访问过，在G中任选一个顶点i作为遍历的初始点，则深度优先搜索遍历可定义如下：<br>(1)首先访问顶点i，并将其访问标记置为访问过，即visited[i]=1；<br>(2)然后搜索与顶点i有边相连的下一个顶点j，若j未被访问过，则访问它，并将j的访问标记置为访问过，visited[j]=1，然后从j开始重复此过程，若j已访问，再看与i有边相连的其它顶点；<br>(3)若与i有边相连的顶点都被访问过，则退回到前一个访问顶点并重复刚才过程，直到图中所有顶点都被访问完为止。<br>若图是连通的或强连通的，则从图中某一个顶点出发可以访问到图中所有顶点，否则只能访问到一部分顶点。另外，从刚才写出的遍历结果可以看出，从某一个顶点出发的遍历结果是不唯一的。但是,若我们给定图的存贮结构,则从某一顶点出发的遍历结果应是唯一的。<br><strong>用邻接矩阵实现图的深度优先搜索</strong></p><pre><code>void dfs (int i)          /* 从顶点i 出发遍历*/{       int j;                                                               visit(i);               /*输出访问顶点*/    visited[i]=1;       /*全局数组访问标记置1表示已经访问*/    for(j=1; j&lt;=n; j++)         if((A[i][j]==1)&amp;&amp;(!visited[j]))        dfs(j);        }</code></pre><p>时间复杂度为:O(n2)<br><strong>用邻接表实现图的深度优先搜索</strong></p><pre><code>void  dfs1(int i){      link *p;       visit(head[i]) ;       //输出访问顶点    visted[i]=1;        //全局数组访问标记置为1表示已访问    p=head[i].link;    while (p!=NULL)    {          if(!visited[p-&gt;adjvex]) //如果p指向的邻接点未被访问过            dfs1(p-&gt;adjvex);           p=p-&gt;next;    }}</code></pre><p>而当以邻接表作图的存储结构时，找邻接点所需时间为O(e)，其中e为无向图中边的数或有向图中弧的数。由此，当以邻接表作存储结构时，深度优先搜索遍历图的时间复杂度为O(n＋e)。<br><strong>非连通图的深度优先搜索</strong><br>若图是非连通的或非强连通图，则从图中某一个顶点出发。不能用深度优先搜索访问到图中所有顶点，而只能访问到一个连通子图（既连通分量）或只能访问到一个强连通子图（即强连通分量）。这时，可以在每个连通分量或每个强连通分量中都选一个顶点，进行深度优先搜索遍历，最后将每个连通分量或每个强连通分量的遍历结果合起来，则得到整个非连通图的遍历结果。<br>遍历算法实现与连通图的只有一点不同，即对所有顶点进行循环，反复调用连通图的深度优先搜索遍历算法即可。</p><hr><h3 id="广度优先搜索遍历"><a href="#广度优先搜索遍历" class="headerlink" title="广度优先搜索遍历"></a>广度优先搜索遍历</h3><p>广度优先搜索遍历类似于树的按层次遍历。设图G的初态是所有顶点均未访问，在G 中任选一顶点i作为初始点，则广度优先搜索的基本思想是：<br>(1)首先访问顶点i，并将其访问标志置为已被访问，即visited[i]=1；<br>(2)接着依次访问与顶点i有边相连的所有顶点W1，W2，…，Wt；<br>(3)然后再按顺序访问与W1，W2，…，Wt有边相连又未曾访问过的顶点；<br>依此类推，直到图中所有顶点都被访问完为止 。   </p><pre><code>void bfs(Graph g ,vtx * v）{   visit(v); visited[v]=1; INIQUEUE(Q);ENQUEUE(Q,v); while (!EMPTY(Q)){     DLQUEUE(Q,v); //队头元素出队     w=FIRSTADJ(g,v);        //求v的邻接点    while (w!=0)    {         if(!visited[w])         {             visit(w);             visited[w]=1;                        ENQUEUE(Q,w);         }         w=NEXTADJ(g,v,w);//求下一邻接点     } } }//bfs </code></pre><p><strong>用邻接矩阵实现图的广度优先搜索遍历</strong><br>算法描述如下：</p><pre><code>void  bfs(int  i)      //从顶点i出发遍历{      int  Q[n+1] ;       //Q为队列    int  f,r,j ;        // f,r分别为队列头，尾指针    f=r=0 ;             //设置空队列    visit(v[i]) ;       // 输出访问顶点    visited[i]=1 ;      //全局数组标记置1表示已经访问    r++; q[r]=i ;       //入队列    while (f&lt;r)     {           f++;         i=q[f] ;       //出队列           for (j=1; j&lt;=n; j++)               if ((A[i][j]==1)&amp;&amp;(!visited[j]))            {                  visit(v[j]);                     visited[j]=1;                     r++; q[r]=j;            }    }   }</code></pre><p><strong>用邻接表实现图的广序优先搜索遍历</strong><br>算法描述如下：</p><pre><code>void  BFSl(int i){      int  q[n+1] ;                               //定义队列    int  f,r ;      E_NODE *p ;             //P为搜索指针    f=r=0 ;      visit(head[i]) ;    visited[i]=1; r++; q[r]=i ;                //进队    while (f&lt;r)       {         f++ ; i=q[f] ;    //出队  p=head[i].link ;          while  (p!=NULL)        {               if(!visited[p-&gt;adjvex])                 {                      visit(head[p-&gt;adjvex].vertex;                    visited[p-&gt;adjvex]=1;                       r++;q[r]=p-&gt;adjvex;                 }            p=p-&gt;next;         }    }  }</code></pre><p><strong>非连通图的广度优先搜索</strong><br>若图是非连通的或非强连通图，则从图中某一个顶点出发。不能用广度优先搜索遍历访问到图中所有顶点，而只能访问到一个连通子图（既连通分量）或只能访问到一个强连通子图（既强连通分量）。这时，可以在每个连通分量或每个强连通分量中都选一个顶点，进行广度优先搜索遍历，最后将每个连通分量或每个强连通分量的遍历结果合起来，则得到整个非连通图或非强连通图的广度优先搜索遍历序列。<br>遍历算法实现与连通图的只有一点不同，即对所有顶点进行循环，反复调用连通图的广度优先搜索遍历算法即可。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图的遍历：从图中某个顶点出发游历图，访遍图中其余顶点，并且使图中的每个顶点仅被访问一次的过程。我们可以设置一个全局型标志数组visited来标志某个顶点是否被访问过，未访问的值为0，访问过的值为1。&lt;br&gt;
    
    </summary>
    
    
      <category term="Data Struct" scheme="http://peisenli.github.io/tags/Data-Struct/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode169.求众数</title>
    <link href="http://peisenli.github.io/2019/08/13/LeetCode169-%E6%B1%82%E4%BC%97%E6%95%B0/"/>
    <id>http://peisenli.github.io/2019/08/13/LeetCode169-求众数/</id>
    <published>2019-08-13T03:04:28.000Z</published>
    <updated>2019-08-13T03:34:55.541Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊n/2⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在众数。<br>示例 1:<br>输入: [3,2,3]<br>输出: 3<br>示例 2:<br>输入: [2,2,1,1,1,2,2]<br>输出: 2<br>来源：力扣（LeetCode）<br>解题思路：摩尔投票算法<br>从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，总能找到最多的那个。<br><a id="more"></a><br>python实现：    </p><pre><code>class Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        MostF = nums[0]        count = 1;        for i in range(1,len(nums)):            if MostF == nums[i]:                count += 1            else:                count -=1                if count == 0:                      MostF = nums[i + 1]        return MostF</code></pre><p>Boyer-Moore majority vote algorithm(摩尔投票算法)是一种在线性时间O(n)和空间复杂度的情况下，在一个元素序列中查找包含最多的元素。它是以Robert S.Boyer和J Strother Moore命名的，1981年发明的，是一种典型的流算法(streaming algorithm)。<br>在它最简单的形式就是，查找最多的元素，也就是在输入中重复出现超过一半以上(n/2)的元素。如果序列中没有最多的元素，算法不能检测到正确结果，将输出其中的一个元素之一。<br>当元素重复的次数比较小的时候，对于流算法不能在小于线性空间的情况下查找频率最高的元素。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊n/2⌋ 的元素。&lt;br&gt;你可以假设数组是非空的，并且给定的数组总是存在众数。&lt;br&gt;示例 1:&lt;br&gt;输入: [3,2,3]&lt;br&gt;输出: 3&lt;br&gt;示例 2:&lt;br&gt;输入: [2,2,1,1,1,2,2]&lt;br&gt;输出: 2&lt;br&gt;来源：力扣（LeetCode）&lt;br&gt;解题思路：摩尔投票算法&lt;br&gt;从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，总能找到最多的那个。&lt;br&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://peisenli.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>图的存储结构</title>
    <link href="http://peisenli.github.io/2019/08/13/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
    <id>http://peisenli.github.io/2019/08/13/图的存储结构/</id>
    <published>2019-08-13T02:41:59.000Z</published>
    <updated>2019-08-13T02:48:19.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a><center>图的存储结构</center></h2><p>由于图的结构比较复杂，任意两个顶点之间都可能存在关系，因此无法以数据元素在存储区中的物理位置来表示元素之间关系，即图没有顺序映象的存储结构。<br>另一方面，用多重链表表示图是自然的事，它是一种最简单的链式映象结构，即以一个由一个数据域和多个指针域组成的结点表示图中一个顶点，其中数据域存储该顶点的信息，指针域存储指向其邻接点的指针。  </p><p><center><img src="https://i.loli.net/2019/08/13/YLTV6NISDibzh53.png" alt="多重.jpg"><br>图1 有向图多重链表<br><img src="https://i.loli.net/2019/08/13/MRQzS3pCLbJFoZO.png" alt="表.jpg"><br>图2 无向图的多重链表</center><br>我们一般采用一些改进的方式来存储图，常用的有邻接矩阵、邻接表和十字链表及邻接多重表等。除了要存储图中各个顶点本身的信息外，同时还要存储顶点与顶点之间的所有关系（边的信息）。存储方法的选择，取决于具体的应用。  </p><a id="more"></a><hr><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>在邻接矩阵表示中，除了存放顶点本身信息外，还用一个矩阵表示各个顶点之间的关系。若(i,j)∈E(G)或&lt;i,j&gt;∈E(G),则矩阵中第i行 第j列元素值为1，否则为0 。<br><strong>无向图：  </strong>  </p><p><center><img src="https://i.loli.net/2019/08/13/eo1HNckBwgzQDiM.png" alt="邻阶矩阵.jpg"><br>图3 无向图的邻接矩阵表示</center><br>分析1：无向图的邻接矩阵是对称的；<br>分析2：顶点i 的度＝第 i 行 (列) 中1 的个数；<br>特别：完全图的邻接矩阵中，对角元素为0，其余1。<br>结论：<br>（1）矩阵是对称的，可压缩存储(上(下)三角);<br>（2）第i行或第i 列中1的个数为顶点i 的度;<br>（3）矩阵中1的个数的一半为图中边的数目;<br>（4）很容易判断顶点i和顶点j之间是否有边相连(看矩阵中i行j列值是否为1)。   </p><hr><p><strong>有向图：</strong>  </p><p><center><img src="https://i.loli.net/2019/08/13/jsqWJYnwrG9HM3X.png" alt="1565661031(1).jpg"><br>有向图的邻接矩阵表示</center><br>分析1：有向图的邻接矩阵可能是不对称的。<br>分析2：顶点的出度=第i行元素之和，顶点的入度=第i列元素之和，顶点的度=第i行元素之和+第i列元素之和。<br>结论：<br>（1） 矩阵不一定是对称的;<br>（2） 第i 行中1的个数为顶点i 的出度;<br>（3） 第i列中1的个数为顶点 i的入度;<br>（4） 矩阵中1的个数为图中弧的数目;<br>（5） 很容易判断顶点i 和顶点j 是否有弧相连.<br>邻接矩阵法优点：<br>容易实现图的操作，如：求某顶点的度、判断顶点之间是否有边（弧）、找顶点的邻接点等等。<br>邻接矩阵法缺点：<br>n个顶点需要n*n个单元存储边(弧);空间效率为O(n2)。 对稀疏图而言尤其浪费空间。</p><pre><code>#define INFINITE 9999       /* 假设的无穷大数 */void  creatadj(int n,int e,int t) /*n为顶点数,e为边数,t为1~4,分别表示无向图、有向图、带权无向图、带权有向图*/{      int i,j,k,w;    for(i=1;i&lt;=n;i++)     {          printf(“输入第%d顶点信息”,i);        v[i]=getchar();      }    for(i=1;i&lt;=n;i++)          for(j=1;j&lt;=n;j++)            if(t&gt;2)                 A[i][j]=INFINITE;            else                     A[i][j]=0;      for(k=1;k&lt;=e;k++)     {          scanf(“%d,%d”,&amp;i,&amp;j);         if(i&gt;n ||j&gt;n)  exit(0);         if(t&gt;2)            {                 scanf(“%d”,&amp;w);            A[i][j]=w;               if(t==3) A[j][i]=w;          }        else                 {             A[i][j]=1;            if(t==1)  A[j][i]=1;          }      }} </code></pre><hr><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>图的邻接表存储方法是一种顺序分配与链式分配相结合的存储方法，它包括两部分：一部分是单链表，用来存放边的信息；另一部分是数组，主要用来存放顶点本身的数据信息。<br><strong>有向图：</strong>  </p><p><center><img src="https://i.loli.net/2019/08/13/sz1qmV6A5EdBNKb.png" alt="1565662180(1).jpg"><br>有向图的邻接表表示</center><br>出度：OD(Vi)＝单链出边表中链接的结点数<br>入度：ID(Vi)＝邻接点域为Vi的弧个数<br>结论：<br>（1）第i 个链表中结点数目为顶点i的出度；<br>（2）所有链表中结点数目为图中弧数；<br>（3）占用的存储单元数目为n+e 。<br><strong>无向图：</strong>  </p><p><center><img src="https://i.loli.net/2019/08/13/9MOj6Fop7kiV1qG.png" alt="1565662132(1).jpg"><br>无向图的邻接表表示</center><br>注：邻接表不唯一，因各个边结点的链入顺序是任意的<br>空间效率为O(n+2e)。<br>若是稀疏图(e&lt;&lt;n2)，比邻接矩阵表示法O(n2)省空间。<br>结论：<br>（1）第i 个链表中结点数目为顶点i的度；<br>（2）所有链表中结点数目的一半为图中边数；<br>（3）占用的存储单元数目为n+2e 。<br><strong>邻接表优缺点：</strong><br>优：空间效率高；容易寻找顶点的邻接点；<br>缺：判断两顶点间是否有边或弧，需搜索两结点对应的单链表，没有邻接矩阵方便。<br><strong>与邻接矩阵对比：</strong><br>① 对于任一确定的无向图，邻接矩阵是唯一的（行列号与顶点编号一致），但邻接表不唯一（链接次序与顶点编号无关）。<br>② 邻接矩阵的空间复杂度为O(n2),而邻接表的空间复杂度为O(n+e)。<br>③ 邻接矩阵多用于稠密图；而邻接表多用于稀疏图</p><h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p>C语言实现及定义：<br><img src="https://i.loli.net/2019/08/13/fT7IYKbRoOXiqQN.png" width="250" hegiht="100" align="left">  </p><pre><code>弧结点：typedef  struct  arcnode{       int   tailvex,  headvex;        //弧尾、弧头在表头数组中位置     struct   arcnode   *hlink；//指向弧头相同的下一条弧     struct   arcnode   *tlink;    //指向弧尾相同的下一条弧}AD;    顶点结点：typedef  struct  dnode{       int   data;  //存与顶点有关信息     struct   arcnode   *firstin；//指向以该顶点为弧头的第一个弧结点     struct   arcnode   *firstout; //指向以该顶点为弧尾的第一个弧结点}DD;</code></pre><h3 id="多重链表"><a href="#多重链表" class="headerlink" title="多重链表"></a>多重链表</h3><p>C语言实现及定义：<br><img src="https://i.loli.net/2019/08/13/tEPCrjLlOzBwXY5.png" width="250" hegiht="200" align="left">  </p><pre><code>边结点：typedef   struct  node{       int  mark;   //标志域     int  ivex, jvex;  //该边依附的两个顶点在表头数组中位置     struct  node   *ilink,  *jlink;  //分别指向依附于ivex和jvex的下一条边}JD;顶点结点：typedef   struct  dnode{        int   data;   //存与顶点有关的信息    struct   node  *firstedge;  //指向第一条依附于该顶点的边}DD;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;图的存储结构&quot;&gt;&lt;a href=&quot;#图的存储结构&quot; class=&quot;headerlink&quot; title=&quot;图的存储结构&quot;&gt;&lt;/a&gt;&lt;center&gt;图的存储结构&lt;/center&gt;&lt;/h2&gt;&lt;p&gt;由于图的结构比较复杂，任意两个顶点之间都可能存在关系，因此无法以数据元素在存储区中的物理位置来表示元素之间关系，即图没有顺序映象的存储结构。&lt;br&gt;另一方面，用多重链表表示图是自然的事，它是一种最简单的链式映象结构，即以一个由一个数据域和多个指针域组成的结点表示图中一个顶点，其中数据域存储该顶点的信息，指针域存储指向其邻接点的指针。  &lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src=&quot;https://i.loli.net/2019/08/13/YLTV6NISDibzh53.png&quot; alt=&quot;多重.jpg&quot;&gt;&lt;br&gt;图1 有向图多重链表&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2019/08/13/MRQzS3pCLbJFoZO.png&quot; alt=&quot;表.jpg&quot;&gt;&lt;br&gt;图2 无向图的多重链表&lt;/center&gt;&lt;br&gt;我们一般采用一些改进的方式来存储图，常用的有邻接矩阵、邻接表和十字链表及邻接多重表等。除了要存储图中各个顶点本身的信息外，同时还要存储顶点与顶点之间的所有关系（边的信息）。存储方法的选择，取决于具体的应用。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Data Struct" scheme="http://peisenli.github.io/tags/Data-Struct/"/>
    
  </entry>
  
  <entry>
    <title>图的基本概念</title>
    <link href="http://peisenli.github.io/2019/08/13/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://peisenli.github.io/2019/08/13/图的基本概念/</id>
    <published>2019-08-13T01:28:03.000Z</published>
    <updated>2019-08-13T01:32:16.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="  图的基本概念 "></a><center>  图的基本概念 </center></h2><p><strong>图结构特点：</strong><br>图(Graph)是一种较线性表和树更为复杂的数据结构。在线性表中，数据元素之间仅有线性关系，即每个数据元素只有一个直接前驱和一个直接后继；在树形结构中，数据元素 之间有着明显的层次关系，虽然每一层上的数据元素可能和下一层中多个元素(孩子) 相关，但只能和上一层中一个元素(双亲)相关；而在图形结构中，结点之间 的关系可以是任意的，任意两个数据元素之间都可能相关。   </p><a id="more"></a><hr><p><strong>图的定义：</strong><br>Graph=(V,E)，V：顶点(数据元素)的有穷非空集合；E：边的有穷集合。<br>无向图：每条边都是无方向的<br>有向图：每条边都是有方向的  </p><p><center><img src="https://i.loli.net/2019/08/13/jDrKtBVpOiHXWhY.png" alt="1565658564(1).jpg"></center><br>完全图：任意两个点都有一条边相连。<br>有向完全图边数：n(n-1)<br>无向完全图边数：n(n-1)/2<br>稀疏图：有很少边或弧的图。<br>稠密图：有较多边或弧的图。<br>网：边/弧带权的图。<br>邻接：有边/弧相连的两个顶点之间的关系。存在(vi, vj)，则称vi和vj互为邻接点；存在&lt;vi, vj&gt;，则称vi邻接到vj， vj邻接于vi。<br>关联(依附)：边/弧与顶点之间的关系。存在(vi, vj)/ &lt;vi, vj&gt;， 则称该边/弧关联于vi和vj。<br>顶点的度：与该顶点相关联的边的数目，记为TD(v)<br>在有向图中, 顶点的度等于该顶点的入度与出度之和。<br>顶点 v 的入度是以 v 为终点的有向边的条数, 记作 ID(v)<br>顶点 v 的出度是以 v 为始点的有向边的条数, 记作OD(v)<br>路径：接续的边构成的顶点序列。<br>路径长度：路径上边或弧的数目/权值之和。<br>回路(环)：第一个顶点和最后一个顶点相同的路径。<br>简单路径：除路径起点和终点可以相同外，其余顶点均不相同的路径。<br>简单回路(简单环)：除路径起点和终点相同外，其余顶点均不相同的路径。  </p><p><center><img src="https://i.loli.net/2019/08/13/jACpbBO4NJFxMXz.png" alt="图片1.png"></center><br>在无（有）向图G=( V, E )中，若对任何两个顶点 v、u 都存在从v 到 u 的路径，则称G是连通图（强连通图）。  </p><p><center><img src="https://i.loli.net/2019/08/13/cAGOqHbg9ZmktjD.png" alt="tu.png"></center><br>权与网：图中边或弧所具有的相关数称为权。表明从一个顶点到另一个顶点的距离或耗费。带权的图称为网。<br>子图：设有两个图G=（V，{E}）、G1=（V1，{E1}），若V1  V，E1  E，则称 G1是G的子图。例:(b)、(c) 是 (a) 的子图。  </p><h2 id><a href="#" class="headerlink" title></a><center><img src="https://i.loli.net/2019/08/13/SMVnxFU8oTlirfZ.png" alt="ww.jpg"></center></h2><p>极大连通子图意思是：该子图是 G 连通子图，将G 的任何不在该子图中的顶点加入，子图不再连通。<br>有向图极大强连通子图意思是：该子图是G的强连通子图，将D的任何不在该子图中的顶点加入，子图不再是强连通的。<br>极小连通子图：该子图是G 的连通子图，在该子图中删除任何一条边，子图不再连通。<br>生成树：包含无向图G 所有顶点的极小连通子图。<br>生成森林：对非连通图，由各个连通分量的生成树的集合。        </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;图的基本概念&quot;&gt;&lt;a href=&quot;#图的基本概念&quot; class=&quot;headerlink&quot; title=&quot;  图的基本概念 &quot;&gt;&lt;/a&gt;&lt;center&gt;  图的基本概念 &lt;/center&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;图结构特点：&lt;/strong&gt;&lt;br&gt;图(Graph)是一种较线性表和树更为复杂的数据结构。在线性表中，数据元素之间仅有线性关系，即每个数据元素只有一个直接前驱和一个直接后继；在树形结构中，数据元素 之间有着明显的层次关系，虽然每一层上的数据元素可能和下一层中多个元素(孩子) 相关，但只能和上一层中一个元素(双亲)相关；而在图形结构中，结点之间 的关系可以是任意的，任意两个数据元素之间都可能相关。   &lt;/p&gt;
    
    </summary>
    
    
      <category term="Graph" scheme="http://peisenli.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>位运算-异或</title>
    <link href="http://peisenli.github.io/2019/08/12/%E4%BD%8D%E8%BF%90%E7%AE%97-%E5%BC%82%E6%88%96/"/>
    <id>http://peisenli.github.io/2019/08/12/位运算-异或/</id>
    <published>2019-08-12T03:39:52.000Z</published>
    <updated>2019-08-12T03:54:28.469Z</updated>
    
    <content type="html"><![CDATA[<p><strong>异或</strong>，英文为exclusive OR，缩写成xor<br>异或（xor）是一个数学运算符。它应用于逻辑运算。异或的数学符号  为“⊕”，计算机符号为“xor”。<br>其运算法则为：<br>a⊕b = (¬a ∧ b) ∨ (a ∧¬b)<br>如果a、b两个值不相同，则异或结果为1。<br>如果a、b两个值相同，异或结果为0。<br>异或也叫半加运算，其运算法则相当于不带进位的二进制加法：二进制下用1表示真，0表示假，则异或的运算法则为：<br>0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0（同为0，异为1），这些法则与加法是相同的，只是不带进位，所以异或常被认作不进位加法。<br><a id="more"></a><br><strong>运算法则：</strong>  </p><ol><li>a ⊕ a = 0  </li><li>a ⊕ b = b ⊕ a  </li><li>a ⊕ b ⊕ c = a ⊕ (b ⊕ c) = (a ⊕ b) ⊕ c;  </li><li>d = a ⊕ b ⊕ c 可以推出 a = d ⊕ b ⊕ c.  </li><li><p>a ⊕ b ⊕ a = b.<br>例：若x是二进制数0101，y是二进制数1011；则x⊕y=1110只有在两个比较的位不同时其结果是1，否则结果为0即“两个输入相同时为0，不同则为1。<br><strong>LeetCode136.只出现一次的数字</strong><br>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。<br>说明：<br>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？<br>示例 1:<br>输入: [2,2,1]<br>输出: 1<br>示例 2:<br>输入: [4,1,2,1,2]<br>输出: 4<br><strong>思路</strong>：一开始直接想的进行暴力破解，但是综合时间复杂度上，考虑位运算，异或具有很好的性质，如果相同的两个数异或则为零，零和任何元素异或为元素本身。那么数组种出现的某个单一元素直接就可以找出来。<br>python实现：</p><p> class Solution:</p><pre><code>def singleNumber(self, nums: List[int]) -&gt; int:    res = nums[0]    for i in range(1,len(nums)):        res ^= nums[i]    return res</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;异或&lt;/strong&gt;，英文为exclusive OR，缩写成xor&lt;br&gt;异或（xor）是一个数学运算符。它应用于逻辑运算。异或的数学符号  为“⊕”，计算机符号为“xor”。&lt;br&gt;其运算法则为：&lt;br&gt;a⊕b = (¬a ∧ b) ∨ (a ∧¬b)&lt;br&gt;如果a、b两个值不相同，则异或结果为1。&lt;br&gt;如果a、b两个值相同，异或结果为0。&lt;br&gt;异或也叫半加运算，其运算法则相当于不带进位的二进制加法：二进制下用1表示真，0表示假，则异或的运算法则为：&lt;br&gt;0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0（同为0，异为1），这些法则与加法是相同的，只是不带进位，所以异或常被认作不进位加法。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-求数组的子集</title>
    <link href="http://peisenli.github.io/2019/08/11/LeetCode-%E6%B1%82%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%90%E9%9B%86/"/>
    <id>http://peisenli.github.io/2019/08/11/LeetCode-求数组的子集/</id>
    <published>2019-08-11T06:07:33.000Z</published>
    <updated>2019-08-11T06:19:49.428Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LeetCode78-子集"><a href="#LeetCode78-子集" class="headerlink" title="LeetCode78.子集"></a>LeetCode78.子集</h3><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>说明：解集不能包含重复的子集。<br><a id="more"></a><br>示例:<br>输入: nums = [1,2,3]<br>输出:<br>[[3],[1],[2],[1,2,3],[1,3],[2,3],[1,2],[]]    </p><p>思路：在求取数组子集时，对每个数据元进行遍历后在原有的List上进行追加即可获得元素的子集。<br>python实现：  </p><pre><code>class Solution:def subsets(self, nums: List[int]) -&gt; List[List[int]]:    result = [[]]    nums.sort()    for num in nums:            result += [item+[num] for item in result]    return result</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;LeetCode78-子集&quot;&gt;&lt;a href=&quot;#LeetCode78-子集&quot; class=&quot;headerlink&quot; title=&quot;LeetCode78.子集&quot;&gt;&lt;/a&gt;LeetCode78.子集&lt;/h3&gt;&lt;p&gt;给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。&lt;br&gt;说明：解集不能包含重复的子集。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Sort-list</title>
    <link href="http://peisenli.github.io/2019/08/10/Sort-list/"/>
    <id>http://peisenli.github.io/2019/08/10/Sort-list/</id>
    <published>2019-08-10T12:55:44.000Z</published>
    <updated>2019-08-10T13:10:37.887Z</updated>
    
    <content type="html"><![CDATA[<p>常见的排序算法比较表如下所示：</p><p><center><img src="https://i.loli.net/2019/08/10/7y58PONKUuH2g4e.png" alt="1565437239(1).png"></center></p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。快速排序（Quicksort）是对冒泡排序的一种改进。<br><a id="more"></a></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。<br><strong>LeetCode148:排序链表</strong><br>在 O(nlogn) 时间复杂度和常数级空间复杂度下，对链表进行排序。<br>思考：对于题目要求了复杂度参照上表可使用的算法列表进行实现。  </p><ul><li>找到链表的中间结点  </li><li>递归对左半部分和右半部分排序  </li><li><p>合并排序好的两部分链表<br>python实现归并排序：</p><p>  class Solution: </p><pre><code>def sortList(self, head: ListNode) -&gt; ListNode:     if not head or not head.next: return head     slow, fast = head, head.next     while fast and fast.next:        fast, slow = fast.next.next, slow.next #fast步长为2，slow步长为1，实现中间节点的寻找    mid, slow.next = slow.next, None  #分为Head开头和Mid开头的两个链表     left, right = self.sortList(head), self.sortList(mid)     h = res = ListNode(0)  #中间及结果存储变量    while left and right:  #左右链表序列进行比较排序        if left.val &lt; right.val:             h.next, left = left, left.next         else:             h.next, right = right, right.next         h = h.next     h.next = left if left else right     return res.next</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的排序算法比较表如下所示：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src=&quot;https://i.loli.net/2019/08/10/7y58PONKUuH2g4e.png&quot; alt=&quot;1565437239(1).png&quot;&gt;&lt;/center&gt;&lt;/p&gt;
&lt;h3 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h3&gt;&lt;p&gt;通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。快速排序（Quicksort）是对冒泡排序的一种改进。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Greedy Algorithm</title>
    <link href="http://peisenli.github.io/2019/08/09/Greedy-Algorithm/"/>
    <id>http://peisenli.github.io/2019/08/09/Greedy-Algorithm/</id>
    <published>2019-08-09T07:12:09.000Z</published>
    <updated>2019-08-09T07:13:16.848Z</updated>
    
    <content type="html"><![CDATA[<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。<br>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。<br>贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止。<br><a id="more"></a></p><h3 id="LeetCode122"><a href="#LeetCode122" class="headerlink" title="LeetCode122"></a>LeetCode122</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br>示例 1:<br>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。<br>示例 2:<br>输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br>示例 3:<br>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。<br>算法思想：题目并不要求输出买入和卖出的日期，只要求输出最后受益，所以其实我们并不需要找到极小值和极大值的点，只需要知道它们的差值，而b-a=(b-c)+(c-a)，换句话说，可以通过极大值和极小值之间中间值，通过价格上涨的累加，算出最后的价格差值。<br>Python实现：</p><pre><code>class Solution:def maxProfit(self, prices: List[int]) -&gt; int:    earn=0    if len(prices)&lt;=1:        return earn    for i in range(len(prices)-1):        if prices[i+1]&gt;prices[i]:            earn+=(prices[i+1]-prices[i])    return earn</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;贪心算法&quot;&gt;&lt;a href=&quot;#贪心算法&quot; class=&quot;headerlink&quot; title=&quot;贪心算法&quot;&gt;&lt;/a&gt;贪心算法&lt;/h3&gt;&lt;p&gt;贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。&lt;br&gt;贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。&lt;br&gt;贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode23_sort-K-lists</title>
    <link href="http://peisenli.github.io/2019/08/07/Leetcode23-sort-K-lists/"/>
    <id>http://peisenli.github.io/2019/08/07/Leetcode23-sort-K-lists/</id>
    <published>2019-08-07T07:35:54.000Z</published>
    <updated>2019-08-07T07:41:13.436Z</updated>
    
    <content type="html"><![CDATA[<p><center><strong>堆-合并 k 个排序链表</strong></center><br>LeetCode23-合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。<br>示例：<br>输入:<br>    [<br>          1-&gt;4-&gt;5,<br>          1-&gt;3-&gt;4,<br>          2-&gt;6<br>    ]<br>输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<br>算法思路：利用一个size为K的优先级队列，每次把K个链表的当前头的val塞进优先级队列。  </p><ul><li>首先将list中的每个链表比较首元素，然后依次加入优先队列。  </li><li>然后判断这个优先队列是否为空，不为空，我们弹出队首元素，接着判断这个弹出的元素作为一个链表节点，其后是否还有元素，如果有元素，将元素加入新队列中。 </li></ul><a id="more"></a><p>python3实现：  </p><pre><code># Definition for singly-linked list.  # class ListNode:  #    def __init__(self, x):  #         self.val = x  #         self.next = None  from heapq import *  #python标准库模块堆操作class Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        pq = []      #队列列表        for i in range(len(lists)):            if lists[i]:                heappush(pq, (lists[i].val, i))    #以元组的方式加入堆，（链表Val，ith序列链表）                 lists[i] = lists[i].next #改变每个序列的链表指针        dummy = ListNode(1) #新序列节点        p = dummy          while pq:            val, idx = heappop(pq) #弹出pq堆中的最小值的元素值及index            p.next = ListNode(val) #指针指向下一个Val节点            p = p.next #更新指针节点            #重新以顺序进入链表序列            if lists[idx]:                 heappush(pq, (lists[idx].val, idx))                lists[idx] = lists[idx].next        return dummy.next</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;strong&gt;堆-合并 k 个排序链表&lt;/strong&gt;&lt;/center&gt;&lt;br&gt;LeetCode23-合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。&lt;br&gt;示例：&lt;br&gt;输入:&lt;br&gt;    [&lt;br&gt;          1-&amp;gt;4-&amp;gt;5,&lt;br&gt;          1-&amp;gt;3-&amp;gt;4,&lt;br&gt;          2-&amp;gt;6&lt;br&gt;    ]&lt;br&gt;输出: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6&lt;br&gt;算法思路：利用一个size为K的优先级队列，每次把K个链表的当前头的val塞进优先级队列。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先将list中的每个链表比较首元素，然后依次加入优先队列。  &lt;/li&gt;
&lt;li&gt;然后判断这个优先队列是否为空，不为空，我们弹出队首元素，接着判断这个弹出的元素作为一个链表节点，其后是否还有元素，如果有元素，将元素加入新队列中。 &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://peisenli.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Kth Largest</title>
    <link href="http://peisenli.github.io/2019/08/06/LeetCode-Kth-Largest/"/>
    <id>http://peisenli.github.io/2019/08/06/LeetCode-Kth-Largest/</id>
    <published>2019-08-06T07:21:07.000Z</published>
    <updated>2019-08-06T07:27:39.992Z</updated>
    
    <content type="html"><![CDATA[<p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br>示例 1:<br>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5<br>示例 2:<br>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4<br>说明：你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。<br>思路：对输入示例进行从大到小排序后进行输出第K大的数值即可。<br><a id="more"></a><br>C语言实现：  </p><pre><code>int findKthLargest(int* nums, int numsSize, int k){int i,j,temp;for (i=0;i&lt;numsSize-1;i++){    for(j=i+1;j&lt;numsSize;j++)    {        if(*(nums+i) &lt; *(nums+j))        {            temp = *(nums+i);            *(nums+i) = *(nums+j);            *(nums+j) = temp;        }    }}return *(nums+k-1);}</code></pre><p>python实现：</p><pre><code>class Solution:    def findKthLargest(self, nums: List[int], k: int) -&gt; int:        nums.sort()        return nums[-k]</code></pre><hr><p>堆是一种经过排序的树形数据结构，每个节点都有一个值，通常我们所说的堆的数据结构是指二叉树。所以堆在数据结构中通常可以被看做是一棵树的数组对象。而且堆需要满足一下两个性质：<br>（1）堆中某个节点的值总是不大于或不小于其父节点的值；<br>（2）堆总是一棵完全二叉树。<br>堆分为两种情况，有最大堆和最小堆。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。下图图一就是一个最大堆，图二就是一个最小堆。在一个摆放好元素的最小堆中，可以看到，父结点中的元素一定比子结点的元素要小，但对于左右结点的大小则没有规定谁大谁小。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。&lt;br&gt;示例 1:&lt;br&gt;输入: [3,2,1,5,6,4] 和 k = 2&lt;br&gt;输出: 5&lt;br&gt;示例 2:&lt;br&gt;输入: [3,2,3,1,2,4,5,5,6] 和 k = 4&lt;br&gt;输出: 4&lt;br&gt;说明：你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。&lt;br&gt;思路：对输入示例进行从大到小排序后进行输出第K大的数值即可。&lt;br&gt;
    
    </summary>
    
    
      <category term="Heap" scheme="http://peisenli.github.io/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>vaildparentheses</title>
    <link href="http://peisenli.github.io/2019/08/05/vaildparentheses/"/>
    <id>http://peisenli.github.io/2019/08/05/vaildparentheses/</id>
    <published>2019-08-05T04:23:02.000Z</published>
    <updated>2019-08-05T04:32:44.143Z</updated>
    
    <content type="html"><![CDATA[<p><center><strong>栈在括号匹配中的应用问题</strong></center><br>算法思想：  </p><ul><li>初始设置一个空栈，顺序读入括号  </li><li>若是右括号，则使之置于栈顶的最急迫期待得以消解，或者是不合法的情况（括号序列不匹配，退出程序）  </li><li><p>若是左括号，则作为新的更急迫的期待压入栈中，自然使原有的在栈中的所未消解的期待解决降了一级。算法结束时，栈为空，否则括号序列不匹配。   </p><a id="more"></a><p>Python实现：  </p><p>  class Solution:</p><pre><code>def isValid(self, s: str) -&gt; bool:    temp_str = []       #存放临时开括号    LeftParentheses = [&quot;(&quot;,&quot;[&quot;,&quot;{&quot;]    #左括号查找    vaildParentheses = [&quot;()&quot;,&quot;[]&quot;,&quot;{}&quot;]  #有效括号匹配    for cha in s:        if cha in LeftParentheses:       #如果是左括号就放入temp_str中            temp_str.append(cha)        else:            if not temp_str:             #如果temp_str为空，返回False                return False            else:                temp_cha = temp_str.pop() + cha     #出栈，组合                if temp_cha not in vaildParentheses:                    return False    if not temp_str:                      #判断是栈是否为空        return True    else:        return False</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;strong&gt;栈在括号匹配中的应用问题&lt;/strong&gt;&lt;/center&gt;&lt;br&gt;算法思想：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始设置一个空栈，顺序读入括号  &lt;/li&gt;
&lt;li&gt;若是右括号，则使之置于栈顶的最急迫期待得以消解，或者是不合法的情况（括号序列不匹配，退出程序）  &lt;/li&gt;
&lt;li&gt;&lt;p&gt;若是左括号，则作为新的更急迫的期待压入栈中，自然使原有的在栈中的所未消解的期待解决降了一级。算法结束时，栈为空，否则括号序列不匹配。   &lt;/p&gt;
    
    </summary>
    
    
      <category term="stack" scheme="http://peisenli.github.io/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>Mini-stack</title>
    <link href="http://peisenli.github.io/2019/08/04/Mini-stack/"/>
    <id>http://peisenli.github.io/2019/08/04/Mini-stack/</id>
    <published>2019-08-04T06:03:18.000Z</published>
    <updated>2019-08-04T06:49:04.801Z</updated>
    
    <content type="html"><![CDATA[<p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。<br>push(x) – 将元素 x 推入栈中。<br>pop() – 删除栈顶的元素。<br>top() – 获取栈顶元素。<br>getMin() – 检索栈中的最小元素。<br><a id="more"></a><br>示例:<br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   </p><pre><code>class MinStack(object):    def __init__(self):        &quot;&quot;&quot;        initialize your data structure here.        &quot;&quot;&quot;        self.stack = []                         # 定义一个基本栈，用于存储每个元素        self.min = []                           # 定义一个最小栈，其栈顶元素是当前基本栈中的最小值    def push(self, x):        self.stack.append(x)                    # 把元素压入栈中        if not self.min or x &lt; self.min[-1]:    # 如果最小栈为空或新元素比基本栈的最小值还要小            self.min.append(x)                  # 该元素是目前出现的最小值，压入最小栈        else:                                   # 否则            self.min.append(self.min[-1])       # 将最小栈中的栈顶元素复制一遍压入最小栈    def pop(self):        self.min.pop()                          # 弹出最小栈中的元素，保证两个栈元素个数相同        return self.stack.pop()                 # 弹出基本栈中的元素    def top(self):        return self.stack[-1]                   # 返回基本栈的栈顶元素    def getMin(self):        return self.min[-1]                     # 返回最小栈的栈顶元素</code></pre><p>另一种网上的方法但是运行出现问题：  </p><pre><code>class MinStack:      def __init__(self):        &quot;&quot;&quot;        initialize your data structure here.        &quot;&quot;&quot;        self.stack = []        self.min_list = []        self.min = None         def push(self, x: int):        self.stack.append(x)        if self.min == None or self.min &gt; x:            self.min = x    def pop(self):        popStack = self.stack.pop()        if len(self.stack) == 0:            self.min = None            return popStack        if popStack == self.min:            for i in self.stack: #此处出现问题，出栈后Min的始终没有发生改变。                if i &lt; self.min:                    self.min = i                    print(&quot;i&quot;,i)        return popStack               def top(self) :        return self.stack[-1]    def getMin(self):        print(&quot;Min&quot;,self.min)        return self.min</code></pre><p>运行结果如下所示：<br><img src="https://i.loli.net/2019/08/04/h1iKfALyT5CNJ9P.png" alt="1564898331(1).jpg"><br>对于出栈时存在了一个栈是否被弹出问题，需要进行更正，今天有点事情，之后进行修改。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。&lt;br&gt;push(x) – 将元素 x 推入栈中。&lt;br&gt;pop() – 删除栈顶的元素。&lt;br&gt;top() – 获取栈顶元素。&lt;br&gt;getMin() – 检索栈中的最小元素。&lt;br&gt;
    
    </summary>
    
    
      <category term="Mini-Stack" scheme="http://peisenli.github.io/tags/Mini-Stack/"/>
    
  </entry>
  
</feed>
