<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Paysonly</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://peisenli.github.io/"/>
  <updated>2019-09-18T11:34:27.563Z</updated>
  <id>http://peisenli.github.io/</id>
  
  <author>
    <name>Kong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构-归并排序</title>
    <link href="http://peisenli.github.io/2019/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://peisenli.github.io/2019/09/18/数据结构-归并排序/</id>
    <published>2019-09-18T07:15:04.000Z</published>
    <updated>2019-09-18T11:34:27.563Z</updated>
    
    <content type="html"><![CDATA[<h3 id="归并排序和基数排序"><a href="#归并排序和基数排序" class="headerlink" title="归并排序和基数排序"></a>归并排序和基数排序</h3><p><strong>归并排序</strong>（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><ul><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列  </li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li>重复步骤3直到某一序列的指针达到序列尾</li><li><p>将另一序列剩下的所有元素直接复制到合并序列尾，一次归并结束</p><a id="more"></a><pre><code>int min(int x, int y) {    return x &lt; y ? x : y;}void merge_sort(int arr[], int len) {    int *a = arr;    int *b = (int *) malloc(len * sizeof(int));    int seg, start;    for (seg = 1; seg &lt; len; seg += seg) {        for (start = 0; start &lt; len; start += seg * 2) {            int low = start, mid = min(start + seg, len), high = min(start + seg * 2, len);            int k = low;            int start1 = low, end1 = mid;            int start2 = mid, end2 = high;            while (start1 &lt; end1 &amp;&amp; start2 &lt; end2)                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];            while (start1 &lt; end1)                b[k++] = a[start1++];            while (start2 &lt; end2)                b[k++] = a[start2++];        }        int *temp = a;        a = b;        b = temp;    }    if (a != arr) {        int i;        for (i = 0; i &lt; len; i++)            b[i] = a[i];        b = a;    }    free(b);}  </code></pre><p>是否稳定：true<br>平均时间复杂度：O(nlogn)<br>最差时间复杂度：O(nlogn)<br>最优时间复杂度：O(n)<br>空间复杂度：　　O(n)</p></li></ul><hr><p><strong>基数排序</strong>（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）上的贡献。<br>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。<br>基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。<br>排序过程：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。<br>基数排序法会使用到桶 (Bucket)，顾名思义，通过将要比较的位（个位、十位、百位…），将要排序的元素分配至 0~9 个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其它的比较性排序法<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt="图.jpg"></p><pre><code>#include&lt;stdio.h&gt;#define MAX 20//#define SHOWPASS#define BASE 10void print(int *a, int n) {  int i;  for (i = 0; i &lt; n; i++) {    printf(&quot;%d\t&quot;, a[i]);  }}void radixsort(int *a, int n) {  int i, b[MAX], m = a[0], exp = 1;  for (i = 1; i &lt; n; i++)     {        if (a[i] &gt; m) {          m = a[i];        }      }  while (m / exp &gt; 0) {    int bucket[BASE] = { 0 };    for (i = 0; i &lt; n; i++) {      bucket[(a[i] / exp) % BASE]++;    }    for (i = 1; i &lt; BASE; i++) {      bucket[i] += bucket[i - 1];    }    for (i = n - 1; i &gt;= 0; i--) {      b[--bucket[(a[i] / exp) % BASE]] = a[i];    }    for (i = 0; i &lt; n; i++) {      a[i] = b[i];    }    exp *= BASE;#ifdef SHOWPASS    printf(&quot;\nPASS   : &quot;);    print(a, n);#endif  }}int main() {  int arr[MAX];  int i, n;  printf(&quot;Enter total elements (n &lt;= %d) : &quot;, MAX);  scanf(&quot;%d&quot;, &amp;n);  n = n &lt; MAX ? n : MAX;  printf(&quot;Enter %d Elements : &quot;, n);  for (i = 0; i &lt; n; i++) {    scanf(&quot;%d&quot;, &amp;arr[i]);  }  printf(&quot;\nARRAY  : &quot;);  print(&amp;arr[0], n);  radixsort(&amp;arr[0], n);  printf(&quot;\nSORTED : &quot;);  print(&amp;arr[0], n);  printf(&quot;\n&quot;);  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;归并排序和基数排序&quot;&gt;&lt;a href=&quot;#归并排序和基数排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序和基数排序&quot;&gt;&lt;/a&gt;归并排序和基数排序&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;归并排序&lt;/strong&gt;（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列  &lt;/li&gt;
&lt;li&gt;设定两个指针，最初位置分别为两个已经排序序列的起始位置&lt;/li&gt;
&lt;li&gt;比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置&lt;/li&gt;
&lt;li&gt;重复步骤3直到某一序列的指针达到序列尾&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将另一序列剩下的所有元素直接复制到合并序列尾，一次归并结束&lt;/p&gt;
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://peisenli.github.io/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-选择排序</title>
    <link href="http://peisenli.github.io/2019/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://peisenli.github.io/2019/09/18/数据结构-选择排序/</id>
    <published>2019-09-18T07:13:40.000Z</published>
    <updated>2019-09-18T11:34:08.166Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据结构-选择排序"><a href="#数据结构-选择排序" class="headerlink" title="数据结构-选择排序"></a>数据结构-选择排序</h3><p><strong>选择排序</strong>（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。<br><strong>简单选择排序：</strong><br>该算法的实现思想为：对于具有 n 个记录的无序表遍历 n-1 次，第 i 次从无序表中第 i 个记录开始，找出后序关键字中最小的记录，然后放置在第 i 的位置上。<br>例如对无序表{56，12，80，91，20}采用简单选择排序算法进行排序，具体过程为：<br>第一次遍历时，从下标为 1 的位置即 56 开始，找出关键字值最小的记录 12，同下标为 0 的关键字 56 交换位置：<br>{12，56，80，91，20}<br>第二次遍历时，从下标为 2 的位置即 56 开始，找出最小值 20，同下标为 2 的关键字 56 互换位置：<br>{12，20，80，91，56}<br>第三次遍历时，从下标为 3 的位置即 80 开始，找出最小值 56，同下标为 3 的关键字 80 互换位置：<br>{12，20，56，91，80}<br>第四次遍历时，从下标为 4 的位置即 91 开始，找出最小是 80，同下标为 4 的关键字 91 互换位置：<br>{12，20，56，80，91}<br>到此简单选择排序算法完成，无序表变为有序表。<br><a id="more"></a></p><pre><code>void SelectSort(ElemTypr A[],int n){    for(i=0;i&lt;n-1;i++)    {        min=i;        for(j=i+1;j&lt;n;j++)            if(A[j]&lt;A[min]) min=j;        if(min!=j)            swap(A[i],A[min]);    }}</code></pre><hr><p><strong>堆排序：</strong>若以升序排序说明，把数组转换成最大堆积(Max-Heap Heap)，这是一种满足最大堆积性质(Max-Heap Property)的二叉树：对于除了根之外的每个节点i, A[parent(i)] ≥ A[i]。<br>重复从最大堆积取出数值最大的结点(把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并让残余的堆积维持最大堆积性质。<br>通常堆是通过一维数组来实现的。在数组起始位置为0的情形中：<br>父节点i的左子节点在位置(2i+1);<br>父节点i的右子节点在位置(2i+2);<br>子节点i的父节点在位置floor((i-1)/2);<br>在堆的数据结构中，堆中的最大值总是位于根节点（在优先队列中使用堆的话堆中的最小值位于根节点）。堆中定义以下几种操作：<br>最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点<br>创建最大堆（Build Max Heap）：将堆中的所有数据重新排序<br>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算  </p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void swap(int *a, int *b) {    int temp = *b;    *b = *a;    *a = temp;}void max_heapify(int arr[], int start, int end) {    // 建立父節點指標和子節點指標    int dad = start;    int son = dad * 2 + 1;    while (son &lt;= end) { // 若子節點指標在範圍內才做比較        if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1]) // 先比較兩個子節點大小，選擇最大的            son++;        if (arr[dad] &gt; arr[son]) //如果父節點大於子節點代表調整完畢，直接跳出函數            return;        else { // 否則交換父子內容再繼續子節點和孫節點比较            swap(&amp;arr[dad], &amp;arr[son]);            dad = son;            son = dad * 2 + 1;        }    }}void heap_sort(int arr[], int len) {    int i;    // 初始化，i從最後一個父節點開始調整    for (i = len / 2 - 1; i &gt;= 0; i--)        max_heapify(arr, i, len - 1);    // 先將第一個元素和已排好元素前一位做交換，再重新調整，直到排序完畢    for (i = len - 1; i &gt; 0; i--) {        swap(&amp;arr[0], &amp;arr[i]);        max_heapify(arr, 0, i - 1);    }}int main() {    int arr[] = { 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 };    int len = (int) sizeof(arr) / sizeof(*arr);    heap_sort(arr, len);    int i;    for (i = 0; i &lt; len; i++)        printf(&quot;%d &quot;, arr[i]);    printf(&quot;\n&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据结构-选择排序&quot;&gt;&lt;a href=&quot;#数据结构-选择排序&quot; class=&quot;headerlink&quot; title=&quot;数据结构-选择排序&quot;&gt;&lt;/a&gt;数据结构-选择排序&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;选择排序&lt;/strong&gt;（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。&lt;br&gt;&lt;strong&gt;简单选择排序：&lt;/strong&gt;&lt;br&gt;该算法的实现思想为：对于具有 n 个记录的无序表遍历 n-1 次，第 i 次从无序表中第 i 个记录开始，找出后序关键字中最小的记录，然后放置在第 i 的位置上。&lt;br&gt;例如对无序表{56，12，80，91，20}采用简单选择排序算法进行排序，具体过程为：&lt;br&gt;第一次遍历时，从下标为 1 的位置即 56 开始，找出关键字值最小的记录 12，同下标为 0 的关键字 56 交换位置：&lt;br&gt;{12，56，80，91，20}&lt;br&gt;第二次遍历时，从下标为 2 的位置即 56 开始，找出最小值 20，同下标为 2 的关键字 56 互换位置：&lt;br&gt;{12，20，80，91，56}&lt;br&gt;第三次遍历时，从下标为 3 的位置即 80 开始，找出最小值 56，同下标为 3 的关键字 80 互换位置：&lt;br&gt;{12，20，56，91，80}&lt;br&gt;第四次遍历时，从下标为 4 的位置即 91 开始，找出最小是 80，同下标为 4 的关键字 91 互换位置：&lt;br&gt;{12，20，56，80，91}&lt;br&gt;到此简单选择排序算法完成，无序表变为有序表。&lt;br&gt;
    
    </summary>
    
    
      <category term="Data structure" scheme="http://peisenli.github.io/tags/Data-structure/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-交换排序</title>
    <link href="http://peisenli.github.io/2019/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/"/>
    <id>http://peisenli.github.io/2019/09/18/数据结构-交换排序/</id>
    <published>2019-09-18T07:11:58.000Z</published>
    <updated>2019-09-18T11:33:55.299Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据结构-交换排序"><a href="#数据结构-交换排序" class="headerlink" title="数据结构-交换排序"></a>数据结构-交换排序</h3><p>所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，交换排序的特点是：将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。<br><strong>冒泡排序（Bubble Sort）</strong>是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。<br>冒泡排序对n个项目需要O(n^2)的比较次数，且可以原地排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于包含大量的元素的数列排序是很没有效率的。<br>冒泡排序是与插入排序拥有相等的运行时间，但是两种算法在需要的交换次数却很大地不同。在最坏的情况，冒泡排序需要 O(n^2)次交换，而插入排序只要最多O(n)交换。冒泡排序的实现（类似下面）通常会对已经排序好的数列拙劣地运行O(n^2)，而插入排序在这个例子只需要O(n)个运算。因此很多现代的算法教科书避免使用冒泡排序，而用插入排序取代之。冒泡排序如果能在内部循环第一次运行时，使用一个旗标来表示有无需要交换的可能，也可以把最优情况下的复杂度降低到O(n)。在这个情况，已经排序好的数列就无交换的需要。若在每次走访数列时，把走访顺序反过来，也可以稍微地改进效率。有时候称为鸡尾酒排序，因为算法会从数列的一端到另一端之间穿梭往返。<br>冒泡排序算法的运作如下：  </p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><a id="more"></a><pre><code>#include &lt;stdio.h&gt;//交换 a 和 b 的位置的函数void swap(int *a, int *b);int main(){    int array[8] = {49,38,65,97,76,13,27,49};    int i, j;    int key;    //有多少记录，就需要多少次冒泡，当比较过程，所有记录都按照升序排列时，排序结束    for (i = 0; i &lt; 8; i++){        key=0;//每次开始冒泡前，初始化 key 值为 0        //每次起泡从下标为 0 开始，到 8-i 结束        for (j = 0; j+1&lt;8-i; j++){            if (array[j] &gt; array[j+1]){                key=1;                swap(&amp;array[j], &amp;array[j+1]);            }        }        //如果 key 值为 0，表明表中记录排序完成        if (key==0) {            break;        }    }    for (i = 0; i &lt; 8; i++){        printf(&quot;%d &quot;, array[i]);    }    return 0;}void swap(int *a, int *b){    int temp;    temp = *a;    *a = *b;    *b = temp;}</code></pre><p>时间复杂度：O(n^2)<br>空间复杂度：O(1)<br>稳定：是</p></li></ul><hr><p><strong>快速排序</strong>使用分治法（Divide and conquer）策略来把一个序列（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。<br>步骤为：  </p><ul><li>挑选基准值：从数列中挑出一个元素，称为“基准”（pivot）</li><li>分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成  </li><li>递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。</li><li><p>递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。</p><pre><code>void quicksort(int left, int right) {    int i, j, t, temp;    if(left &gt; right)        return;    temp = a[left]; //temp中存的就是基准数    i = left;    j = right;    while(i != j) { //顺序很重要，要先从右边开始找        while(a[j] &gt;= temp &amp;&amp; i &lt; j)            j--;        while(a[i] &lt;= temp &amp;&amp; i &lt; j)//再找右边的            i++;               if(i &lt; j)//交换两个数在数组中的位置        {            t = a[i];            a[i] = a[j];            a[j] = t;        }    }    //最终将基准数归位    a[left] = a[i];    a[i] = temp;    quicksort(left, i-1);//继续处理左边的，这里是一个递归的过程    quicksort(i+1, right);//继续处理右边的 ，这里是一个递归的过程}</code></pre><p>时间复杂度：O(logn)<br>空间复杂度：O(nlogn)<br>稳定：否</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据结构-交换排序&quot;&gt;&lt;a href=&quot;#数据结构-交换排序&quot; class=&quot;headerlink&quot; title=&quot;数据结构-交换排序&quot;&gt;&lt;/a&gt;数据结构-交换排序&lt;/h3&gt;&lt;p&gt;所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，交换排序的特点是：将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。&lt;br&gt;&lt;strong&gt;冒泡排序（Bubble Sort）&lt;/strong&gt;是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。&lt;br&gt;冒泡排序对n个项目需要O(n^2)的比较次数，且可以原地排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于包含大量的元素的数列排序是很没有效率的。&lt;br&gt;冒泡排序是与插入排序拥有相等的运行时间，但是两种算法在需要的交换次数却很大地不同。在最坏的情况，冒泡排序需要 O(n^2)次交换，而插入排序只要最多O(n)交换。冒泡排序的实现（类似下面）通常会对已经排序好的数列拙劣地运行O(n^2)，而插入排序在这个例子只需要O(n)个运算。因此很多现代的算法教科书避免使用冒泡排序，而用插入排序取代之。冒泡排序如果能在内部循环第一次运行时，使用一个旗标来表示有无需要交换的可能，也可以把最优情况下的复杂度降低到O(n)。在这个情况，已经排序好的数列就无交换的需要。若在每次走访数列时，把走访顺序反过来，也可以稍微地改进效率。有时候称为鸡尾酒排序，因为算法会从数列的一端到另一端之间穿梭往返。&lt;br&gt;冒泡排序算法的运作如下：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比较相邻的元素。如果第一个比第二个大，就交换他们两个。&lt;/li&gt;
&lt;li&gt;对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。&lt;/li&gt;
&lt;li&gt;针对所有的元素重复以上的步骤，除了最后一个。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Data structure" scheme="http://peisenli.github.io/tags/Data-structure/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-插入排序</title>
    <link href="http://peisenli.github.io/2019/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://peisenli.github.io/2019/09/18/数据结构-插入排序/</id>
    <published>2019-09-18T03:12:51.000Z</published>
    <updated>2019-09-18T05:53:21.671Z</updated>
    
    <content type="html"><![CDATA[<p><strong>插入排序</strong>（Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用inplace排序（即只需用到 O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。<br><strong>直接插入排序：</strong>    </p><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li><p>重复步骤2~5  </p><pre><code>void Insertionsort(int arr[], int len){        int i,j,key;        for (i=1;i&lt;len;i++){                key = arr[i];                j=i-1;                while((j&gt;=0) &amp;&amp; (arr[j]&gt;key)) {                        arr[j+1] = arr[j];                        j--;                }                arr[j+1] = key;        }}</code></pre><p>时间复杂度：O(n^2)<br>空间复杂度：O(1)<br>稳定：是<br>适用：顺序存储和链式存储的线性表  </p><a id="more"></a></li></ol><hr><p><strong>折半插入排序：</strong><br>折半插入排序（binary insertion sort）是对插入排序算法的一种改进，由于排序算法过程中，就是不断的依次将元素插入前面已排好序的序列中。由于前半部分为已排好序的数列，这样我们不用按顺序依次寻找插入点，可以采用折半查找的方法来加快寻找插入点的速度。<br>（1） 将一新的元素插入到有序数组中，寻找插入点时，将带插区域的首元素设置为a[low],末元素设置为a[high],比较时则将待插元素与参考元素a[m]（m=(low+high)/2）相比较。；<br>（2）如果待插元素比参考元素小，则选择a[low]到a[m-1]为新的插入区域（即high=m-1）,否则选择a[m+1]到a[high]为插入区域；<br>（3）如此直到low&lt;=high不成立，即将此位置(low)之后所有元素后移一位，并将新元素插入a[high+1]中。  </p><pre><code>void BInsertSort(int a[],int size){    int i,j,low = 0,high = 0,mid;    int temp = 0;    for (i=1; i&lt;size; i++) {        low=0;        high=i-1;        temp=a[i];        //采用折半查找法判断插入位置，最终变量 low 表示插入位置        while (low&lt;=high) {            mid=(low+high)/2;            if (a[mid]&gt;temp) {                high=mid-1;            }            else{                low=mid+1;            }        }        //有序表中插入位置后的元素统一后移        for (j=i; j&gt;low; j--) {            a[j]=a[j-1];        }        a[low]=temp;//插入元素    }}</code></pre><p>时间复杂度：O(n^2)  </p><hr><p><strong>希尔排序：</strong><br>希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。<br>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。<br>步长取值：d1=n/2 di+1=di/2<br><img src="https://i.loli.net/2019/09/18/QfVThLPImHFqrpE.png" alt="1024555_20161128110416068_1421707828.png">    </p><pre><code>void shell_sort(int arr[], int len) {    int gap, i, j;    int temp;    for (gap = len &gt;&gt; 1; gap &gt; 0; gap &gt;&gt;= 1)        for (i = gap; i &lt; len; i++) {            temp = arr[i];            for (j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap)                arr[j + gap] = arr[j];            arr[j + gap] = temp;        }}</code></pre><p>时间复杂度： O(n^(1.3—2))<br>空间复杂度： O(1)<br>稳定性： 不稳定  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;插入排序&lt;/strong&gt;（Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用inplace排序（即只需用到 O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。&lt;br&gt;&lt;strong&gt;直接插入排序：&lt;/strong&gt;    &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从第一个元素开始，该元素可以认为已经被排序&lt;/li&gt;
&lt;li&gt;取出下一个元素，在已经排序的元素序列中从后向前扫描&lt;/li&gt;
&lt;li&gt;如果该元素（已排序）大于新元素，将该元素移到下一位置&lt;/li&gt;
&lt;li&gt;重复步骤3，直到找到已排序的元素小于或者等于新元素的位置&lt;/li&gt;
&lt;li&gt;将新元素插入到该位置后&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重复步骤2~5  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void Insertionsort(int arr[], int len){
        int i,j,key;
        for (i=1;i&amp;lt;len;i++){
                key = arr[i];
                j=i-1;
                while((j&amp;gt;=0) &amp;amp;&amp;amp; (arr[j]&amp;gt;key)) {
                        arr[j+1] = arr[j];
                        j--;
                }
                arr[j+1] = key;
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;时间复杂度：O(n^2)&lt;br&gt;空间复杂度：O(1)&lt;br&gt;稳定：是&lt;br&gt;适用：顺序存储和链式存储的线性表  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Data struct" scheme="http://peisenli.github.io/tags/Data-struct/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode121-买卖股票最佳的时期</title>
    <link href="http://peisenli.github.io/2019/09/11/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E7%9A%84%E6%97%B6%E6%9C%9F/"/>
    <id>http://peisenli.github.io/2019/09/11/LeetCode121-买卖股票最佳的时期/</id>
    <published>2019-09-11T14:12:13.000Z</published>
    <updated>2019-09-11T14:22:45.517Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。<br>注意你不能在买入股票前卖出股票。<br>示例 1:<br>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。<br>示例 2:<br>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。<br>思路：<br>题意要求先买在卖，找到利润最大的卖卖方案。<br>按时间顺序，从前到后遍历股票价格数组prices，每次迭代做两件事：<br>统计直至目前的最低成本cost，因为今日卖出的利润等于今日price减去前几日的price最小值（即最小成本）；<br>计算直至目前的最高利润profit 。<br>最终，返回最高利润profit。<br><a id="more"></a></p><pre><code>class Solution(object):    def maxProfit(self, prices):        &quot;&quot;&quot;        :type prices: List[int]        :rtype: int        &quot;&quot;&quot;        minprice = float(&apos;Inf&apos;)  #初始化最小值        maxprofit = 0        for  i in range(len(prices)):            if (prices[i] &lt; minprice):  #找出最小值                minprice = prices[i]            elif (prices[i] - minprice &gt; maxprofit): #寻找利润最大点                maxprofit = prices[i] - minprice                return maxprofit;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;br&gt;如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。&lt;br&gt;注意你不能在买入股票前卖出股票。&lt;br&gt;示例 1:&lt;br&gt;输入: [7,1,5,3,6,4]&lt;br&gt;输出: 5&lt;br&gt;解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。&lt;br&gt;注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。&lt;br&gt;示例 2:&lt;br&gt;输入: [7,6,4,3,1]&lt;br&gt;输出: 0&lt;br&gt;解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。&lt;br&gt;思路：&lt;br&gt;题意要求先买在卖，找到利润最大的卖卖方案。&lt;br&gt;按时间顺序，从前到后遍历股票价格数组prices，每次迭代做两件事：&lt;br&gt;统计直至目前的最低成本cost，因为今日卖出的利润等于今日price减去前几日的price最小值（即最小成本）；&lt;br&gt;计算直至目前的最高利润profit 。&lt;br&gt;最终，返回最高利润profit。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode88-合并两个有序数组</title>
    <link href="http://peisenli.github.io/2019/09/10/LeetCode88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://peisenli.github.io/2019/09/10/LeetCode88-合并两个有序数组/</id>
    <published>2019-09-10T11:39:09.000Z</published>
    <updated>2019-09-10T11:48:04.880Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。<br>说明:<br>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>示例:<br>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3<br>输出: [1,2,2,3,5,6]<br>思路一：追加后使用sort排序</p><pre><code>class Solution(object):    def merge(self, nums1, m, nums2, n):        nums1[m:] = nums2        return nums1.sort()</code></pre><a id="more"></a><p>思路二：从有序数组尾部进行比较，然后在长数组尾部进行写入，注意问题：数组越界及元素个数为0的数组</p><pre><code>class Solution(object):    def merge(self, nums1, m, nums2, n):        &quot;&quot;&quot;        :type nums1: List[int]        :type m: int        :type nums2: List[int]        :type n: int        :rtype: None Do not return anything, modify nums1 in-place instead.        &quot;&quot;&quot;        p1 = m - 1        p2 = n - 1        # set pointer for nums1        p = m + n - 1        # while there are still elements to compare        while p1 &gt;= 0 and p2 &gt;= 0:            if nums1[p1] &lt; nums2[p2]:                nums1[p] = nums2[p2]                p2 -= 1            else:                nums1[p] =  nums1[p1]                p1 -= 1            p -= 1                # add missing elements from nums2        nums1[:p2 + 1] = nums2[:p2 + 1]</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。&lt;br&gt;说明:&lt;br&gt;初始化 nums1 和 nums2 的元素数量分别为 m 和 n。&lt;br&gt;你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。&lt;br&gt;示例:&lt;br&gt;输入:&lt;br&gt;nums1 = [1,2,3,0,0,0], m = 3&lt;br&gt;nums2 = [2,5,6],       n = 3&lt;br&gt;输出: [1,2,2,3,5,6]&lt;br&gt;思路一：追加后使用sort排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution(object):
    def merge(self, nums1, m, nums2, n):
        nums1[m:] = nums2
        return nums1.sort()
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode62-不同路径</title>
    <link href="http://peisenli.github.io/2019/09/09/LeetCode62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>http://peisenli.github.io/2019/09/09/LeetCode62-不同路径/</id>
    <published>2019-09-09T12:48:47.000Z</published>
    <updated>2019-09-09T12:52:15.737Z</updated>
    
    <content type="html"><![CDATA[<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png" alt><br>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><p>说明：m 和 n 的值均不超过 100。</p><p>示例 1:</p><p>输入: m = 3, n = 2<br>输出: 3<br>解释:<br>从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li>向右 -&gt; 向右 -&gt; 向下</li><li>向右 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向右<br>示例 2:</li></ol><p>输入: m = 7, n = 3<br>输出: 28<br><a id="more"></a><br>思路：由已知的m和n可以求出初始位置[0][0]到每个位置的[m][n]二维数组任意一个位置的解法种类,同时最后一个位置的值也是答案;  </p><pre><code>class Solution(object):    def uniquePaths(self, m, n):        &quot;&quot;&quot;        :type m: int        :type n: int        :rtype: int        &quot;&quot;&quot;        dp = [[1]*n] + [[1]+[0] * (n-1) for _ in range(m-1)]        #print(dp)        for i in range(1, m):            for j in range(1, n):                dp[i][j] = dp[i-1][j] + dp[i][j-1]        return dp[-1][-1]</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。&lt;/p&gt;
&lt;p&gt;问总共有多少条不同的路径？&lt;br&gt;&lt;img src=&quot;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png&quot; alt&gt;&lt;br&gt;例如，上图是一个7 x 3 的网格。有多少可能的路径？&lt;/p&gt;
&lt;p&gt;说明：m 和 n 的值均不超过 100。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: m = 3, n = 2&lt;br&gt;输出: 3&lt;br&gt;解释:&lt;br&gt;从左上角开始，总共有 3 条路径可以到达右下角。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;向右 -&amp;gt; 向右 -&amp;gt; 向下&lt;/li&gt;
&lt;li&gt;向右 -&amp;gt; 向下 -&amp;gt; 向右&lt;/li&gt;
&lt;li&gt;向下 -&amp;gt; 向右 -&amp;gt; 向右&lt;br&gt;示例 2:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;输入: m = 7, n = 3&lt;br&gt;输出: 28&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode59-旋转矩阵②</title>
    <link href="http://peisenli.github.io/2019/09/07/LeetCode59-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%E2%91%A1/"/>
    <id>http://peisenli.github.io/2019/09/07/LeetCode59-旋转矩阵②/</id>
    <published>2019-09-07T12:22:51.000Z</published>
    <updated>2019-09-09T12:52:53.154Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。<br>示例:<br>输入: 3<br>输出:<br>[<br> [ 1, 2, 3 ],<br> [ 8, 9, 4 ],<br> [ 7, 6, 5 ]<br>]<br><a id="more"></a><br>还是模拟过程,控制好边界<br>行的上下边界, 列的左右边界!即可<br>时间复杂度: O(n^2)</p><pre><code>class Solution:    def generateMatrix(self, n: int) -&gt; List[List[int]]:        above_row = 0        below_row = n - 1        left_col = 0        right_col = n - 1        res = [ [0] * n for _ in range(n) ]        num = 1        while above_row &lt;= below_row and left_col &lt;= right_col:            # 从左到右            for i in range(left_col, right_col+1):                res[above_row][i] = num                num += 1            # 上行加1            above_row += 1            # 从上到下            for i in range(above_row, below_row+1):                res[i][right_col] = num                num += 1            right_col -= 1            # 从右到左            for i in range(right_col, left_col-1, -1):                res[below_row][i] = num                num += 1            below_row -= 1            #从下到上            for i in range(below_row, above_row-1, -1):                res[i][left_col] = num                num += 1            left_col += 1        return res</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。&lt;br&gt;示例:&lt;br&gt;输入: 3&lt;br&gt;输出:&lt;br&gt;[&lt;br&gt; [ 1, 2, 3 ],&lt;br&gt; [ 8, 9, 4 ],&lt;br&gt; [ 7, 6, 5 ]&lt;br&gt;]&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode54-旋转矩阵</title>
    <link href="http://peisenli.github.io/2019/09/07/LeetCode54-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/"/>
    <id>http://peisenli.github.io/2019/09/07/LeetCode54-旋转矩阵/</id>
    <published>2019-09-07T11:15:25.000Z</published>
    <updated>2019-09-09T12:21:00.967Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。<br>示例 1:<br>输入:<br>[<br> [ 1, 2, 3 ],<br> [ 4, 5, 6 ],<br> [ 7, 8, 9 ]<br>]<br>输出: [1,2,3,6,9,8,7,4,5]<br>示例 2:<br>输入:<br>[<br>  [1, 2, 3, 4],<br>  [5, 6, 7, 8],<br>  [9,10,11,12]<br>]<br>输出: [1,2,3,4,8,12,11,10,9,5,6,7]<br><a id="more"></a><br>思路：每次取数组的第一行添加到列表中后将数组进行逆时针旋转，进行迭代操作。</p><pre><code>class Solution(object):    def spiralOrder(self, matrix):        &quot;&quot;&quot;        :type matrix: List[List[int]]        :rtype: List[int]        &quot;&quot;&quot;        # 取首行，去除首行后，对矩阵翻转来创建新的矩阵，        # 再递归直到新矩阵为[],退出并将取到的数据返回        ret = []        if matrix == []:            return ret        ret.extend(matrix[0]) # 上侧\#        print(ret)        new = [reversed(i) for i in matrix[1:]] #反转迭代器        if new == []:            return ret        r = self.spiralOrder([i for i in zip(*new)])        ret.extend(r)        return ret</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。&lt;br&gt;示例 1:&lt;br&gt;输入:&lt;br&gt;[&lt;br&gt; [ 1, 2, 3 ],&lt;br&gt; [ 4, 5, 6 ],&lt;br&gt; [ 7, 8, 9 ]&lt;br&gt;]&lt;br&gt;输出: [1,2,3,6,9,8,7,4,5]&lt;br&gt;示例 2:&lt;br&gt;输入:&lt;br&gt;[&lt;br&gt;  [1, 2, 3, 4],&lt;br&gt;  [5, 6, 7, 8],&lt;br&gt;  [9,10,11,12]&lt;br&gt;]&lt;br&gt;输出: [1,2,3,4,8,12,11,10,9,5,6,7]&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode33-搜索旋转排序数组</title>
    <link href="http://peisenli.github.io/2019/09/06/LeetCode33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://peisenli.github.io/2019/09/06/LeetCode33-搜索旋转排序数组/</id>
    <published>2019-09-06T11:05:35.000Z</published>
    <updated>2019-09-09T11:10:26.484Z</updated>
    
    <content type="html"><![CDATA[<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。<br>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。<br>你可以假设数组中不存在重复的元素。<br>你的算法时间复杂度必须是 O(log n) 级别。<br>示例 1:<br>输入: nums = [4,5,6,7,0,1,2], target = 0<br>输出: 4<br>示例 2:<br>输入: nums = [4,5,6,7,0,1,2], target = 3<br>输出: -1<br><a id="more"></a><br>Python代码<br>偷懒版本：  </p><pre><code>class Solution(object):    def search(self, nums, target):        &quot;&quot;&quot;        :type nums: List[int]        :type target: int        :rtype: int        &quot;&quot;&quot;        if target in nums:            return nums.index(target)        return -1</code></pre><p>思路：二分查找<br>1、中间元素和“左边界”、“右边界”比较；<br>2、中间元素选择“靠左的中间元素”、“靠右的中间元素”。  </p><pre><code>class Solution(object):    def search(self, nums, target):        &quot;&quot;&quot;        :type nums: List[int]        :type target: int        :rtype: int        &quot;&quot;&quot;        if not nums:            return -1        n = len(nums)        l, r = 0, len(nums) - 1        while l &lt;= r:            m = (l + r) // 2            if nums[m] == target:                return m            elif nums[l] &lt;= nums[m]:                if nums[l] &lt;= target &lt;= nums[m]:                    r = m                else:                    l = m + 1            else:                if nums[m] &lt;= target &lt;= nums[r]:                    l = m                else:                    r = m - 1        return -1</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;br&gt;( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。&lt;br&gt;搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。&lt;br&gt;你可以假设数组中不存在重复的元素。&lt;br&gt;你的算法时间复杂度必须是 O(log n) 级别。&lt;br&gt;示例 1:&lt;br&gt;输入: nums = [4,5,6,7,0,1,2], target = 0&lt;br&gt;输出: 4&lt;br&gt;示例 2:&lt;br&gt;输入: nums = [4,5,6,7,0,1,2], target = 3&lt;br&gt;输出: -1&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-静态表查找</title>
    <link href="http://peisenli.github.io/2019/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%99%E6%80%81%E8%A1%A8%E6%9F%A5%E6%89%BE/"/>
    <id>http://peisenli.github.io/2019/09/06/数据结构-静态表查找/</id>
    <published>2019-09-06T06:19:06.000Z</published>
    <updated>2019-09-06T06:20:09.392Z</updated>
    
    <content type="html"><![CDATA[<p>###静态表查找</p><ol><li><p>顺序查找<br>核心：从数据的第一个元素开始，依次比较，直到找到目标数据或查找失败。  </p><ul><li>从表中的第一个元素开始，依次与关键字比较           </li><li>若某个元素匹配关键字，则 查找成功。</li><li><p>若查找到最后一个元素还未匹配关键字，则 查找失败。<br>特点：顺序查找平均关键字匹配次数为表长的一半，其时间复杂度为O(n),顺序查找的优点是对表无要求，插入数据可在O(1)内完成。缺点是时间复杂度较大，数据规模较大时，效率较低。  </p><a id="more"></a><p>实例代码：</p><pre><code>#include&lt;iostream&gt;using namespace std;struct LNode {    int Element[100];    int Length; };int SequentialSearch(LNode *Tbl, int K){       int i;    Tbl -&gt; Element[0] = K;    for(i = Tbl-&gt;Length; Tbl-&gt;Element[i] != K; i--);    return i;}int main(){    LNode test = { {0,1,2,3,4,5,6,7,8,9}, 9};//待比较数据从第二个开始，第一个位置用来设置哨兵     int result, num = 8;    result = SequentialSearch(&amp;test, num);    if(result == 0)        cout&lt;&lt;&quot;没找到！&quot;&lt;&lt;endl;    else        cout&lt;&lt;&quot;在m[&quot;&lt;&lt;result&lt;&lt;&quot;]里找到&quot;&lt;&lt;num-2 &lt;&lt;endl;    system(&quot;pause&quot;);    return 0;}</code></pre></li></ul></li><li><p>折半查找<br>仅适用有序表<br>首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。  </p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define keyType inttypedef struct {    keyType key;//查找表中每个数据元素的值    //如果需要，还可以添加其他属性}ElemType;typedef struct{    ElemType *elem;//存放查找表中数据元素的数组    int length;//记录查找表中数据的总数量}SSTable;//创建查找表void Create(SSTable **st,int length){    (*st)=(SSTable*)malloc(sizeof(SSTable));    (*st)-&gt;length=length;    printf(&quot;输入表中的数据元素：\n&quot;);    //根据查找表中数据元素的总长度，在存储时，从数组下标为 1 的空间开始存储数据    for (int i=1; i&lt;=length; i++) {        scanf(&quot;%d&quot;,&amp;((*st)-&gt;elem[i].key));    }}int Search_Bin(SSTable *ST,keyType key){    int low=1;//初始状态 low 指针指向第一个关键字    int high=ST-&gt;length;//high 指向最后一个关键字    int mid;    while (low&lt;=high) {        mid=(low+high)/2;//int 本身为整形，所以，mid 每次为取整的整数        if (ST-&gt;elem[mid].key==key)//如果 mid 指向的同要查找的相等，返回 mid 所指向的位置        {            return mid;        }else if(ST-&gt;elem[mid].key&gt;key)//如果mid指向的关键字较大，则更新 high 指针的位置        {            high=mid-1;        }        //反之，则更新 low 指针的位置        else{            low=mid+1;        }    }    return 0;}int main(int argc, const char * argv[]) {    SSTable *st;    Create(&amp;st, 11);    getchar();    printf(&quot;请输入查找数据的关键字：\n&quot;);    int key;    scanf(&quot;%d&quot;,&amp;key);    int location=Search_Bin(st, key);    //如果返回值为 0，则证明查找表中未查到 key 值，    if (location==0) {        printf(&quot;查找表中无该元素&quot;);    }else{        printf(&quot;数据在查找表中的位置为：%d&quot;,location);    }    return 0;}</code></pre><p>折半查找过程可用二叉树描述：结点表示记录，其值为该记录在表中位置，比较一次的作为根，比较两次放在第二层，依次类推，得到的二叉树称为判定树。<br>n个元素表的折半查找判定树是唯一的，即：判定树由表中元素个数决定。<br>找到表中任一记录的过程就是走了一条从根结点到与该记录相应的结点的路径。<br>比较的关键字个数：该结点在判定树上的层次数。<br>⑴ 当n=0时，折半查找判定树为空；<br>⑵ 当n＞0时，折半查找判定树的根结点是有序表中序号为mid=(n+1)/2的记录，根结点的左子树是与有序表r[1] ~ r[mid-1]相对应的折半查找判定树，根结点的右子树是与r[mid+1] ~ r[n]相对应的折半查找判定树。<br>查找成功：在表中查找任一记录的过程，即是折半查找判定树中从根结点到该记录结点的路径，和给定值的比较次数等于该记录结点在树中的层数。<br>查找不成功：查找失败的过程就是走了一条从根结点到外部结点的路径，和给定值进行的关键码的比较次数等于该路径上内部结点的个数。  </p></li><li><p>分块查找<br>分块查找又称索引顺序查找。这种查找方法中除了表本身以外尚需建立一个索引表。<br>索引表的构造过程：<br>要查找的表分成几个子表(称为块)。对每个子表建立一个索引项，其中包括两项内容：关键字项（存放该块中最大的关键字 ）指针项（存放该块中第一个记录的地址）。索引表中关键字递增有序，表中记录可以有序，也可以无序。但块之间一定有序（即后一块中的最小关键字都大于前一块中的最大关键字）。<br>查找表构成：<br>让数据分块有序，即分成若干子表（块），要求每个子表（块）中数据元素的关键字都比后一子表中数据元素的关键字小（但子表内部未必有序）。<br>将各子表中的最大关键字构成一个索引表，表中还要包含每个子表的起始地址（即头指针）。<br>① 由索引表确定关键字所在的区域，由于索引表是有序表，可以用折半查找法；<br>② 在顺序表的某个子表中查找关键字，各子表内部数据元素无序，只能采用顺序查找法；  </p><pre><code> typedef struct {       int key;    int start;    int len; }IDX; int blk_search(int a[],IDX idx[],int v,int m) {       int low=0,high=m-1,mid,i,h;    while(low&lt;=high)       {          mid=(low+high)/2;        if(v&lt;idx[mid].key)                 high=mid-1;        else if(v&gt;idx[mid].key)            low=mid+1;        else         {              low=mid;            break;           }    }     if(low&gt;=m)        return(-1);    i=idx[low].start;    h=i+idx[low].len;    while(i&lt;h&amp;&amp;a[i]!=v)          i++ ;    if(a[i]!=v) i=-l;        return(i);} </code></pre></li><li><p>二叉排序树<br>若二叉排序树为空，则查找失败，否则<br>（1）首先将根结点值与待查值进行比较，若相等，则查找成功。<br>（2）若根结点值大于待查值，则进入左子树重复此步骤，否则，进入右子树重复此步骤。<br>（3）若在查找过程中遇到二叉排序树的叶子结点时，还没有找到待查结点，则查找不成功。<br>递归函数 </p><pre><code>NODE *search(NODE t,char x){       if(t==NULL)        return(NULL);    else    {         if(t-&gt;data==x) return(t);        if(x&lt;(t-&gt;data) return(search(t-&gt;lchild,x));        else         return(search(t-&gt;rchild,x));     }}</code></pre><p>非递归函数</p><pre><code>NODE  *search(NODE *t,char x){       NODE *p;    p=t;    while(p!=NULL)    {         if(p-&gt;data==x)  return(p);        if(x&lt;p-&gt;data)   p=p-&gt;lchild;        else   p=p-&gt;rchlid;     }    printf(“ 找不到值为%x的结点!”,x);    return(NULL);} </code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###静态表查找&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;顺序查找&lt;br&gt;核心：从数据的第一个元素开始，依次比较，直到找到目标数据或查找失败。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从表中的第一个元素开始，依次与关键字比较           &lt;/li&gt;
&lt;li&gt;若某个元素匹配关键字，则 查找成功。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;若查找到最后一个元素还未匹配关键字，则 查找失败。&lt;br&gt;特点：顺序查找平均关键字匹配次数为表长的一半，其时间复杂度为O(n),顺序查找的优点是对表无要求，插入数据可在O(1)内完成。缺点是时间复杂度较大，数据规模较大时，效率较低。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://peisenli.github.io/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode16-最接近的三数之和</title>
    <link href="http://peisenli.github.io/2019/09/04/LeetCode16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://peisenli.github.io/2019/09/04/LeetCode16-最接近的三数之和/</id>
    <published>2019-09-04T09:04:14.000Z</published>
    <updated>2019-09-04T09:08:06.079Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。<br>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.<br>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).<br><a id="more"></a><br>思路：<br>排序，遍历，双指针<br>排序是为了使用双指针，首先遍历得到索引 c，然后计算 c，左指针 i，右指针 j 对应数字之和，如果大于 target，j 向内移动，否则 i 向内移动   </p><pre><code>class Solution(object):def threeSumClosest(self, nums, target):    &quot;&quot;&quot;    :type nums: List[int]    :type target: int    :rtype: int    &quot;&quot;&quot;    n = len(nums)    nums.sort()    re_min = 0 #存储当前最小的差值    for i in range(len(nums)):        low = i+1        high = n-1        while low &lt; high:            three_sum = nums[i] + nums[low] + nums[high]            x = target - three_sum #当前三数的差值            if re_min == 0:                re_min = abs(x)                sum_min = three_sum #sum_min为当前最接近的和            if abs(x) &lt; re_min:                re_min = abs(x)                sum_min = three_sum            if three_sum == target:                return target            elif three_sum &lt; target:                low += 1            else:                high -=1    return sum_min</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。&lt;br&gt;例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.&lt;br&gt;与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode15-三数之和</title>
    <link href="http://peisenli.github.io/2019/09/03/LeetCode15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://peisenli.github.io/2019/09/03/LeetCode15-三数之和/</id>
    <published>2019-09-03T07:28:43.000Z</published>
    <updated>2019-09-04T08:14:02.870Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。<br>例如, 给定数组<br>nums = [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]<br><a id="more"></a><br>思路：</p><ul><li>先将数组进行排序</li><li>从左侧开始，选定一个值为 定值 ，右侧进行求解，获取与其相加为 0 的两个值</li><li><p>类似于快排，定义首和尾<br>首尾与 定值 相加<br>等于 00，记录这三个值<br>小于 00，首部右移<br>大于 00，尾部左移<br>定值右移，重复该步骤  </p><pre><code>class Solution(object):def threeSum(self, nums):    &quot;&quot;&quot;    :type nums: List[int]    :rtype: List[List[int]]    &quot;&quot;&quot;nums.sort()res =[]i = 0for i in range(len(nums)):    if i == 0 or nums[i]&gt;nums[i-1]:        l = i+1        r = len(nums)-1        while l &lt; r:            s = nums[i] + nums[l] +nums[r]            if s ==0:                res.append([nums[i],nums[l],nums[r]])                l +=1                r -=1                while l &lt; r and nums[l] == nums[l-1]:                    l += 1                while r &gt; l and nums[r] == nums[r+1]:                    r -= 1            elif s&gt;0:                r -=1            else :                l +=1return res</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。&lt;br&gt;注意：答案中不可以包含重复的三元组。&lt;br&gt;例如, 给定数组&lt;br&gt;nums = [-1, 0, 1, 2, -1, -4]，&lt;br&gt;满足要求的三元组集合为：&lt;br&gt;[&lt;br&gt;  [-1, 0, 1],&lt;br&gt;  [-1, -1, 2]&lt;br&gt;]&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode11-盛水最多的容器</title>
    <link href="http://peisenli.github.io/2019/09/02/LeetCode11-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>http://peisenli.github.io/2019/09/02/LeetCode11-盛水最多的容器/</id>
    <published>2019-09-02T09:19:44.000Z</published>
    <updated>2019-09-02T10:53:12.256Z</updated>
    
    <content type="html"><![CDATA[<p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>说明：你不能倾斜容器，且 n 的值至少为 2。<br><img src="https://i.loli.net/2019/09/02/eMRhmZK6SI9C2Lu.jpg" alt="question_11.jpg"><br>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。<br>示例:<br>输入: [1,8,6,2,5,4,8,3,7]<br>输出: 49<br><a id="more"></a><br>思路：采用暴力法简单地考虑每对可能出现的线段组合并找出这些情况之下的最大面积，但是在进行提交时出现运行超时。</p><pre><code>class Solution(object):    def maxArea(self, height):        &quot;&quot;&quot;        :type height: List[int]        :rtype: int        &quot;&quot;&quot;        MaxArea = 0        for i in range(0,len(height)):            for j in range(i+1,len(height)):                MaxArea = max(MaxArea,min(height[i],height[j])*(j-i))        return MaxArea</code></pre><p>双指针法<br>这种方法背后的思路在于，两线段之间形成的区域总是会受到其中较短那条长度的限制。此外，两线段距离越远，得到的面积就越大。<br>我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 此外，我们会使用变量 maxareamaxarea 来持续存储到目前为止所获得的最大面积。 在每一步中，我们会找出指针所指向的两条线段形成的区域，更新 maxareamaxarea，并将指向较短线段的指针向较长线段那端移动一步。  </p><pre><code>class Solution(object):    def maxArea(self, height):        &quot;&quot;&quot;        :type height: List[int]        :rtype: int        &quot;&quot;&quot;        MaxArea = 0        i = 0        j = len(height) - 1         while(i &lt; j):            MaxArea = max(MaxArea,min(height[i],height[j])*(j-i))            if height[i] &lt; height[j]:                i += 1            else:                j -= 1        return MaxArea</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。&lt;br&gt;说明：你不能倾斜容器，且 n 的值至少为 2。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2019/09/02/eMRhmZK6SI9C2Lu.jpg&quot; alt=&quot;question_11.jpg&quot;&gt;&lt;br&gt;图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。&lt;br&gt;示例:&lt;br&gt;输入: [1,8,6,2,5,4,8,3,7]&lt;br&gt;输出: 49&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode53-最大子序和</title>
    <link href="http://peisenli.github.io/2019/09/01/LeetCode53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <id>http://peisenli.github.io/2019/09/01/LeetCode53-最大子序和/</id>
    <published>2019-09-01T11:14:06.000Z</published>
    <updated>2019-09-01T11:22:28.719Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>示例:<br>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br><a id="more"></a><br>思路：<br>动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 ans<br>如果 sum &gt; 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字<br>如果 sum &lt;= 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字<br>每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果  </p><pre><code>class Solution(object):    def maxSubArray(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: int        &quot;&quot;&quot;        for i in range(1, len(nums)):            ans = max(nums[i-1], 0)            nums[i]= nums[i] + ans        return max(nums)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;br&gt;示例:&lt;br&gt;输入: [-2,1,-3,4,-1,2,1,-5,4],&lt;br&gt;输出: 6&lt;br&gt;解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode26-删除排序数组中的重复项</title>
    <link href="http://peisenli.github.io/2019/08/30/LeetCode26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>http://peisenli.github.io/2019/08/30/LeetCode26-删除排序数组中的重复项/</id>
    <published>2019-08-30T07:45:39.000Z</published>
    <updated>2019-08-30T07:49:07.073Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br>示例 1:<br>给定数组 nums = [1,1,2],<br>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。<br>你不需要考虑数组中超出新长度后面的元素。<br>示例 2:<br>给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br><strong>思路：</strong>用两个指针，指向第一个和第二个元素，如果他们相等，删除第二个元素。指针还指向原来的位置，继续比较。不等的话，两个指针位置都加一。遍历结束即可。<br><a id="more"></a></p><pre><code>class Solution(object):    def removeDuplicates(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: int        &quot;&quot;&quot;        if not nums:            return 0        j = 0        for i in range(1,len(nums)):            if nums[i] != nums[j]:                j += 1                nums[j] = nums[i]        return j+1        </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。&lt;br&gt;不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。&lt;br&gt;示例 1:&lt;br&gt;给定数组 nums = [1,1,2],&lt;br&gt;函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。&lt;br&gt;你不需要考虑数组中超出新长度后面的元素。&lt;br&gt;示例 2:&lt;br&gt;给定 nums = [0,0,1,1,1,2,2,3,3,4],&lt;br&gt;函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。&lt;br&gt;&lt;strong&gt;思路：&lt;/strong&gt;用两个指针，指向第一个和第二个元素，如果他们相等，删除第二个元素。指针还指向原来的位置，继续比较。不等的话，两个指针位置都加一。遍历结束即可。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode4.寻找两个有序数组的中位数</title>
    <link href="http://peisenli.github.io/2019/08/29/LeetCode4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://peisenli.github.io/2019/08/29/LeetCode4-寻找两个有序数组的中位数/</id>
    <published>2019-08-29T09:30:32.000Z</published>
    <updated>2019-08-29T09:38:44.566Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。<br>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。<br>你可以假设 nums1 和 nums2 不会同时为空。<br>示例 1:<br>nums1 = [1, 3]<br>nums2 = [2]<br>则中位数是 2.0<br>示例 2:<br>nums1 = [1, 2]<br>nums2 = [3, 4]<br>则中位数是 (2 + 3)/2 = 2.5  </p><p><strong>思路：</strong>题目要求时间复杂度为O(log(m + n))。基本可以确定本题应该用二分查找，对于数组arr的中位数，如果数组长度为len，<br>len为奇数，则中位数为第（len+1）/2 位，如果len为偶数，我们需要知道第 len/2和 len/2+1 个数。<br><a id="more"></a></p><pre><code>class Solution(object):    def findMedianSortedArrays(self, A, B):        &quot;&quot;&quot;        :type nums1: List[int]        :type nums2: List[int]        :rtype: float        &quot;&quot;&quot;        m, n = len(A), len(B)        if m &gt; n:            A, B, m, n = B, A, n, m        if n == 0:            raise ValueError        imin, imax, half_len = 0, m, (m + n + 1) / 2        while imin &lt;= imax:            i = (imin + imax) / 2            j = half_len - i            if i &lt; m and B[j-1] &gt; A[i]:                # i is too small, must increase it                imin = i + 1            elif i &gt; 0 and A[i-1] &gt; B[j]:                # i is too big, must decrease it                imax = i - 1            else:                # i is perfect                if i == 0: max_of_left = B[j-1]                elif j == 0: max_of_left = A[i-1]                else: max_of_left = max(A[i-1], B[j-1])                if (m + n) % 2 == 1:                    return max_of_left                if i == m: min_of_right = B[j]                elif j == n: min_of_right = A[i]                else: min_of_right = min(A[i], B[j])                return (max_of_left + min_of_right) / 2.0</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。&lt;br&gt;请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。&lt;br&gt;你可以假设 nums1 和 nums2 不会同时为空。&lt;br&gt;示例 1:&lt;br&gt;nums1 = [1, 3]&lt;br&gt;nums2 = [2]&lt;br&gt;则中位数是 2.0&lt;br&gt;示例 2:&lt;br&gt;nums1 = [1, 2]&lt;br&gt;nums2 = [3, 4]&lt;br&gt;则中位数是 (2 + 3)/2 = 2.5  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;题目要求时间复杂度为O(log(m + n))。基本可以确定本题应该用二分查找，对于数组arr的中位数，如果数组长度为len，&lt;br&gt;len为奇数，则中位数为第（len+1）/2 位，如果len为偶数，我们需要知道第 len/2和 len/2+1 个数。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>图-拓扑排序</title>
    <link href="http://peisenli.github.io/2019/08/28/%E5%9B%BE-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>http://peisenli.github.io/2019/08/28/图-拓扑排序/</id>
    <published>2019-08-28T08:59:21.000Z</published>
    <updated>2019-08-28T09:14:59.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p><strong>1.定义</strong><br>给出有向图G=(V,E)，对于V中的顶点的线性序列(vi1,vi2,…,vin)，如果满足如下条件：若在G中从顶点 vi 到vj有一条路经，则在序列中顶点vi必在顶点 vj之前；则称该序列为 G的一个拓扑序列(Topological order)。构造有向图的一个拓扑序列的过程称为拓扑排序(Topological sort)。<br><strong>2.说明</strong><br>(1)在AOV网中，若不存在回路，则所有活动可排成一个线性序列，使得每个活动的所有前驱活动都排在该活动的前面，那么该序列为拓扑序列。<br>(2)拓扑序列不是唯一的。<br>(3)AOV网不一定都存在拓扑序列。<br>在AOV网中，&lt;i,j&gt;有向边表示i活动应先于j活动开始，即i活动必须完成后，j活动才可以开始，并称i为j的直接前驱，j为i的直接后继。这种前驱与后继的关系有传递性，此外，任何活动i不能以它自己作为自己的前驱或后继，这叫做反自反性。从前驱和后继的传递性和反自反性来看，AOV网中不能出现有向回路(或称有向环)。在AOV网中如果出现了有向环，则意味着某项活动应以自己作为先决条件，工程将无法进行。对程序流程而言，将出现死循环。<br>因此，对给定的AOV网，应先判断它是否存在有向环。判断AOV网是否有有向环的方法是对该AOV网进行拓扑排序，将AOV网中顶点排列成一个线性有序序列，若该线性序列中包含AOV网全部顶点，则AOV网无环，否则，AOV网中存在有向环，该AOV网所代表的工程是不可行的。<br><a id="more"></a><br><strong>3、拓扑序列的实际意义是:</strong><br>如果按照拓扑序列中的顶点次序进行每一项活动，就能够保证在开始每一项活动时，他的所有前驱活动均已完成，从而使整个工程顺序执行。  </p><h3 id="拓扑排序方法"><a href="#拓扑排序方法" class="headerlink" title="拓扑排序方法"></a>拓扑排序方法</h3><p>(1)在AOV网中选一个入度为0的顶点(没有前驱)且输出之；<br>(2)从AOV网中删除此顶点及该顶点发出来的所有有向边；<br>(3)重复(1)、(2)两步，直到AOV网中所有顶点都被输出或网中不存在入度为0的顶点。<br>从拓扑排序步骤可知，若在第3步中，网中所有顶点都被输出，则表明网中无有向环，拓扑排序成功。若仅输出部分顶点，网中已不存在入度为0的顶点，则表明网中有有向环，拓扑排序不成功。因此，一个AOV网的拓扑序列是不唯一的。  </p><p>###算法步骤###<br>在执行拓扑排序的过程中，当某个顶点的入度为零时，就将此顶点输出，同时将该顶点的所有后续顶点的入度减1，为了避免重复检测入度为零的顶点，设立一个栈，以存放入度为零的顶点。执行拓扑排序的算法步骤如下：<br>（1）输入有向边的序列，建立相应的邻接表。<br>（2）查找邻接表中入度为零的顶点，让入度为零的顶点入栈。<br>（3）当栈不空时<br>（a）使用退栈操作，取得栈顶的顶点j并输出。<br>（b）在邻接表的第j个链表中，查找顶点j的所有后续顶点k，将顶点k的入度减1。若顶点k的入度变为零，则顶点k进栈，转步骤（3）<br>（4）当栈空时，若有向图的所有顶点都输出，则拓扑排序过程正常结束，否则，有向图存在回路。<br>如果给定的有向图有n个顶点和m条边，那么建立邻接表的时间为O(m)，在拓扑排序的过程中，查找入度为零的顶点的时间为O(n)，顶点进栈及退栈输出共执行n次，入度减1的操作执行m次，所以，总的执行时间为O(m+n)。  </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;拓扑排序&quot;&gt;&lt;a href=&quot;#拓扑排序&quot; class=&quot;headerlink&quot; title=&quot;拓扑排序&quot;&gt;&lt;/a&gt;拓扑排序&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.定义&lt;/strong&gt;&lt;br&gt;给出有向图G=(V,E)，对于V中的顶点的线性序列(vi1,vi2,…,vin)，如果满足如下条件：若在G中从顶点 vi 到vj有一条路经，则在序列中顶点vi必在顶点 vj之前；则称该序列为 G的一个拓扑序列(Topological order)。构造有向图的一个拓扑序列的过程称为拓扑排序(Topological sort)。&lt;br&gt;&lt;strong&gt;2.说明&lt;/strong&gt;&lt;br&gt;(1)在AOV网中，若不存在回路，则所有活动可排成一个线性序列，使得每个活动的所有前驱活动都排在该活动的前面，那么该序列为拓扑序列。&lt;br&gt;(2)拓扑序列不是唯一的。&lt;br&gt;(3)AOV网不一定都存在拓扑序列。&lt;br&gt;在AOV网中，&amp;lt;i,j&amp;gt;有向边表示i活动应先于j活动开始，即i活动必须完成后，j活动才可以开始，并称i为j的直接前驱，j为i的直接后继。这种前驱与后继的关系有传递性，此外，任何活动i不能以它自己作为自己的前驱或后继，这叫做反自反性。从前驱和后继的传递性和反自反性来看，AOV网中不能出现有向回路(或称有向环)。在AOV网中如果出现了有向环，则意味着某项活动应以自己作为先决条件，工程将无法进行。对程序流程而言，将出现死循环。&lt;br&gt;因此，对给定的AOV网，应先判断它是否存在有向环。判断AOV网是否有有向环的方法是对该AOV网进行拓扑排序，将AOV网中顶点排列成一个线性有序序列，若该线性序列中包含AOV网全部顶点，则AOV网无环，否则，AOV网中存在有向环，该AOV网所代表的工程是不可行的。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>图-最短路径问题</title>
    <link href="http://peisenli.github.io/2019/08/28/%E5%9B%BE-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <id>http://peisenli.github.io/2019/08/28/图-最短路径问题/</id>
    <published>2019-08-28T06:48:01.000Z</published>
    <updated>2019-08-28T06:50:14.646Z</updated>
    
    <content type="html"><![CDATA[<p><strong>最短路径问题</strong>是图论研究中的一个经典算法问题， 旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法能得出最短路径的最优解，但由于它遍历计算的节点很多，所以效率低。<br>单源点最短路径是指：给定一个出发点(单源点)和一个有向网G=(V，E),求出源点到其它各顶点之间的最短路径。<br>迪杰斯特拉(Dijkstra)在做了大量观察后,首先提出了按路径长度递增序产生各顶点的最短路径算法,我们称之为<strong>迪杰斯特拉算法</strong>。<br><strong>算法的基本思想是:</strong>把图中顶点集合分成两组，第一组为集合S，存放已求出其最短路径的顶点，第二组为尚未确定最短路径的顶点集合是V-S（用U表示），其中V为网中所有顶点集合。按最短路径长度递增的顺序逐个把U中的顶点加到S中，直到S中包含全部顶点，而U为空。在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。<br>（1）初始时，S只包含源点，S={v}，v的距离为0。U包含除v外的其他顶点，U中顶点的距离为顶点的权或∞ 。<br>（2）从U中选取一个距离最小的顶点k，把k加入到S中<br>（3）以k 作为新考虑的中间点，修改U中各顶点的距离。<br>（4）重复步骤（2）、（3）直到所有顶点都包含在S中。<br>时间复杂度：O（V^3）<br><a id="more"></a></p><center><img src="https://i.loli.net/2019/08/28/UwrRpzbHsENFiaY.png" alt="TIM图片20190828143649.png"><br><img src="https://i.loli.net/2019/08/28/J4hFigydBtOeLQp.png" alt="TIM图片20190828143701.png">  </center><pre><code>//有权图的Dijikstra(遍历整个数组寻找最小路径顶点)bool Dijikstra(int vertex){    //根据初始结点初始化距离数组与路径数组     for(int i = 0 ; i &lt; this-&gt;Nv+1 ; i++){        //在构造函数里dist已经全部初始化为MAX        //G存在边时为权重，没有边时为MAX         this-&gt;dist[i] = this-&gt;G[vertex][i];        if(this-&gt;dist[i] &lt; MAX){            this-&gt;path[i] = vertex;        }    }    this-&gt;dist[vertex] = 0;        //初始结点的距离为０    this-&gt;collected[vertex] = 1;    //初始结点标记为已收录     while(1){        //V是未被收录定点中dist最小者         int V = this-&gt;FindMinVertex();         if(V == -1){//未找到这样的V则跳出循环             break;        }         this-&gt;collected[V] = 1;//标记为已经被收录         //遍历图中每个顶点         for(int w = 1 ; w &lt; this-&gt;Nv+1 ; w++){            //若w是V的邻接点且未被收录             if(this-&gt;collected[w] == 0 &amp;&amp; this-&gt;G[V][w] &lt; MAX){                if(this-&gt;G[V][w] &lt; 0){//存在负边时                     return false;    //结束算法                 }                //若收录V使得dist[w]变小                 if(this-&gt;dist[V] + this-&gt;G[V][w] &lt; this-&gt;dist[w]){                    //更新dist[w]                     this-&gt;dist[w] = this-&gt;dist[V] = this-&gt;G[V][w];                     this-&gt;path[w] = V;//更新路径                 }             }         }     }    return true;}</code></pre><p>最短路径算法中的<strong>Floyd算法</strong>，这是针对多源最短路径的一个经典算法。<br><strong>算法思想：</strong><br>Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）。<br>从任意节点i到任意节点j的最短路径不外乎2种可能，一是直接从i到j，二是从i经过若干个节点k到j。所以，我们假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，我们检查Dis(i,k) + Dis(k,j) &lt; Dis(i,j)是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，我们便设置Dis(i,j) = Dis(i,k) + Dis(k,j)，这样一来，当我们遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。<br>时间复杂度：O（V^3）<br><strong>算法过程：</strong><br>1）首先把初始化距离dist数组为图的邻接矩阵，路径数组path初始化为-1。其中对于邻接矩阵中的数首先初始化为正无穷，如果两个顶点存在边则初始化为权重。<br>2）对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短。如果是就更新它。<br>状态转移方程为<br>如果 dist[i][k]+dist[k][j] &lt; dist[i][j]<br>则   dist[i][j] = dist[i][k]+dist[k][j]  </p><pre><code>bool Floyd(){    for(int k = 1 ; k &lt; this-&gt;Nv+1 ; k++){    //k代表中间顶点         for(int i = 1  ; i &lt; this-&gt;Nv+1 ; i++){//i代表起始顶点             for(int j = 1 ; j &lt; this-&gt;Nv+1 ; j++){//j代表终点                 if(this-&gt;dist[i][k] + this-&gt;dist[k][j] &lt; this-&gt;dist[i][j]){                    this-&gt;dist[i][j] = this-&gt;dist[i][k] + this-&gt;dist[k][j];                    if(i == j &amp;&amp; this-&gt;dist[i][j] &lt; 0){//发现了负值圈                         return false;                    }                    this-&gt;path[i][j] = k;                }                                }        }    }    return true; }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;最短路径问题&lt;/strong&gt;是图论研究中的一个经典算法问题， 旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法能得出最短路径的最优解，但由于它遍历计算的节点很多，所以效率低。&lt;br&gt;单源点最短路径是指：给定一个出发点(单源点)和一个有向网G=(V，E),求出源点到其它各顶点之间的最短路径。&lt;br&gt;迪杰斯特拉(Dijkstra)在做了大量观察后,首先提出了按路径长度递增序产生各顶点的最短路径算法,我们称之为&lt;strong&gt;迪杰斯特拉算法&lt;/strong&gt;。&lt;br&gt;&lt;strong&gt;算法的基本思想是:&lt;/strong&gt;把图中顶点集合分成两组，第一组为集合S，存放已求出其最短路径的顶点，第二组为尚未确定最短路径的顶点集合是V-S（用U表示），其中V为网中所有顶点集合。按最短路径长度递增的顺序逐个把U中的顶点加到S中，直到S中包含全部顶点，而U为空。在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。&lt;br&gt;（1）初始时，S只包含源点，S={v}，v的距离为0。U包含除v外的其他顶点，U中顶点的距离为顶点的权或∞ 。&lt;br&gt;（2）从U中选取一个距离最小的顶点k，把k加入到S中&lt;br&gt;（3）以k 作为新考虑的中间点，修改U中各顶点的距离。&lt;br&gt;（4）重复步骤（2）、（3）直到所有顶点都包含在S中。&lt;br&gt;时间复杂度：O（V^3）&lt;br&gt;
    
    </summary>
    
    
      <category term="Data Struct" scheme="http://peisenli.github.io/tags/Data-Struct/"/>
    
  </entry>
  
  <entry>
    <title>图的生成树问题</title>
    <link href="http://peisenli.github.io/2019/08/28/%E5%9B%BE%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98/"/>
    <id>http://peisenli.github.io/2019/08/28/图的生成树问题/</id>
    <published>2019-08-28T02:48:15.000Z</published>
    <updated>2019-08-28T02:56:18.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、无向图的连通分量和生成树"><a href="#一、无向图的连通分量和生成树" class="headerlink" title="一、无向图的连通分量和生成树"></a>一、无向图的连通分量和生成树</h2><p>若图是连通的或强连通的，则从图中某一个顶点出发可以访问到图中所有顶点；<br>若图是非连通的或非强连通图，则需从图中多个顶点出发搜索访问。而每一次从一个新的起始点出发进行搜索过程中得到的顶点访问序列恰为每个连通分量中的顶点集。  </p><h3 id="1、生成树"><a href="#1、生成树" class="headerlink" title="1、生成树"></a>1、生成树</h3><p>深度优先搜索遍历算法及广度优先搜索遍历算法中遍历图过程中历经边的集合和顶点集合一起构成连通图的极小连通子图。它是连通图的一颗生成树。<br>生成树：是一个极小连通子图，它含有图中全部n个顶点，但只有n-1条边。<br>由深度优先搜索遍历得到的生成树，称为深度优先生成树，由广度优先搜索遍历得到的生成树，称为广度优先生成树。图中无向图G7的两种生成树见 图(a)、(b)。<br><img src="https://i.loli.net/2019/08/28/Q6cGY2loXtgzDxe.png" alt="生成shu.png"><br><a id="more"></a></p><h3 id="2．生成森林"><a href="#2．生成森林" class="headerlink" title="2．生成森林"></a>2．生成森林</h3><p>若一个图是非连通图或非强连通图，但有若干个连通分量或若干个强连通分量，则通过深度优先搜索遍历或广度优先搜索遍历，不可以得到生成树，但可以得到生成森林，且若非连通图有 n 个顶点，m 个连通分量或强连通分量，则可以遍历得到m棵生成树，合起来为生成森林，森林中包含n-m条树边。<br>生成森林可以利用非连通图的深度优先搜索遍历或非连通图的广度优先搜索遍历算法得到。   </p><h3 id="3．最小生成树"><a href="#3．最小生成树" class="headerlink" title="3．最小生成树"></a>3．最小生成树</h3><p>在一般情况下，图中的每条边若给定了权，这时，我们所关心的不是生成树，而是生成树中边上权值之和。若生成树中每条边上权值之和达到最小，称为最小生成树。  </p><h2 id="二、求最小生成树"><a href="#二、求最小生成树" class="headerlink" title="二、求最小生成树"></a>二、求最小生成树</h2><p><strong>首先明确：</strong>  </p><ul><li>使用不同的遍历图的方法，可以得到不同的生成树；从不同的顶点出发，也可能得到不同的生成树。  </li><li>按照生成树的定义，n 个顶点的连通网络的生成树有 n 个顶点、n-1 条边。<br><strong>目标：</strong><br>在网络的多个生成树中，寻找一个各边权值之和最小的生成树。<br><strong>构造最小生成树的准则</strong>  </li><li>必须只使用该网络中的边来构造最小生成树；  </li><li>必须使用且仅使用n-1条边来联结网络中的n个顶点；  </li><li><p>不能使用产生回路的边。  </p><h3 id="1-克鲁斯卡尔算法基本思想"><a href="#1-克鲁斯卡尔算法基本思想" class="headerlink" title="1. 克鲁斯卡尔算法基本思想"></a>1. 克鲁斯卡尔算法基本思想</h3><p>克鲁斯卡尔算法的基本思想是：将图中所有边按权值递增顺序排列，依次选定取权值较小的边，但要求后面选取的边不能与前面选取的边构成回路，若构成回路，则放弃该条边，再去选后面权值较大的边，n个顶点的图中，选够n-1条边即可。  </p><p>  #定义<br>  typedef struct  Edge                //定义边集数组元素，v1,v2存顶点，weight存权重。<br>  {</p><pre><code>int v1;int v2;int weight;</code></pre><p>  }Edge;</p><p>  typedef struct ALGraph        //定义图的结构，peak存顶点的数量，edge存边的数量<br>  {                                            //指针p作为边集数组，指针m为作为顶点数组</p><pre><code>int peak;int edge;Edge *p;int *m;</code></pre><p>  }ALGraph;<br>  #创建图<br>  void CreatALGraph(ALGraph *G)<br>  {</p><pre><code>int i,j;printf(&quot;输入图的顶点数量和边的数量：&quot;);scanf(&quot;%d %d&quot;,&amp;G-&gt;peak,&amp;G-&gt;edge);G-&gt;p=(Edge *)malloc(sizeof(Edge)*(G-&gt;edge+1));G-&gt;m=(int *)malloc(sizeof(int)*G-&gt;peak);for(i=0;i&lt;G-&gt;peak;i++){      printf(&quot;请输入输入顶点：&quot;);      scanf(&quot;%d&quot;,&amp;G-&gt;m[i]);}for(i=0;i&lt;G-&gt;edge;i++){    printf(&quot;请输入(vi-vj)和权重：&quot;);    scanf(&quot;%d %d %d&quot;,&amp;G-&gt;p[i].v1,&amp;G-&gt;p[i].v2,&amp;G-&gt;p[i].weight);}for(i=0 ;i&lt;G-&gt;edge;i++)                //冒泡排序法，权重从小到大存在边集数组中{    for(j=G-&gt;edge-1;j&gt;i;j--)    {        if(G-&gt;p[i].weight&gt;G-&gt;p[j].weight)        {            G-&gt;p[G-&gt;edge]=G-&gt;p[i];            G-&gt;p[i]=G-&gt;p[j];            G-&gt;p[j]=G-&gt;p[G-&gt;edge];        }    }}</code></pre><p>  }<br>  #克鲁斯卡尔算法<br>  int Find(int *parent,int g)                //通过parent[]找到可连接的边<br>  {</p><pre><code>while(parent[g]!=0){    g=parent[g];}return g;</code></pre><p>  }<br>  int Finish(ALGraph <em>G,int </em>parent)        //判断生成树是否完成，完成的标志是生成树的边等于顶点的数量减1<br>  {</p><pre><code>int i,n=0;for(i=0;i&lt;G-&gt;peak;i++){    if(parent[i])    {        n++;    }}if(n==G-&gt;peak-1){    return 1;}return 0;</code></pre><p>  }<br>  int FindPeak(ALGraph *G,int g)        //找到顶点的下标<br>  {</p><pre><code>int i;for(i=0;i&lt;G-&gt;peak;i++){    if(G-&gt;m[i]==g)        return i;}return -1;</code></pre><p>  }<br>  void MinTree_Kruskal(ALGraph *G)<br>  {</p><pre><code>int i,a,b;int parent[G-&gt;peak];for(i=0;i&lt;G-&gt;peak;i++)        //初始化parent[]{    parent[i]=0;}for(i=0;i&lt;G-&gt;edge;i++){    a=Find(parent,FindPeak(G,G-&gt;p[i].v1));    b=Find(parent,FindPeak(G,G-&gt;p[i].v2));    if(a!=b)                //如果a==b则表是a和b在同一颗生成树上，如果a和b连接则为生成环，不符合生成树    {        parent[a]=b;        printf(&quot;%d-&gt;%d   %d\n&quot;,G-&gt;p[i].v1,G-&gt;p[i].v2,G-&gt;p[i].weight);    }    if(Finish(G,parent))        //完成后返回    {        return;    }}</code></pre><p>  }</p></li></ul><h3 id="2-普里姆-prim-算法思想"><a href="#2-普里姆-prim-算法思想" class="headerlink" title="2. 普里姆(prim)算法思想"></a>2. 普里姆(prim)算法思想</h3><p>普里姆方法的思想是：在图中任取一个顶点K作为开始点，令U={k}，W=V-U，其中V为图中所有顶点集，然后找一个顶点在U中，另一个顶点在W中的边中最短的一条，找到后，将该边作为最小生成树的树边保存起来，并将该边顶点全部加入U集合中，并从W中删去这些顶点，然后重新调整U中顶点到W中顶点的距离, 使之保持最小，再重复此过程，直到W为空集止。  </p><pre><code>#define INFINITE 9999#define MAXN 100void prim(int cost[][MAXN],int n,int v){      int lowcost[MAXN],min,closest[MAXN],i,j,k;    for(i=1;i&lt;=n;i++)    {          lowcost[i]=cost[v][i];        closest[i]=v;    }       for(i=1;i&lt;n;i++)    {          min=INFINITE;        for(j=1;j&lt;=n;j++)            if(lowcost[j]!=0&amp;&amp;lowcost[j]&lt;min))            {                  min=lowcost[j];                k=j;               }             printf(“%d%d%d”,closest[k],k,min);             lowcost[k]=0;             for(j=1;j&lt;=n;j++)                if((cost[k][j]!=0)&amp;&amp;(cost[k][j]&lt;lowcost[j]))                   {                      lowcost[j]=cost[k][j];                       closest[j]=k;                  }     }}#时间复杂度为O(n2)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、无向图的连通分量和生成树&quot;&gt;&lt;a href=&quot;#一、无向图的连通分量和生成树&quot; class=&quot;headerlink&quot; title=&quot;一、无向图的连通分量和生成树&quot;&gt;&lt;/a&gt;一、无向图的连通分量和生成树&lt;/h2&gt;&lt;p&gt;若图是连通的或强连通的，则从图中某一个顶点出发可以访问到图中所有顶点；&lt;br&gt;若图是非连通的或非强连通图，则需从图中多个顶点出发搜索访问。而每一次从一个新的起始点出发进行搜索过程中得到的顶点访问序列恰为每个连通分量中的顶点集。  &lt;/p&gt;
&lt;h3 id=&quot;1、生成树&quot;&gt;&lt;a href=&quot;#1、生成树&quot; class=&quot;headerlink&quot; title=&quot;1、生成树&quot;&gt;&lt;/a&gt;1、生成树&lt;/h3&gt;&lt;p&gt;深度优先搜索遍历算法及广度优先搜索遍历算法中遍历图过程中历经边的集合和顶点集合一起构成连通图的极小连通子图。它是连通图的一颗生成树。&lt;br&gt;生成树：是一个极小连通子图，它含有图中全部n个顶点，但只有n-1条边。&lt;br&gt;由深度优先搜索遍历得到的生成树，称为深度优先生成树，由广度优先搜索遍历得到的生成树，称为广度优先生成树。图中无向图G7的两种生成树见 图(a)、(b)。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2019/08/28/Q6cGY2loXtgzDxe.png&quot; alt=&quot;生成shu.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Data Struct" scheme="http://peisenli.github.io/tags/Data-Struct/"/>
    
  </entry>
  
</feed>
