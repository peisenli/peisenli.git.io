<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Paysonly</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://peisenli.github.io/"/>
  <updated>2020-09-03T03:45:18.756Z</updated>
  <id>http://peisenli.github.io/</id>
  
  <author>
    <name>Kong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态规划-leetcode64最小路径和</title>
    <link href="http://peisenli.github.io/2020/09/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-leetcode64%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://peisenli.github.io/2020/09/03/动态规划-leetcode64最小路径和/</id>
    <published>2020-09-03T01:17:23.000Z</published>
    <updated>2020-09-03T03:45:18.756Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动态规划：最小路径和"><a href="#动态规划：最小路径和" class="headerlink" title="动态规划：最小路径和"></a>动态规划：最小路径和</h3><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p><strong>示例:</strong></p><p>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 7<br>解释: 因为路径 1→3→1→1→1 的总和最小。</p><p><strong>题解</strong></p><p>由于路径的方向只能是向下或向右，因此网格的第一行的每个元素只能从左上角元素开始向右移动到达，网格的第一列的每个元素只能从左上角元素开始向下移动到达，此时的路径是唯一的，因此每个元素对应的最小路径和即为对应的路径上的数字总和。</p><p>对于不在第一行和第一列的元素，可以从其上方相邻元素向下移动一步到达，或者从其左方相邻元素向右移动一步到达，元素对应的最小路径和等于其上方相邻元素与其左方相邻元素两者对应的最小路径和中的最小值加上当前元素的值。由于每个元素对应的最小路径和与其相邻元素对应的最小路径和有关，因此可以使用动态规划求解。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minpathsum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.size(), columns = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(rows, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(columns));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; columns; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; columns; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[rows - <span class="number">1</span>][columns - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;动态规划：最小路径和&quot;&gt;&lt;a href=&quot;#动态规划：最小路径和&quot; class=&quot;headerlink&quot; title=&quot;动态规划：最小路径和&quot;&gt;&lt;/a&gt;动态规划：最小路径和&lt;/h3&gt;&lt;p&gt;给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。&lt;/p&gt;
&lt;p&gt;说明：每次只能向下或者向右移动一步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入:&lt;br&gt;[&lt;br&gt;  [1,3,1],&lt;br&gt;  [1,5,1],&lt;br&gt;  [4,2,1]&lt;br&gt;]&lt;br&gt;输出: 7&lt;br&gt;解释: 因为路径 1→3→1→1→1 的总和最小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于路径的方向只能是向下或向右，因此网格的第一行的每个元素只能从左上角元素开始向右移动到达，网格的第一列的每个元素只能从左上角元素开始向下移动到达，此时的路径是唯一的，因此每个元素对应的最小路径和即为对应的路径上的数字总和。&lt;/p&gt;
&lt;p&gt;对于不在第一行和第一列的元素，可以从其上方相邻元素向下移动一步到达，或者从其左方相邻元素向右移动一步到达，元素对应的最小路径和等于其上方相邻元素与其左方相邻元素两者对应的最小路径和中的最小值加上当前元素的值。由于每个元素对应的最小路径和与其相邻元素对应的最小路径和有关，因此可以使用动态规划求解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>动态规划—Leetcode62</title>
    <link href="http://peisenli.github.io/2020/09/02/The-Problem-of-DP/"/>
    <id>http://peisenli.github.io/2020/09/02/The-Problem-of-DP/</id>
    <published>2020-09-02T12:23:59.000Z</published>
    <updated>2020-09-02T14:50:20.560Z</updated>
    
    <content type="html"><![CDATA[<center> 动态规划 </center><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><p><img src="https://paysonly.oss-cn-chengdu.aliyuncs.com/img/image-20200902203905153.png" alt="image-20200902203905153"></p><p><strong>输入</strong>: m = 3, n = 2<br><strong>输出</strong>: 3<br><strong>解释</strong>:<br>从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li>向右 -&gt; 向右 -&gt; 向下</li><li>向右 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向右</li></ol><a id="more"></a><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划offer.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vc(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">if</span> (m&lt;=<span class="number">0</span>||n&lt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vc[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vc[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                vc[i][j] = vc[i - <span class="number">1</span>][j] + vc[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vc[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution A;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; A.uniquePaths(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; 动态规划 &lt;/center&gt;

&lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。&lt;/p&gt;
&lt;p&gt;问总共有多少条不同的路径？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://paysonly.oss-cn-chengdu.aliyuncs.com/img/image-20200902203905153.png&quot; alt=&quot;image-20200902203905153&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入&lt;/strong&gt;: m = 3, n = 2&lt;br&gt;&lt;strong&gt;输出&lt;/strong&gt;: 3&lt;br&gt;&lt;strong&gt;解释&lt;/strong&gt;:&lt;br&gt;从左上角开始，总共有 3 条路径可以到达右下角。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;向右 -&amp;gt; 向右 -&amp;gt; 向下&lt;/li&gt;
&lt;li&gt;向右 -&amp;gt; 向下 -&amp;gt; 向右&lt;/li&gt;
&lt;li&gt;向下 -&amp;gt; 向右 -&amp;gt; 向右&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Cpp核心编程一</title>
    <link href="http://peisenli.github.io/2020/08/20/Cpp%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E4%B8%80/"/>
    <id>http://peisenli.github.io/2020/08/20/Cpp核心编程一/</id>
    <published>2020-08-20T10:54:19.000Z</published>
    <updated>2020-08-20T10:54:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C-核心编程"><a href="#C-核心编程" class="headerlink" title="C++核心编程"></a>C++核心编程</h3><h4 id="1、内存分区模型"><a href="#1、内存分区模型" class="headerlink" title="1、内存分区模型"></a>1、内存分区模型</h4><p>C++程序执行程序时，将内存大方向划分为4个区域  </p><ul><li><p>代码区：存放函数的二进制代码，由操作系统进行管理的<br>存放CPU执行的机器指令，代码区是共享的，其目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。<br>内存区是只读的，防止程序意外地修改了他的指令。</p></li><li><p>全局区：存放全局变量、静态变量及常量<br>该区的数据在程序结束后由操作系统释放。</p></li><li><p>栈区：由编译器自动分配及释放，存放函数的参数值、局部变量等<br>Notice：不要返回局部变量的地址</p></li><li><p>堆区：有程序员分配和释放。若程序员不释放，程序结束由系统回收。<br>在C++中主要利用new在堆区开辟内存。<br>Eg:  </p><pre><code>int *p = new int(10);   //小括号创建一个变量  int *arr = new int[10];   //中括号表示申请多个变量  </code></pre><p>手动释放利用操作符delete。<br>Eg:    </p><pre><code>delete p;   delete[] arr;  //释放数组</code></pre></li></ul><a id="more"></a><h4 id="2、引用"><a href="#2、引用" class="headerlink" title="2、引用"></a>2、引用</h4><ul><li><p>引用的基本语法<br>作用：给变量取别名<br>语法：数据类型 &amp;别名 = 原名<br>Eg：  </p><pre><code>int main(){    int a = 10 ;    int &amp;b = a ;    b = 20;    cout &lt;&lt; a &lt;&lt; endl; //a的输出为20    return 0;}</code></pre></li><li><p>引用的注意事项<br>引用必须初始化，告诉系统是谁的别名，且一旦初始化就不可再进行更改。  </p></li><li><p>引用做函数参数<br>引用做函数参数的时候相当于对输入实参给予一个别名。</p><pre><code>void swap(int &amp;a,int &amp;b)//形参也可以改编实参，相当于赋值的时候定义别名{    int temp = a;    a = b;    b = a;}</code></pre></li><li><p>引用用作函数返回值<br>不要引用局部变量，引用函数可以作为左值。</p></li><li><p>引用的本质<br>引用的本质实质上是一个指针常量。  </p></li><li><p>常量引用   </p><p>const int &amp;ref = 10;   //ref变为可读，不可修改。</p><pre><code>//防止误操作，引用的变量可以通过别名进行修改。int a = 100;</code></pre></li></ul><pre><code>void showvalue(const int &amp;val){    val = 1000;  //如果没有Const,会对实参进行修改。}</code></pre><h4 id="3、函数的使用"><a href="#3、函数的使用" class="headerlink" title="3、函数的使用"></a>3、函数的使用</h4><ul><li><p>函数的默认参数<br>如果我们自己传入数据，就使用自己的数据，如果没有，即使用默认值。<br>语法：返回值类型 函数名（形式参数等于默认值）</p><pre><code>int Func(int a,int b=20,int c=10){    return a+b+c;}</code></pre><p>注意事项：<br>如果某个形参位置已经有了默认参数那么从这个位置之后从左到右必须全部都有。<br>函数声明或者定义时形式参数智能有一个默认参数。  </p></li><li><p>函数的占位参数<br>返回类型 函数名（数据类型 变量名，数据类型）；<br>占位参数依然可以有默认参数；</p><pre><code>void Test(int a=10; int = 20)  </code></pre><p>在函数调用时必须填补该位置；</p></li><li><p>函数的重载技术<br>作用：函数名可以相同，提高复用性。<br>函数重载满足条件：<br>（1） 同一个作用域下<br>（2） 函数名称相同<br>（3） 函数<strong>参数类型不同</strong>或者<strong>个数不同</strong>或者<strong>顺序不同</strong>，否则程序不知道执行哪一个函数。<br>注意：函数的返回值不可以作为函数重载条件。即不可出现相同名称的不同类型函数返回。</p><pre><code>//引用作为函数参数int func(int &amp;a);int func(const int &amp;a);int a=10;func(a);  //调用第一个函数func(20);  //调用第二个函数</code></pre><p>当函数碰到默认参数时，避免出现二义性的函数调用和定义。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;C-核心编程&quot;&gt;&lt;a href=&quot;#C-核心编程&quot; class=&quot;headerlink&quot; title=&quot;C++核心编程&quot;&gt;&lt;/a&gt;C++核心编程&lt;/h3&gt;&lt;h4 id=&quot;1、内存分区模型&quot;&gt;&lt;a href=&quot;#1、内存分区模型&quot; class=&quot;headerlink&quot; title=&quot;1、内存分区模型&quot;&gt;&lt;/a&gt;1、内存分区模型&lt;/h4&gt;&lt;p&gt;C++程序执行程序时，将内存大方向划分为4个区域  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;代码区：存放函数的二进制代码，由操作系统进行管理的&lt;br&gt;存放CPU执行的机器指令，代码区是共享的，其目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。&lt;br&gt;内存区是只读的，防止程序意外地修改了他的指令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;全局区：存放全局变量、静态变量及常量&lt;br&gt;该区的数据在程序结束后由操作系统释放。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;栈区：由编译器自动分配及释放，存放函数的参数值、局部变量等&lt;br&gt;Notice：不要返回局部变量的地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;堆区：有程序员分配和释放。若程序员不释放，程序结束由系统回收。&lt;br&gt;在C++中主要利用new在堆区开辟内存。&lt;br&gt;Eg:  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int *p = new int(10);   //小括号创建一个变量  
int *arr = new int[10];   //中括号表示申请多个变量  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;手动释放利用操作符delete。&lt;br&gt;Eg:    &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;delete p;   
delete[] arr;  //释放数组
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据结构-归并排序</title>
    <link href="http://peisenli.github.io/2019/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://peisenli.github.io/2019/09/18/数据结构-归并排序/</id>
    <published>2019-09-18T07:15:04.000Z</published>
    <updated>2019-09-18T11:34:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="归并排序和基数排序"><a href="#归并排序和基数排序" class="headerlink" title="归并排序和基数排序"></a>归并排序和基数排序</h3><p><strong>归并排序</strong>（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><ul><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列  </li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li>重复步骤3直到某一序列的指针达到序列尾</li><li><p>将另一序列剩下的所有元素直接复制到合并序列尾，一次归并结束</p><a id="more"></a><pre><code>int min(int x, int y) {    return x &lt; y ? x : y;}void merge_sort(int arr[], int len) {    int *a = arr;    int *b = (int *) malloc(len * sizeof(int));    int seg, start;    for (seg = 1; seg &lt; len; seg += seg) {        for (start = 0; start &lt; len; start += seg * 2) {            int low = start, mid = min(start + seg, len), high = min(start + seg * 2, len);            int k = low;            int start1 = low, end1 = mid;            int start2 = mid, end2 = high;            while (start1 &lt; end1 &amp;&amp; start2 &lt; end2)                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];            while (start1 &lt; end1)                b[k++] = a[start1++];            while (start2 &lt; end2)                b[k++] = a[start2++];        }        int *temp = a;        a = b;        b = temp;    }    if (a != arr) {        int i;        for (i = 0; i &lt; len; i++)            b[i] = a[i];        b = a;    }    free(b);}  </code></pre><p>是否稳定：true<br>平均时间复杂度：O(nlogn)<br>最差时间复杂度：O(nlogn)<br>最优时间复杂度：O(n)<br>空间复杂度：　　O(n)</p></li></ul><hr><p><strong>基数排序</strong>（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）上的贡献。<br>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。<br>基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。<br>排序过程：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。<br>基数排序法会使用到桶 (Bucket)，顾名思义，通过将要比较的位（个位、十位、百位…），将要排序的元素分配至 0~9 个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其它的比较性排序法<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt="图.jpg"></p><pre><code>#include&lt;stdio.h&gt;#define MAX 20//#define SHOWPASS#define BASE 10void print(int *a, int n) {  int i;  for (i = 0; i &lt; n; i++) {    printf(&quot;%d\t&quot;, a[i]);  }}void radixsort(int *a, int n) {  int i, b[MAX], m = a[0], exp = 1;  for (i = 1; i &lt; n; i++)     {        if (a[i] &gt; m) {          m = a[i];        }      }  while (m / exp &gt; 0) {    int bucket[BASE] = { 0 };    for (i = 0; i &lt; n; i++) {      bucket[(a[i] / exp) % BASE]++;    }    for (i = 1; i &lt; BASE; i++) {      bucket[i] += bucket[i - 1];    }    for (i = n - 1; i &gt;= 0; i--) {      b[--bucket[(a[i] / exp) % BASE]] = a[i];    }    for (i = 0; i &lt; n; i++) {      a[i] = b[i];    }    exp *= BASE;#ifdef SHOWPASS    printf(&quot;\nPASS   : &quot;);    print(a, n);#endif  }}int main() {  int arr[MAX];  int i, n;  printf(&quot;Enter total elements (n &lt;= %d) : &quot;, MAX);  scanf(&quot;%d&quot;, &amp;n);  n = n &lt; MAX ? n : MAX;  printf(&quot;Enter %d Elements : &quot;, n);  for (i = 0; i &lt; n; i++) {    scanf(&quot;%d&quot;, &amp;arr[i]);  }  printf(&quot;\nARRAY  : &quot;);  print(&amp;arr[0], n);  radixsort(&amp;arr[0], n);  printf(&quot;\nSORTED : &quot;);  print(&amp;arr[0], n);  printf(&quot;\n&quot;);  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;归并排序和基数排序&quot;&gt;&lt;a href=&quot;#归并排序和基数排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序和基数排序&quot;&gt;&lt;/a&gt;归并排序和基数排序&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;归并排序&lt;/strong&gt;（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列  &lt;/li&gt;
&lt;li&gt;设定两个指针，最初位置分别为两个已经排序序列的起始位置&lt;/li&gt;
&lt;li&gt;比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置&lt;/li&gt;
&lt;li&gt;重复步骤3直到某一序列的指针达到序列尾&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将另一序列剩下的所有元素直接复制到合并序列尾，一次归并结束&lt;/p&gt;
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://peisenli.github.io/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-选择排序</title>
    <link href="http://peisenli.github.io/2019/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://peisenli.github.io/2019/09/18/数据结构-选择排序/</id>
    <published>2019-09-18T07:13:40.000Z</published>
    <updated>2019-09-18T11:34:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据结构-选择排序"><a href="#数据结构-选择排序" class="headerlink" title="数据结构-选择排序"></a>数据结构-选择排序</h3><p><strong>选择排序</strong>（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。<br><strong>简单选择排序：</strong><br>该算法的实现思想为：对于具有 n 个记录的无序表遍历 n-1 次，第 i 次从无序表中第 i 个记录开始，找出后序关键字中最小的记录，然后放置在第 i 的位置上。<br>例如对无序表{56，12，80，91，20}采用简单选择排序算法进行排序，具体过程为：<br>第一次遍历时，从下标为 1 的位置即 56 开始，找出关键字值最小的记录 12，同下标为 0 的关键字 56 交换位置：<br>{12，56，80，91，20}<br>第二次遍历时，从下标为 2 的位置即 56 开始，找出最小值 20，同下标为 2 的关键字 56 互换位置：<br>{12，20，80，91，56}<br>第三次遍历时，从下标为 3 的位置即 80 开始，找出最小值 56，同下标为 3 的关键字 80 互换位置：<br>{12，20，56，91，80}<br>第四次遍历时，从下标为 4 的位置即 91 开始，找出最小是 80，同下标为 4 的关键字 91 互换位置：<br>{12，20，56，80，91}<br>到此简单选择排序算法完成，无序表变为有序表。<br><a id="more"></a></p><pre><code>void SelectSort(ElemTypr A[],int n){    for(i=0;i&lt;n-1;i++)    {        min=i;        for(j=i+1;j&lt;n;j++)            if(A[j]&lt;A[min]) min=j;        if(min!=j)            swap(A[i],A[min]);    }}</code></pre><hr><p><strong>堆排序：</strong>若以升序排序说明，把数组转换成最大堆积(Max-Heap Heap)，这是一种满足最大堆积性质(Max-Heap Property)的二叉树：对于除了根之外的每个节点i, A[parent(i)] ≥ A[i]。<br>重复从最大堆积取出数值最大的结点(把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并让残余的堆积维持最大堆积性质。<br>通常堆是通过一维数组来实现的。在数组起始位置为0的情形中：<br>父节点i的左子节点在位置(2i+1);<br>父节点i的右子节点在位置(2i+2);<br>子节点i的父节点在位置floor((i-1)/2);<br>在堆的数据结构中，堆中的最大值总是位于根节点（在优先队列中使用堆的话堆中的最小值位于根节点）。堆中定义以下几种操作：<br>最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点<br>创建最大堆（Build Max Heap）：将堆中的所有数据重新排序<br>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算  </p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void swap(int *a, int *b) {    int temp = *b;    *b = *a;    *a = temp;}void max_heapify(int arr[], int start, int end) {    // 建立父節點指標和子節點指標    int dad = start;    int son = dad * 2 + 1;    while (son &lt;= end) { // 若子節點指標在範圍內才做比較        if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1]) // 先比較兩個子節點大小，選擇最大的            son++;        if (arr[dad] &gt; arr[son]) //如果父節點大於子節點代表調整完畢，直接跳出函數            return;        else { // 否則交換父子內容再繼續子節點和孫節點比较            swap(&amp;arr[dad], &amp;arr[son]);            dad = son;            son = dad * 2 + 1;        }    }}void heap_sort(int arr[], int len) {    int i;    // 初始化，i從最後一個父節點開始調整    for (i = len / 2 - 1; i &gt;= 0; i--)        max_heapify(arr, i, len - 1);    // 先將第一個元素和已排好元素前一位做交換，再重新調整，直到排序完畢    for (i = len - 1; i &gt; 0; i--) {        swap(&amp;arr[0], &amp;arr[i]);        max_heapify(arr, 0, i - 1);    }}int main() {    int arr[] = { 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 };    int len = (int) sizeof(arr) / sizeof(*arr);    heap_sort(arr, len);    int i;    for (i = 0; i &lt; len; i++)        printf(&quot;%d &quot;, arr[i]);    printf(&quot;\n&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据结构-选择排序&quot;&gt;&lt;a href=&quot;#数据结构-选择排序&quot; class=&quot;headerlink&quot; title=&quot;数据结构-选择排序&quot;&gt;&lt;/a&gt;数据结构-选择排序&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;选择排序&lt;/strong&gt;（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。&lt;br&gt;&lt;strong&gt;简单选择排序：&lt;/strong&gt;&lt;br&gt;该算法的实现思想为：对于具有 n 个记录的无序表遍历 n-1 次，第 i 次从无序表中第 i 个记录开始，找出后序关键字中最小的记录，然后放置在第 i 的位置上。&lt;br&gt;例如对无序表{56，12，80，91，20}采用简单选择排序算法进行排序，具体过程为：&lt;br&gt;第一次遍历时，从下标为 1 的位置即 56 开始，找出关键字值最小的记录 12，同下标为 0 的关键字 56 交换位置：&lt;br&gt;{12，56，80，91，20}&lt;br&gt;第二次遍历时，从下标为 2 的位置即 56 开始，找出最小值 20，同下标为 2 的关键字 56 互换位置：&lt;br&gt;{12，20，80，91，56}&lt;br&gt;第三次遍历时，从下标为 3 的位置即 80 开始，找出最小值 56，同下标为 3 的关键字 80 互换位置：&lt;br&gt;{12，20，56，91，80}&lt;br&gt;第四次遍历时，从下标为 4 的位置即 91 开始，找出最小是 80，同下标为 4 的关键字 91 互换位置：&lt;br&gt;{12，20，56，80，91}&lt;br&gt;到此简单选择排序算法完成，无序表变为有序表。&lt;br&gt;
    
    </summary>
    
    
      <category term="Data structure" scheme="http://peisenli.github.io/tags/Data-structure/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-交换排序</title>
    <link href="http://peisenli.github.io/2019/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/"/>
    <id>http://peisenli.github.io/2019/09/18/数据结构-交换排序/</id>
    <published>2019-09-18T07:11:58.000Z</published>
    <updated>2019-09-18T11:33:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据结构-交换排序"><a href="#数据结构-交换排序" class="headerlink" title="数据结构-交换排序"></a>数据结构-交换排序</h3><p>所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，交换排序的特点是：将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。<br><strong>冒泡排序（Bubble Sort）</strong>是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。<br>冒泡排序对n个项目需要O(n^2)的比较次数，且可以原地排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于包含大量的元素的数列排序是很没有效率的。<br>冒泡排序是与插入排序拥有相等的运行时间，但是两种算法在需要的交换次数却很大地不同。在最坏的情况，冒泡排序需要 O(n^2)次交换，而插入排序只要最多O(n)交换。冒泡排序的实现（类似下面）通常会对已经排序好的数列拙劣地运行O(n^2)，而插入排序在这个例子只需要O(n)个运算。因此很多现代的算法教科书避免使用冒泡排序，而用插入排序取代之。冒泡排序如果能在内部循环第一次运行时，使用一个旗标来表示有无需要交换的可能，也可以把最优情况下的复杂度降低到O(n)。在这个情况，已经排序好的数列就无交换的需要。若在每次走访数列时，把走访顺序反过来，也可以稍微地改进效率。有时候称为鸡尾酒排序，因为算法会从数列的一端到另一端之间穿梭往返。<br>冒泡排序算法的运作如下：  </p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><a id="more"></a><pre><code>#include &lt;stdio.h&gt;//交换 a 和 b 的位置的函数void swap(int *a, int *b);int main(){    int array[8] = {49,38,65,97,76,13,27,49};    int i, j;    int key;    //有多少记录，就需要多少次冒泡，当比较过程，所有记录都按照升序排列时，排序结束    for (i = 0; i &lt; 8; i++){        key=0;//每次开始冒泡前，初始化 key 值为 0        //每次起泡从下标为 0 开始，到 8-i 结束        for (j = 0; j+1&lt;8-i; j++){            if (array[j] &gt; array[j+1]){                key=1;                swap(&amp;array[j], &amp;array[j+1]);            }        }        //如果 key 值为 0，表明表中记录排序完成        if (key==0) {            break;        }    }    for (i = 0; i &lt; 8; i++){        printf(&quot;%d &quot;, array[i]);    }    return 0;}void swap(int *a, int *b){    int temp;    temp = *a;    *a = *b;    *b = temp;}</code></pre><p>时间复杂度：O(n^2)<br>空间复杂度：O(1)<br>稳定：是</p></li></ul><hr><p><strong>快速排序</strong>使用分治法（Divide and conquer）策略来把一个序列（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。<br>步骤为：  </p><ul><li>挑选基准值：从数列中挑出一个元素，称为“基准”（pivot）</li><li>分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成  </li><li>递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。</li><li><p>递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。</p><pre><code>void quicksort(int left, int right) {    int i, j, t, temp;    if(left &gt; right)        return;    temp = a[left]; //temp中存的就是基准数    i = left;    j = right;    while(i != j) { //顺序很重要，要先从右边开始找        while(a[j] &gt;= temp &amp;&amp; i &lt; j)            j--;        while(a[i] &lt;= temp &amp;&amp; i &lt; j)//再找右边的            i++;               if(i &lt; j)//交换两个数在数组中的位置        {            t = a[i];            a[i] = a[j];            a[j] = t;        }    }    //最终将基准数归位    a[left] = a[i];    a[i] = temp;    quicksort(left, i-1);//继续处理左边的，这里是一个递归的过程    quicksort(i+1, right);//继续处理右边的 ，这里是一个递归的过程}</code></pre><p>时间复杂度：O(logn)<br>空间复杂度：O(nlogn)<br>稳定：否</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据结构-交换排序&quot;&gt;&lt;a href=&quot;#数据结构-交换排序&quot; class=&quot;headerlink&quot; title=&quot;数据结构-交换排序&quot;&gt;&lt;/a&gt;数据结构-交换排序&lt;/h3&gt;&lt;p&gt;所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，交换排序的特点是：将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。&lt;br&gt;&lt;strong&gt;冒泡排序（Bubble Sort）&lt;/strong&gt;是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。&lt;br&gt;冒泡排序对n个项目需要O(n^2)的比较次数，且可以原地排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于包含大量的元素的数列排序是很没有效率的。&lt;br&gt;冒泡排序是与插入排序拥有相等的运行时间，但是两种算法在需要的交换次数却很大地不同。在最坏的情况，冒泡排序需要 O(n^2)次交换，而插入排序只要最多O(n)交换。冒泡排序的实现（类似下面）通常会对已经排序好的数列拙劣地运行O(n^2)，而插入排序在这个例子只需要O(n)个运算。因此很多现代的算法教科书避免使用冒泡排序，而用插入排序取代之。冒泡排序如果能在内部循环第一次运行时，使用一个旗标来表示有无需要交换的可能，也可以把最优情况下的复杂度降低到O(n)。在这个情况，已经排序好的数列就无交换的需要。若在每次走访数列时，把走访顺序反过来，也可以稍微地改进效率。有时候称为鸡尾酒排序，因为算法会从数列的一端到另一端之间穿梭往返。&lt;br&gt;冒泡排序算法的运作如下：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比较相邻的元素。如果第一个比第二个大，就交换他们两个。&lt;/li&gt;
&lt;li&gt;对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。&lt;/li&gt;
&lt;li&gt;针对所有的元素重复以上的步骤，除了最后一个。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Data structure" scheme="http://peisenli.github.io/tags/Data-structure/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-插入排序</title>
    <link href="http://peisenli.github.io/2019/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://peisenli.github.io/2019/09/18/数据结构-插入排序/</id>
    <published>2019-09-18T03:12:51.000Z</published>
    <updated>2019-09-18T05:53:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>插入排序</strong>（Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用inplace排序（即只需用到 O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。<br><strong>直接插入排序：</strong>    </p><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li><p>重复步骤2~5  </p><pre><code>void Insertionsort(int arr[], int len){        int i,j,key;        for (i=1;i&lt;len;i++){                key = arr[i];                j=i-1;                while((j&gt;=0) &amp;&amp; (arr[j]&gt;key)) {                        arr[j+1] = arr[j];                        j--;                }                arr[j+1] = key;        }}</code></pre><p>时间复杂度：O(n^2)<br>空间复杂度：O(1)<br>稳定：是<br>适用：顺序存储和链式存储的线性表  </p><a id="more"></a></li></ol><hr><p><strong>折半插入排序：</strong><br>折半插入排序（binary insertion sort）是对插入排序算法的一种改进，由于排序算法过程中，就是不断的依次将元素插入前面已排好序的序列中。由于前半部分为已排好序的数列，这样我们不用按顺序依次寻找插入点，可以采用折半查找的方法来加快寻找插入点的速度。<br>（1） 将一新的元素插入到有序数组中，寻找插入点时，将带插区域的首元素设置为a[low],末元素设置为a[high],比较时则将待插元素与参考元素a[m]（m=(low+high)/2）相比较。；<br>（2）如果待插元素比参考元素小，则选择a[low]到a[m-1]为新的插入区域（即high=m-1）,否则选择a[m+1]到a[high]为插入区域；<br>（3）如此直到low&lt;=high不成立，即将此位置(low)之后所有元素后移一位，并将新元素插入a[high+1]中。  </p><pre><code>void BInsertSort(int a[],int size){    int i,j,low = 0,high = 0,mid;    int temp = 0;    for (i=1; i&lt;size; i++) {        low=0;        high=i-1;        temp=a[i];        //采用折半查找法判断插入位置，最终变量 low 表示插入位置        while (low&lt;=high) {            mid=(low+high)/2;            if (a[mid]&gt;temp) {                high=mid-1;            }            else{                low=mid+1;            }        }        //有序表中插入位置后的元素统一后移        for (j=i; j&gt;low; j--) {            a[j]=a[j-1];        }        a[low]=temp;//插入元素    }}</code></pre><p>时间复杂度：O(n^2)  </p><hr><p><strong>希尔排序：</strong><br>希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。<br>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。<br>步长取值：d1=n/2 di+1=di/2<br><img src="https://i.loli.net/2019/09/18/QfVThLPImHFqrpE.png" alt="1024555_20161128110416068_1421707828.png">    </p><pre><code>void shell_sort(int arr[], int len) {    int gap, i, j;    int temp;    for (gap = len &gt;&gt; 1; gap &gt; 0; gap &gt;&gt;= 1)        for (i = gap; i &lt; len; i++) {            temp = arr[i];            for (j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap)                arr[j + gap] = arr[j];            arr[j + gap] = temp;        }}</code></pre><p>时间复杂度： O(n^(1.3—2))<br>空间复杂度： O(1)<br>稳定性： 不稳定  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;插入排序&lt;/strong&gt;（Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用inplace排序（即只需用到 O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。&lt;br&gt;&lt;strong&gt;直接插入排序：&lt;/strong&gt;    &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从第一个元素开始，该元素可以认为已经被排序&lt;/li&gt;
&lt;li&gt;取出下一个元素，在已经排序的元素序列中从后向前扫描&lt;/li&gt;
&lt;li&gt;如果该元素（已排序）大于新元素，将该元素移到下一位置&lt;/li&gt;
&lt;li&gt;重复步骤3，直到找到已排序的元素小于或者等于新元素的位置&lt;/li&gt;
&lt;li&gt;将新元素插入到该位置后&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重复步骤2~5  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void Insertionsort(int arr[], int len){
        int i,j,key;
        for (i=1;i&amp;lt;len;i++){
                key = arr[i];
                j=i-1;
                while((j&amp;gt;=0) &amp;amp;&amp;amp; (arr[j]&amp;gt;key)) {
                        arr[j+1] = arr[j];
                        j--;
                }
                arr[j+1] = key;
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;时间复杂度：O(n^2)&lt;br&gt;空间复杂度：O(1)&lt;br&gt;稳定：是&lt;br&gt;适用：顺序存储和链式存储的线性表  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Data struct" scheme="http://peisenli.github.io/tags/Data-struct/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode121-买卖股票最佳的时期</title>
    <link href="http://peisenli.github.io/2019/09/11/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E7%9A%84%E6%97%B6%E6%9C%9F/"/>
    <id>http://peisenli.github.io/2019/09/11/LeetCode121-买卖股票最佳的时期/</id>
    <published>2019-09-11T14:12:13.000Z</published>
    <updated>2019-09-11T14:22:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。<br>注意你不能在买入股票前卖出股票。<br>示例 1:<br>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。<br>示例 2:<br>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。<br>思路：<br>题意要求先买在卖，找到利润最大的卖卖方案。<br>按时间顺序，从前到后遍历股票价格数组prices，每次迭代做两件事：<br>统计直至目前的最低成本cost，因为今日卖出的利润等于今日price减去前几日的price最小值（即最小成本）；<br>计算直至目前的最高利润profit 。<br>最终，返回最高利润profit。<br><a id="more"></a></p><pre><code>class Solution(object):    def maxProfit(self, prices):        &quot;&quot;&quot;        :type prices: List[int]        :rtype: int        &quot;&quot;&quot;        minprice = float(&apos;Inf&apos;)  #初始化最小值        maxprofit = 0        for  i in range(len(prices)):            if (prices[i] &lt; minprice):  #找出最小值                minprice = prices[i]            elif (prices[i] - minprice &gt; maxprofit): #寻找利润最大点                maxprofit = prices[i] - minprice                return maxprofit;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;br&gt;如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。&lt;br&gt;注意你不能在买入股票前卖出股票。&lt;br&gt;示例 1:&lt;br&gt;输入: [7,1,5,3,6,4]&lt;br&gt;输出: 5&lt;br&gt;解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。&lt;br&gt;注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。&lt;br&gt;示例 2:&lt;br&gt;输入: [7,6,4,3,1]&lt;br&gt;输出: 0&lt;br&gt;解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。&lt;br&gt;思路：&lt;br&gt;题意要求先买在卖，找到利润最大的卖卖方案。&lt;br&gt;按时间顺序，从前到后遍历股票价格数组prices，每次迭代做两件事：&lt;br&gt;统计直至目前的最低成本cost，因为今日卖出的利润等于今日price减去前几日的price最小值（即最小成本）；&lt;br&gt;计算直至目前的最高利润profit 。&lt;br&gt;最终，返回最高利润profit。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode88-合并两个有序数组</title>
    <link href="http://peisenli.github.io/2019/09/10/LeetCode88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://peisenli.github.io/2019/09/10/LeetCode88-合并两个有序数组/</id>
    <published>2019-09-10T11:39:09.000Z</published>
    <updated>2019-09-10T11:48:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。<br>说明:<br>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>示例:<br>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3<br>输出: [1,2,2,3,5,6]<br>思路一：追加后使用sort排序</p><pre><code>class Solution(object):    def merge(self, nums1, m, nums2, n):        nums1[m:] = nums2        return nums1.sort()</code></pre><a id="more"></a><p>思路二：从有序数组尾部进行比较，然后在长数组尾部进行写入，注意问题：数组越界及元素个数为0的数组</p><pre><code>class Solution(object):    def merge(self, nums1, m, nums2, n):        &quot;&quot;&quot;        :type nums1: List[int]        :type m: int        :type nums2: List[int]        :type n: int        :rtype: None Do not return anything, modify nums1 in-place instead.        &quot;&quot;&quot;        p1 = m - 1        p2 = n - 1        # set pointer for nums1        p = m + n - 1        # while there are still elements to compare        while p1 &gt;= 0 and p2 &gt;= 0:            if nums1[p1] &lt; nums2[p2]:                nums1[p] = nums2[p2]                p2 -= 1            else:                nums1[p] =  nums1[p1]                p1 -= 1            p -= 1                # add missing elements from nums2        nums1[:p2 + 1] = nums2[:p2 + 1]</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。&lt;br&gt;说明:&lt;br&gt;初始化 nums1 和 nums2 的元素数量分别为 m 和 n。&lt;br&gt;你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。&lt;br&gt;示例:&lt;br&gt;输入:&lt;br&gt;nums1 = [1,2,3,0,0,0], m = 3&lt;br&gt;nums2 = [2,5,6],       n = 3&lt;br&gt;输出: [1,2,2,3,5,6]&lt;br&gt;思路一：追加后使用sort排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution(object):
    def merge(self, nums1, m, nums2, n):
        nums1[m:] = nums2
        return nums1.sort()
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode62-不同路径</title>
    <link href="http://peisenli.github.io/2019/09/09/LeetCode62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>http://peisenli.github.io/2019/09/09/LeetCode62-不同路径/</id>
    <published>2019-09-09T12:48:47.000Z</published>
    <updated>2019-09-09T12:52:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png" alt><br>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><p>说明：m 和 n 的值均不超过 100。</p><p>示例 1:</p><p>输入: m = 3, n = 2<br>输出: 3<br>解释:<br>从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li>向右 -&gt; 向右 -&gt; 向下</li><li>向右 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向右<br>示例 2:</li></ol><p>输入: m = 7, n = 3<br>输出: 28<br><a id="more"></a><br>思路：由已知的m和n可以求出初始位置[0][0]到每个位置的[m][n]二维数组任意一个位置的解法种类,同时最后一个位置的值也是答案;  </p><pre><code>class Solution(object):    def uniquePaths(self, m, n):        &quot;&quot;&quot;        :type m: int        :type n: int        :rtype: int        &quot;&quot;&quot;        dp = [[1]*n] + [[1]+[0] * (n-1) for _ in range(m-1)]        #print(dp)        for i in range(1, m):            for j in range(1, n):                dp[i][j] = dp[i-1][j] + dp[i][j-1]        return dp[-1][-1]</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。&lt;/p&gt;
&lt;p&gt;问总共有多少条不同的路径？&lt;br&gt;&lt;img src=&quot;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png&quot; alt&gt;&lt;br&gt;例如，上图是一个7 x 3 的网格。有多少可能的路径？&lt;/p&gt;
&lt;p&gt;说明：m 和 n 的值均不超过 100。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: m = 3, n = 2&lt;br&gt;输出: 3&lt;br&gt;解释:&lt;br&gt;从左上角开始，总共有 3 条路径可以到达右下角。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;向右 -&amp;gt; 向右 -&amp;gt; 向下&lt;/li&gt;
&lt;li&gt;向右 -&amp;gt; 向下 -&amp;gt; 向右&lt;/li&gt;
&lt;li&gt;向下 -&amp;gt; 向右 -&amp;gt; 向右&lt;br&gt;示例 2:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;输入: m = 7, n = 3&lt;br&gt;输出: 28&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode59-旋转矩阵②</title>
    <link href="http://peisenli.github.io/2019/09/07/LeetCode59-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%E2%91%A1/"/>
    <id>http://peisenli.github.io/2019/09/07/LeetCode59-旋转矩阵②/</id>
    <published>2019-09-07T12:22:51.000Z</published>
    <updated>2019-09-09T12:52:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。<br>示例:<br>输入: 3<br>输出:<br>[<br> [ 1, 2, 3 ],<br> [ 8, 9, 4 ],<br> [ 7, 6, 5 ]<br>]<br><a id="more"></a><br>还是模拟过程,控制好边界<br>行的上下边界, 列的左右边界!即可<br>时间复杂度: O(n^2)</p><pre><code>class Solution:    def generateMatrix(self, n: int) -&gt; List[List[int]]:        above_row = 0        below_row = n - 1        left_col = 0        right_col = n - 1        res = [ [0] * n for _ in range(n) ]        num = 1        while above_row &lt;= below_row and left_col &lt;= right_col:            # 从左到右            for i in range(left_col, right_col+1):                res[above_row][i] = num                num += 1            # 上行加1            above_row += 1            # 从上到下            for i in range(above_row, below_row+1):                res[i][right_col] = num                num += 1            right_col -= 1            # 从右到左            for i in range(right_col, left_col-1, -1):                res[below_row][i] = num                num += 1            below_row -= 1            #从下到上            for i in range(below_row, above_row-1, -1):                res[i][left_col] = num                num += 1            left_col += 1        return res</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。&lt;br&gt;示例:&lt;br&gt;输入: 3&lt;br&gt;输出:&lt;br&gt;[&lt;br&gt; [ 1, 2, 3 ],&lt;br&gt; [ 8, 9, 4 ],&lt;br&gt; [ 7, 6, 5 ]&lt;br&gt;]&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode54-旋转矩阵</title>
    <link href="http://peisenli.github.io/2019/09/07/LeetCode54-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/"/>
    <id>http://peisenli.github.io/2019/09/07/LeetCode54-旋转矩阵/</id>
    <published>2019-09-07T11:15:25.000Z</published>
    <updated>2019-09-09T12:21:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。<br>示例 1:<br>输入:<br>[<br> [ 1, 2, 3 ],<br> [ 4, 5, 6 ],<br> [ 7, 8, 9 ]<br>]<br>输出: [1,2,3,6,9,8,7,4,5]<br>示例 2:<br>输入:<br>[<br>  [1, 2, 3, 4],<br>  [5, 6, 7, 8],<br>  [9,10,11,12]<br>]<br>输出: [1,2,3,4,8,12,11,10,9,5,6,7]<br><a id="more"></a><br>思路：每次取数组的第一行添加到列表中后将数组进行逆时针旋转，进行迭代操作。</p><pre><code>class Solution(object):    def spiralOrder(self, matrix):        &quot;&quot;&quot;        :type matrix: List[List[int]]        :rtype: List[int]        &quot;&quot;&quot;        # 取首行，去除首行后，对矩阵翻转来创建新的矩阵，        # 再递归直到新矩阵为[],退出并将取到的数据返回        ret = []        if matrix == []:            return ret        ret.extend(matrix[0]) # 上侧\#        print(ret)        new = [reversed(i) for i in matrix[1:]] #反转迭代器        if new == []:            return ret        r = self.spiralOrder([i for i in zip(*new)])        ret.extend(r)        return ret</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。&lt;br&gt;示例 1:&lt;br&gt;输入:&lt;br&gt;[&lt;br&gt; [ 1, 2, 3 ],&lt;br&gt; [ 4, 5, 6 ],&lt;br&gt; [ 7, 8, 9 ]&lt;br&gt;]&lt;br&gt;输出: [1,2,3,6,9,8,7,4,5]&lt;br&gt;示例 2:&lt;br&gt;输入:&lt;br&gt;[&lt;br&gt;  [1, 2, 3, 4],&lt;br&gt;  [5, 6, 7, 8],&lt;br&gt;  [9,10,11,12]&lt;br&gt;]&lt;br&gt;输出: [1,2,3,4,8,12,11,10,9,5,6,7]&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode33-搜索旋转排序数组</title>
    <link href="http://peisenli.github.io/2019/09/06/LeetCode33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://peisenli.github.io/2019/09/06/LeetCode33-搜索旋转排序数组/</id>
    <published>2019-09-06T11:05:35.000Z</published>
    <updated>2019-09-09T11:10:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。<br>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。<br>你可以假设数组中不存在重复的元素。<br>你的算法时间复杂度必须是 O(log n) 级别。<br>示例 1:<br>输入: nums = [4,5,6,7,0,1,2], target = 0<br>输出: 4<br>示例 2:<br>输入: nums = [4,5,6,7,0,1,2], target = 3<br>输出: -1<br><a id="more"></a><br>Python代码<br>偷懒版本：  </p><pre><code>class Solution(object):    def search(self, nums, target):        &quot;&quot;&quot;        :type nums: List[int]        :type target: int        :rtype: int        &quot;&quot;&quot;        if target in nums:            return nums.index(target)        return -1</code></pre><p>思路：二分查找<br>1、中间元素和“左边界”、“右边界”比较；<br>2、中间元素选择“靠左的中间元素”、“靠右的中间元素”。  </p><pre><code>class Solution(object):    def search(self, nums, target):        &quot;&quot;&quot;        :type nums: List[int]        :type target: int        :rtype: int        &quot;&quot;&quot;        if not nums:            return -1        n = len(nums)        l, r = 0, len(nums) - 1        while l &lt;= r:            m = (l + r) // 2            if nums[m] == target:                return m            elif nums[l] &lt;= nums[m]:                if nums[l] &lt;= target &lt;= nums[m]:                    r = m                else:                    l = m + 1            else:                if nums[m] &lt;= target &lt;= nums[r]:                    l = m                else:                    r = m - 1        return -1</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;br&gt;( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。&lt;br&gt;搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。&lt;br&gt;你可以假设数组中不存在重复的元素。&lt;br&gt;你的算法时间复杂度必须是 O(log n) 级别。&lt;br&gt;示例 1:&lt;br&gt;输入: nums = [4,5,6,7,0,1,2], target = 0&lt;br&gt;输出: 4&lt;br&gt;示例 2:&lt;br&gt;输入: nums = [4,5,6,7,0,1,2], target = 3&lt;br&gt;输出: -1&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-静态表查找</title>
    <link href="http://peisenli.github.io/2019/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%99%E6%80%81%E8%A1%A8%E6%9F%A5%E6%89%BE/"/>
    <id>http://peisenli.github.io/2019/09/06/数据结构-静态表查找/</id>
    <published>2019-09-06T06:19:06.000Z</published>
    <updated>2020-09-02T12:20:57.743Z</updated>
    
    <content type="html"><![CDATA[<h3 id="静态表查找"><a href="#静态表查找" class="headerlink" title="静态表查找"></a>静态表查找</h3><ol><li><p>顺序查找<br>核心：从数据的第一个元素开始，依次比较，直到找到目标数据或查找失败。  </p><ul><li>从表中的第一个元素开始，依次与关键字比较           </li><li>若某个元素匹配关键字，则 查找成功。</li><li><p>若查找到最后一个元素还未匹配关键字，则 查找失败。<br>特点：顺序查找平均关键字匹配次数为表长的一半，其时间复杂度为O(n),顺序查找的优点是对表无要求，插入数据可在O(1)内完成。缺点是时间复杂度较大，数据规模较大时，效率较低。  </p><a id="more"></a><p>实例代码：</p><pre><code>#include&lt;iostream&gt;using namespace std;struct LNode {    int Element[100];    int Length; };int SequentialSearch(LNode *Tbl, int K){       int i;    Tbl -&gt; Element[0] = K;    for(i = Tbl-&gt;Length; Tbl-&gt;Element[i] != K; i--);    return i;}int main(){    LNode test = { {0,1,2,3,4,5,6,7,8,9}, 9};//待比较数据从第二个开始，第一个位置用来设置哨兵     int result, num = 8;    result = SequentialSearch(&amp;test, num);    if(result == 0)        cout&lt;&lt;&quot;没找到！&quot;&lt;&lt;endl;    else        cout&lt;&lt;&quot;在m[&quot;&lt;&lt;result&lt;&lt;&quot;]里找到&quot;&lt;&lt;num-2 &lt;&lt;endl;    system(&quot;pause&quot;);    return 0;}</code></pre></li></ul></li><li><p>折半查找<br>仅适用有序表<br>首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。  </p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define keyType inttypedef struct {    keyType key;//查找表中每个数据元素的值    //如果需要，还可以添加其他属性}ElemType;typedef struct{    ElemType *elem;//存放查找表中数据元素的数组    int length;//记录查找表中数据的总数量}SSTable;//创建查找表void Create(SSTable **st,int length){    (*st)=(SSTable*)malloc(sizeof(SSTable));    (*st)-&gt;length=length;    printf(&quot;输入表中的数据元素：\n&quot;);    //根据查找表中数据元素的总长度，在存储时，从数组下标为 1 的空间开始存储数据    for (int i=1; i&lt;=length; i++) {        scanf(&quot;%d&quot;,&amp;((*st)-&gt;elem[i].key));    }}int Search_Bin(SSTable *ST,keyType key){    int low=1;//初始状态 low 指针指向第一个关键字    int high=ST-&gt;length;//high 指向最后一个关键字    int mid;    while (low&lt;=high) {        mid=(low+high)/2;//int 本身为整形，所以，mid 每次为取整的整数        if (ST-&gt;elem[mid].key==key)//如果 mid 指向的同要查找的相等，返回 mid 所指向的位置        {            return mid;        }else if(ST-&gt;elem[mid].key&gt;key)//如果mid指向的关键字较大，则更新 high 指针的位置        {            high=mid-1;        }        //反之，则更新 low 指针的位置        else{            low=mid+1;        }    }    return 0;}int main(int argc, const char * argv[]) {    SSTable *st;    Create(&amp;st, 11);    getchar();    printf(&quot;请输入查找数据的关键字：\n&quot;);    int key;    scanf(&quot;%d&quot;,&amp;key);    int location=Search_Bin(st, key);    //如果返回值为 0，则证明查找表中未查到 key 值，    if (location==0) {        printf(&quot;查找表中无该元素&quot;);    }else{        printf(&quot;数据在查找表中的位置为：%d&quot;,location);    }    return 0;}</code></pre><p>折半查找过程可用二叉树描述：结点表示记录，其值为该记录在表中位置，比较一次的作为根，比较两次放在第二层，依次类推，得到的二叉树称为判定树。<br>n个元素表的折半查找判定树是唯一的，即：判定树由表中元素个数决定。<br>找到表中任一记录的过程就是走了一条从根结点到与该记录相应的结点的路径。<br>比较的关键字个数：该结点在判定树上的层次数。<br>⑴ 当n=0时，折半查找判定树为空；<br>⑵ 当n＞0时，折半查找判定树的根结点是有序表中序号为mid=(n+1)/2的记录，根结点的左子树是与有序表r[1] ~ r[mid-1]相对应的折半查找判定树，根结点的右子树是与r[mid+1] ~ r[n]相对应的折半查找判定树。<br>查找成功：在表中查找任一记录的过程，即是折半查找判定树中从根结点到该记录结点的路径，和给定值的比较次数等于该记录结点在树中的层数。<br>查找不成功：查找失败的过程就是走了一条从根结点到外部结点的路径，和给定值进行的关键码的比较次数等于该路径上内部结点的个数。  </p></li><li><p>分块查找<br>分块查找又称索引顺序查找。这种查找方法中除了表本身以外尚需建立一个索引表。<br>索引表的构造过程：<br>要查找的表分成几个子表(称为块)。对每个子表建立一个索引项，其中包括两项内容：关键字项（存放该块中最大的关键字 ）指针项（存放该块中第一个记录的地址）。索引表中关键字递增有序，表中记录可以有序，也可以无序。但块之间一定有序（即后一块中的最小关键字都大于前一块中的最大关键字）。<br>查找表构成：<br>让数据分块有序，即分成若干子表（块），要求每个子表（块）中数据元素的关键字都比后一子表中数据元素的关键字小（但子表内部未必有序）。<br>将各子表中的最大关键字构成一个索引表，表中还要包含每个子表的起始地址（即头指针）。<br>① 由索引表确定关键字所在的区域，由于索引表是有序表，可以用折半查找法；<br>② 在顺序表的某个子表中查找关键字，各子表内部数据元素无序，只能采用顺序查找法；  </p><pre><code> typedef struct {       int key;    int start;    int len; }IDX; int blk_search(int a[],IDX idx[],int v,int m) {       int low=0,high=m-1,mid,i,h;    while(low&lt;=high)       {          mid=(low+high)/2;        if(v&lt;idx[mid].key)                 high=mid-1;        else if(v&gt;idx[mid].key)            low=mid+1;        else         {              low=mid;            break;           }    }     if(low&gt;=m)        return(-1);    i=idx[low].start;    h=i+idx[low].len;    while(i&lt;h&amp;&amp;a[i]!=v)          i++ ;    if(a[i]!=v) i=-l;        return(i);} </code></pre></li><li><p>二叉排序树<br>若二叉排序树为空，则查找失败，否则<br>（1）首先将根结点值与待查值进行比较，若相等，则查找成功。<br>（2）若根结点值大于待查值，则进入左子树重复此步骤，否则，进入右子树重复此步骤。<br>（3）若在查找过程中遇到二叉排序树的叶子结点时，还没有找到待查结点，则查找不成功。<br>递归函数 </p><pre><code>NODE *search(NODE t,char x){       if(t==NULL)        return(NULL);    else    {         if(t-&gt;data==x) return(t);        if(x&lt;(t-&gt;data) return(search(t-&gt;lchild,x));        else         return(search(t-&gt;rchild,x));     }}</code></pre><p>非递归函数</p><pre><code>NODE  *search(NODE *t,char x){       NODE *p;    p=t;    while(p!=NULL)    {         if(p-&gt;data==x)  return(p);        if(x&lt;p-&gt;data)   p=p-&gt;lchild;        else   p=p-&gt;rchlid;     }    printf(“ 找不到值为%x的结点!”,x);    return(NULL);} </code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;静态表查找&quot;&gt;&lt;a href=&quot;#静态表查找&quot; class=&quot;headerlink&quot; title=&quot;静态表查找&quot;&gt;&lt;/a&gt;静态表查找&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;顺序查找&lt;br&gt;核心：从数据的第一个元素开始，依次比较，直到找到目标数据或查找失败。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从表中的第一个元素开始，依次与关键字比较           &lt;/li&gt;
&lt;li&gt;若某个元素匹配关键字，则 查找成功。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;若查找到最后一个元素还未匹配关键字，则 查找失败。&lt;br&gt;特点：顺序查找平均关键字匹配次数为表长的一半，其时间复杂度为O(n),顺序查找的优点是对表无要求，插入数据可在O(1)内完成。缺点是时间复杂度较大，数据规模较大时，效率较低。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://peisenli.github.io/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode16-最接近的三数之和</title>
    <link href="http://peisenli.github.io/2019/09/04/LeetCode16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://peisenli.github.io/2019/09/04/LeetCode16-最接近的三数之和/</id>
    <published>2019-09-04T09:04:14.000Z</published>
    <updated>2019-09-04T09:08:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。<br>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.<br>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).<br><a id="more"></a><br>思路：<br>排序，遍历，双指针<br>排序是为了使用双指针，首先遍历得到索引 c，然后计算 c，左指针 i，右指针 j 对应数字之和，如果大于 target，j 向内移动，否则 i 向内移动   </p><pre><code>class Solution(object):def threeSumClosest(self, nums, target):    &quot;&quot;&quot;    :type nums: List[int]    :type target: int    :rtype: int    &quot;&quot;&quot;    n = len(nums)    nums.sort()    re_min = 0 #存储当前最小的差值    for i in range(len(nums)):        low = i+1        high = n-1        while low &lt; high:            three_sum = nums[i] + nums[low] + nums[high]            x = target - three_sum #当前三数的差值            if re_min == 0:                re_min = abs(x)                sum_min = three_sum #sum_min为当前最接近的和            if abs(x) &lt; re_min:                re_min = abs(x)                sum_min = three_sum            if three_sum == target:                return target            elif three_sum &lt; target:                low += 1            else:                high -=1    return sum_min</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。&lt;br&gt;例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.&lt;br&gt;与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode15-三数之和</title>
    <link href="http://peisenli.github.io/2019/09/03/LeetCode15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://peisenli.github.io/2019/09/03/LeetCode15-三数之和/</id>
    <published>2019-09-03T07:28:43.000Z</published>
    <updated>2019-09-04T08:14:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。<br>例如, 给定数组<br>nums = [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]<br><a id="more"></a><br>思路：</p><ul><li>先将数组进行排序</li><li>从左侧开始，选定一个值为 定值 ，右侧进行求解，获取与其相加为 0 的两个值</li><li><p>类似于快排，定义首和尾<br>首尾与 定值 相加<br>等于 00，记录这三个值<br>小于 00，首部右移<br>大于 00，尾部左移<br>定值右移，重复该步骤  </p><pre><code>class Solution(object):def threeSum(self, nums):    &quot;&quot;&quot;    :type nums: List[int]    :rtype: List[List[int]]    &quot;&quot;&quot;nums.sort()res =[]i = 0for i in range(len(nums)):    if i == 0 or nums[i]&gt;nums[i-1]:        l = i+1        r = len(nums)-1        while l &lt; r:            s = nums[i] + nums[l] +nums[r]            if s ==0:                res.append([nums[i],nums[l],nums[r]])                l +=1                r -=1                while l &lt; r and nums[l] == nums[l-1]:                    l += 1                while r &gt; l and nums[r] == nums[r+1]:                    r -= 1            elif s&gt;0:                r -=1            else :                l +=1return res</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。&lt;br&gt;注意：答案中不可以包含重复的三元组。&lt;br&gt;例如, 给定数组&lt;br&gt;nums = [-1, 0, 1, 2, -1, -4]，&lt;br&gt;满足要求的三元组集合为：&lt;br&gt;[&lt;br&gt;  [-1, 0, 1],&lt;br&gt;  [-1, -1, 2]&lt;br&gt;]&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode11-盛水最多的容器</title>
    <link href="http://peisenli.github.io/2019/09/02/LeetCode11-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>http://peisenli.github.io/2019/09/02/LeetCode11-盛水最多的容器/</id>
    <published>2019-09-02T09:19:44.000Z</published>
    <updated>2019-09-02T10:53:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>说明：你不能倾斜容器，且 n 的值至少为 2。<br><img src="https://i.loli.net/2019/09/02/eMRhmZK6SI9C2Lu.jpg" alt="question_11.jpg"><br>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。<br>示例:<br>输入: [1,8,6,2,5,4,8,3,7]<br>输出: 49<br><a id="more"></a><br>思路：采用暴力法简单地考虑每对可能出现的线段组合并找出这些情况之下的最大面积，但是在进行提交时出现运行超时。</p><pre><code>class Solution(object):    def maxArea(self, height):        &quot;&quot;&quot;        :type height: List[int]        :rtype: int        &quot;&quot;&quot;        MaxArea = 0        for i in range(0,len(height)):            for j in range(i+1,len(height)):                MaxArea = max(MaxArea,min(height[i],height[j])*(j-i))        return MaxArea</code></pre><p>双指针法<br>这种方法背后的思路在于，两线段之间形成的区域总是会受到其中较短那条长度的限制。此外，两线段距离越远，得到的面积就越大。<br>我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 此外，我们会使用变量 maxareamaxarea 来持续存储到目前为止所获得的最大面积。 在每一步中，我们会找出指针所指向的两条线段形成的区域，更新 maxareamaxarea，并将指向较短线段的指针向较长线段那端移动一步。  </p><pre><code>class Solution(object):    def maxArea(self, height):        &quot;&quot;&quot;        :type height: List[int]        :rtype: int        &quot;&quot;&quot;        MaxArea = 0        i = 0        j = len(height) - 1         while(i &lt; j):            MaxArea = max(MaxArea,min(height[i],height[j])*(j-i))            if height[i] &lt; height[j]:                i += 1            else:                j -= 1        return MaxArea</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。&lt;br&gt;说明：你不能倾斜容器，且 n 的值至少为 2。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2019/09/02/eMRhmZK6SI9C2Lu.jpg&quot; alt=&quot;question_11.jpg&quot;&gt;&lt;br&gt;图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。&lt;br&gt;示例:&lt;br&gt;输入: [1,8,6,2,5,4,8,3,7]&lt;br&gt;输出: 49&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode53-最大子序和</title>
    <link href="http://peisenli.github.io/2019/09/01/LeetCode53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <id>http://peisenli.github.io/2019/09/01/LeetCode53-最大子序和/</id>
    <published>2019-09-01T11:14:06.000Z</published>
    <updated>2019-09-01T11:22:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>示例:<br>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br><a id="more"></a><br>思路：<br>动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 ans<br>如果 sum &gt; 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字<br>如果 sum &lt;= 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字<br>每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果  </p><pre><code>class Solution(object):    def maxSubArray(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: int        &quot;&quot;&quot;        for i in range(1, len(nums)):            ans = max(nums[i-1], 0)            nums[i]= nums[i] + ans        return max(nums)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;br&gt;示例:&lt;br&gt;输入: [-2,1,-3,4,-1,2,1,-5,4],&lt;br&gt;输出: 6&lt;br&gt;解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode26-删除排序数组中的重复项</title>
    <link href="http://peisenli.github.io/2019/08/30/LeetCode26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>http://peisenli.github.io/2019/08/30/LeetCode26-删除排序数组中的重复项/</id>
    <published>2019-08-30T07:45:39.000Z</published>
    <updated>2019-08-30T07:49:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br>示例 1:<br>给定数组 nums = [1,1,2],<br>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。<br>你不需要考虑数组中超出新长度后面的元素。<br>示例 2:<br>给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br><strong>思路：</strong>用两个指针，指向第一个和第二个元素，如果他们相等，删除第二个元素。指针还指向原来的位置，继续比较。不等的话，两个指针位置都加一。遍历结束即可。<br><a id="more"></a></p><pre><code>class Solution(object):    def removeDuplicates(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: int        &quot;&quot;&quot;        if not nums:            return 0        j = 0        for i in range(1,len(nums)):            if nums[i] != nums[j]:                j += 1                nums[j] = nums[i]        return j+1        </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。&lt;br&gt;不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。&lt;br&gt;示例 1:&lt;br&gt;给定数组 nums = [1,1,2],&lt;br&gt;函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。&lt;br&gt;你不需要考虑数组中超出新长度后面的元素。&lt;br&gt;示例 2:&lt;br&gt;给定 nums = [0,0,1,1,1,2,2,3,3,4],&lt;br&gt;函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。&lt;br&gt;&lt;strong&gt;思路：&lt;/strong&gt;用两个指针，指向第一个和第二个元素，如果他们相等，删除第二个元素。指针还指向原来的位置，继续比较。不等的话，两个指针位置都加一。遍历结束即可。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://peisenli.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode4.寻找两个有序数组的中位数</title>
    <link href="http://peisenli.github.io/2019/08/29/LeetCode4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://peisenli.github.io/2019/08/29/LeetCode4-寻找两个有序数组的中位数/</id>
    <published>2019-08-29T09:30:32.000Z</published>
    <updated>2019-08-29T09:38:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。<br>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。<br>你可以假设 nums1 和 nums2 不会同时为空。<br>示例 1:<br>nums1 = [1, 3]<br>nums2 = [2]<br>则中位数是 2.0<br>示例 2:<br>nums1 = [1, 2]<br>nums2 = [3, 4]<br>则中位数是 (2 + 3)/2 = 2.5  </p><p><strong>思路：</strong>题目要求时间复杂度为O(log(m + n))。基本可以确定本题应该用二分查找，对于数组arr的中位数，如果数组长度为len，<br>len为奇数，则中位数为第（len+1）/2 位，如果len为偶数，我们需要知道第 len/2和 len/2+1 个数。<br><a id="more"></a></p><pre><code>class Solution(object):    def findMedianSortedArrays(self, A, B):        &quot;&quot;&quot;        :type nums1: List[int]        :type nums2: List[int]        :rtype: float        &quot;&quot;&quot;        m, n = len(A), len(B)        if m &gt; n:            A, B, m, n = B, A, n, m        if n == 0:            raise ValueError        imin, imax, half_len = 0, m, (m + n + 1) / 2        while imin &lt;= imax:            i = (imin + imax) / 2            j = half_len - i            if i &lt; m and B[j-1] &gt; A[i]:                # i is too small, must increase it                imin = i + 1            elif i &gt; 0 and A[i-1] &gt; B[j]:                # i is too big, must decrease it                imax = i - 1            else:                # i is perfect                if i == 0: max_of_left = B[j-1]                elif j == 0: max_of_left = A[i-1]                else: max_of_left = max(A[i-1], B[j-1])                if (m + n) % 2 == 1:                    return max_of_left                if i == m: min_of_right = B[j]                elif j == n: min_of_right = A[i]                else: min_of_right = min(A[i], B[j])                return (max_of_left + min_of_right) / 2.0</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。&lt;br&gt;请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。&lt;br&gt;你可以假设 nums1 和 nums2 不会同时为空。&lt;br&gt;示例 1:&lt;br&gt;nums1 = [1, 3]&lt;br&gt;nums2 = [2]&lt;br&gt;则中位数是 2.0&lt;br&gt;示例 2:&lt;br&gt;nums1 = [1, 2]&lt;br&gt;nums2 = [3, 4]&lt;br&gt;则中位数是 (2 + 3)/2 = 2.5  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;题目要求时间复杂度为O(log(m + n))。基本可以确定本题应该用二分查找，对于数组arr的中位数，如果数组长度为len，&lt;br&gt;len为奇数，则中位数为第（len+1）/2 位，如果len为偶数，我们需要知道第 len/2和 len/2+1 个数。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
