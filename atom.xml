<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>帅的如此过分</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://peisenli.github.io/"/>
  <updated>2019-07-13T12:22:27.544Z</updated>
  <id>http://peisenli.github.io/</id>
  
  <author>
    <name>空空</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Resume</title>
    <link href="http://peisenli.github.io/2019/07/13/Resume/"/>
    <id>http://peisenli.github.io/2019/07/13/Resume/</id>
    <published>2019-07-13T11:21:08.000Z</published>
    <updated>2019-07-13T12:22:27.544Z</updated>
    
    <content type="html"><![CDATA[<p><div style="float:right"><img src="https://i.loli.net/2019/07/06/5d2091a117fd054997.png" width="200"></div>   </p><h4 id="李培森"><a href="#李培森" class="headerlink" title="李培森"></a><span style="color:#e33a00"><strong>李培森</strong></span></h4><p><strong>硕士/重庆邮电大学/计算机科学与技术<br>本科/西北民族大学/电子信息工程<br>Github：<a href="http://github.com/peisenli" target="_blank" rel="noopener">http://github.com/peisenli</a> </strong><br><strong>Skill：多项大学生创新创业项目及电子类全国大学生竞赛经验</strong></p><h6 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a><span style="color:#fd3300"><strong>联系方式</strong></span></h6><p><strong>Email：<a href="mailto:peisenli1@gmail.com" target="_blank" rel="noopener">peisenli1@gmail.com</a><br>QQ：577602601<br>电话：17628090959</strong></p><hr><a id="more"></a><h3 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a><span style="color:#e33a00"><strong>项目经历</strong></span></h3><p><strong>• 2015年中央高校科研项目“移动式机械手臂的设计”<br>• 2015年大学生创新创业项目“基于MK60的智能车设计”<br>• 2016年大学生创新创业项目“基于STM32的智能探测机器”<br>• 2017年本科生科研项目“基于互联网语音技术的智能家居管理系统”</strong></p><hr><h3 id="获奖证书"><a href="#获奖证书" class="headerlink" title="获奖证书"></a><span style="color:#e33a00"><strong>获奖证书</strong></span></h3><p><strong>• 优秀学生干部<br>• 2015年中国机器人大赛旅游类二等奖<br>• “博创杯”全国大学生嵌入式大赛一等奖<br>• 2015年全国大学生电子设计大赛省一等奖<br>• 2016年中国机器人大赛水下巡游组一等奖<br>• 2016年中国机器人大赛擂台标准组二等奖</strong></p><hr><h3 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a><span style="color:#e33a00"><strong>专业技能</strong></span></h3><p><strong>• 熟练C/C++语言嵌入式程序设计<br>• 熟悉JAVA、Python、Android程序设计<br>• 熟练使用51单片机、MK60以及Cubieboard板卡<br>• 具有较强的专业英语阅读能力，轻松阅读国外专业相关文档<br>• 硬件检测员实习经验：需求设计测试用例，执行测试和收集测试结果，找出硬件问题并书写测试报告；发现并提出产品的功能和性能问题；</strong></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div style=&quot;float:right&quot;&gt;&lt;img src=&quot;https://i.loli.net/2019/07/06/5d2091a117fd054997.png&quot; width=&quot;200&quot;&gt;&lt;/div&gt;   &lt;/p&gt;
&lt;h4 id=&quot;李培森&quot;&gt;&lt;a href=&quot;#李培森&quot; class=&quot;headerlink&quot; title=&quot;李培森&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#e33a00&quot;&gt;&lt;strong&gt;李培森&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;硕士/重庆邮电大学/计算机科学与技术&lt;br&gt;本科/西北民族大学/电子信息工程&lt;br&gt;Github：&lt;a href=&quot;http://github.com/peisenli&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://github.com/peisenli&lt;/a&gt; &lt;/strong&gt;&lt;br&gt;&lt;strong&gt;Skill：多项大学生创新创业项目及电子类全国大学生竞赛经验&lt;/strong&gt;&lt;/p&gt;
&lt;h6 id=&quot;联系方式&quot;&gt;&lt;a href=&quot;#联系方式&quot; class=&quot;headerlink&quot; title=&quot;联系方式&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#fd3300&quot;&gt;&lt;strong&gt;联系方式&lt;/strong&gt;&lt;/span&gt;&lt;/h6&gt;&lt;p&gt;&lt;strong&gt;Email：&lt;a href=&quot;mailto:peisenli1@gmail.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;peisenli1@gmail.com&lt;/a&gt;&lt;br&gt;QQ：577602601&lt;br&gt;电话：17628090959&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="Resume" scheme="http://peisenli.github.io/tags/Resume/"/>
    
  </entry>
  
  <entry>
    <title>The application of machine learning in network security</title>
    <link href="http://peisenli.github.io/2019/07/13/The-application-of-machine-learning-in-network-security/"/>
    <id>http://peisenli.github.io/2019/07/13/The-application-of-machine-learning-in-network-security/</id>
    <published>2019-07-13T11:05:40.000Z</published>
    <updated>2019-07-13T12:21:33.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="机器学习在网络安全中的应用综述"><a href="#机器学习在网络安全中的应用综述" class="headerlink" title="机器学习在网络安全中的应用综述"></a>机器学习在网络安全中的应用综述</h2><p>摘要：随着互联网人口在线人数的增长，在互联网背景下各行业爆发了很多问题，例如信息的加密和治理，可疑的营销信息，特别是网络安全问题不断的锐化。机器学习和人工智能的诞生，对网络发展既是机遇也是挑战，它用于搜索引擎，图像分类，语音识别等，而利用网络上的安全问题融合机器学习算法，成为网络安全技术的一个新的研究领域，利用机器学习得到的模型和方法，对网络安全攻击行为自动进行判断和预测，进而进行防御，是非常具有利用前景和使用价值，本文是对当前机器学习在网络安全中的不同应用进行总结和概述。<br>关键词：机器学习 网络安全 入侵防御<br>Abstract: with the growth of the number of Internet online population, in the context of the Internet industry broke out a lot of problems, such as the encryption and governance of information, suspicious marketing information, especially the sharpening of network security issues. The birth of machine learning and artificial intelligence, is both opportunity and challenge of network development, which is used to search engine, image classification, speech recognition, etc., and the use of machine learning algorithm on the network security problem fusion, become a new research field of network security technology, using machine learning model and method of judgment and projections for network security attacks automatically, and defend, is very has the advantage of future and use value, this article is for the current machine learning summarize its application in network security.<br>Key words: machine learning; network security; defense<br><a id="more"></a><br>1.引言<br>网络安全问题的爆发在如今在大量用户使用下的背景下越来越引人关注，各种行业都没有实施足够的流程来确保的隐私和安全，被黑客攻击是相当普遍的，这并不奇怪。只需打开错误的电子邮件就可以捕获感染，在线信誉良好的公司共享信息可能会导致敏感的数据泄露，任何设备都可能成为僵尸网络中的僵尸而没有明显的迹象。对于这些问题的研究在大数据时代，人工智能、数据挖掘以及机器学习的相关内容不断发酵，为网络安全行为分析提供了很好的方法，对于机器学习驱动的安全算法在速度、准确性以及隐私安全方面得到了优化，速度方面机器学习训练此类算法比收集定义恶意行为者的规则要快得多，可以轻松分析大量数据; 因此可以提供更精确的结果并且还可以实现个性化。相比一些传统的方法，如深度包检测、DNS黑名单等，在模型建立之后不需要在对用户信息进行深度分析，优化了传统方法的隐私性。<br>机器学习技术以其独特的适应性、可扩展性和快速适应新挑战和未知挑战的潜力而被应用于科学中的许多领域。网络安全是一个快速发展的领域，在社交网络、云与web技术、网上银行、移动环境、智能电网等领域都取得了显著的进步，需要人们的高度关注。针对计算机安全领域中涉猎广泛的问题，人们成功地运用了多种机器学习方法用于解决计算机和信息安全方面的广泛问题。本文归纳了机器学习在网络安全中的不同应用。<br>2.机器学习概述<br>机器学习就是让计算机从数据中进行自动学习，得到某种知识。其通常指一类问题以及解决这类问题的方法，即如何从观测数据中寻找规律，并利用学习到的规律对未知或无法观测的数据进行预测。机器学习是对能通过经验自动改进的计算机算法的研究[1]。<br>机器学习算法可以分为线性模型和非线性模型；按照学习准则的不同，机器学习算法也可以分为统计方法和非统计方法。但一般来说，我们会按照训练样本提供的信息以及反馈方式的不同，将机器学习算法分为以下几类：<br>如果机器学习的目标是通过建模样本的特征x和标签y之间的关系： y = f(x, θ)，并且训练集中每个样本都有标签，那么这类机器学习称为监督学习。<br>无监督学习是指从不包含目标标签的训练样本中自动学习到一些有价值的信息。典型的无监督学习问题有聚类、 密度估计、特征学习、降维等。<br>强化学习是一类通过交互式来学习的机器学习算法。在强化学习中，智能体根据环境的状态做出一个动作，并得到即时或延时的奖励。智能体在和环境的交互中不断学习并调整策略，以取得最大化的期望总回报。<br>从机器学习的本质上来分析，广泛来讲机器学习是预测事物的过程，通常基于他们过去所做的事情。在大量数据集中的基础上通过对数学技术的引入，来构建机器行为模型，这个模型试图在您的数据中找到可以帮助您预测接下来会发生什么的关系。即机器在对各时段数据进行分析、运算的基础上，来实现对未来的科学预测。从技术上来讲，机器学习使用统计方法使用一组输入数据预测目标变量的值即尝试解决在给定特征集X的输入的情况下预测变量Y的值。这就是机器学习所研究的问题及内容。<br>机器学习在网络安全中应用主要体现在机器学习基于网络安全方面的数据进行分析，构建模型帮助用户来有效的对网络安全事件作出及时的响应，减少人力资料的浪费，更有助于清除产品中的恶意软件，进而确保网络系统的安全与稳定。<br>3.实际应用方法<br>3.1.网络安全中的应用<br>机器学习在网络安全中应用极为广泛，网络安全检测主要指对网络的安全状态或者面临的风险进行分析和检测，对不同接入网络的行为进行分析和控制，都需要用到机器学习算法，最后发现潜在的威胁或正在进行的攻击。机器学习技术在网络入侵检测技术、僵尸网络的检测以及恶意加密流量的识别中的研究都极其具有价值。<br>网络入侵检测系统用于识别导致网络中系统机密性、完整性或可用性受到破坏的恶意网络活动。许多入侵检测系统都是基于机器学习技术的，因为它们对新的未知攻击具有适应性。<br>在网络入侵检测中常用的机器学习算法包括神经网络、遗传算法、决策树以及支持向量机等[2]。对于机器学习算法主要的问题是对数据进行分析以及建立合适的模型，然后形成模型对未知问题进行处理，使用机器学习技术解决安全问题的第一步就是要进行问题的抽象和定义将安全问题映射为机器学习能够解决的分类、聚类及降维等问题[3]。<br>其主要问题在于应用这些算法需要有大量的数据，这些数据来自抽象的安全问题数据，如木马的检测、伪基站检测、虚拟化安全、信用卡欺诈、用户身份认证异常、恶意异常入侵检测、取证分析、网络舆情等一些结构化或者非结构化数据，要想应用到数据分析中还需要进行数据处理，数据清洗，得到结构化数据，简单来说就是保留最大的信息熵，维度较低的对分析有利的特征数据，这个过程就是提高数据的质量，保障构建模型学习的效果，对数据进行清洗及归一化等预处理过程，在这些安全问题数据构建模型前还需要进行大数据处理的基本其他数据分割、特征提取等步骤，之后处理后的数据才能构建模型[4]。模型构建是机器学习在网络安全应用的中心环节，这是算法实现的过程，也就是利用之前提及的机器学习方法进行实现，再利用中间构建的模型进行验证，根据评价标准投入使用，进行安全漏洞预测，常见的一下安全问题及处理方法如下图一所示。讲不同的安全入侵问题抽象成不同的处理方式，再利用相应的机器学习算法进行处理。<br><img src="https://i.loli.net/2019/05/12/5cd82f9828a2c.png" alt="图片1.png">  </p><p><center>图1 安全问题抽象  </center><br>目前在入侵检测中很多系统都是利用融合匹配度和遗传算法，对冗余规则进行裁剪，对有效规则进行过滤，在这种算法驱动的系统验证的时候可行性很高[5]。<br>上面所提及到的算法是现在最新的研究的一些基础支撑，在这之上还有许多改进的算法，传统支持向量机算法是利用已知标签的训练样本来进行预测或检测的监督学习算法. 与其他机器学习算法类似，传统方式也易受到利用系统来进行攻击的入侵者，文献[6]中提出了将博弈论与DSVM算法结合的网络入侵检测方法提高了正确性与性能。另外决策树和k邻近算法混合检测也是系统常用的机器学习算法，在网络安全问题抽象中，很多都是分类问题，对于这一方法的多分类问题也是网络安全研究的主要内容[7]。<br>而在现在较新的研究是将深度学习融入入侵检测，将入侵检测系统又提高了一个阶级。针对深度学习算法的安全检测，以及利用神经网络和支持向量机开发了一个针对分布式拒绝服务攻击的告警分类系统[9]，与集中式入侵检测系统相比，在训练数据不足的情况下，该方案的准确率较高。此外，所提出的方法声称可以减少能源消耗[10]。<br>基于神经网络的入侵检测方法中人工神经网络的灵感来自生物神经网络。它通过树突接收信号，并通过轴突进行输出。计算在核中进行，整个网络由一系列神经元组成，而深度学习中的每个神经元完成三个动作：一是以加权的方式累积来自各种其他神经元或输入的输入，第二个动作总结了所有输入信号，三是基于求和值，调用激活函数得到输出。这是神经网络的基本步骤，在文献[11]中进行了深度学习算法下的TOR匿名流量检测实验。<br>在进行流量检测中，对比各种分类器中，基于随机森林和深度学习的方法比其他方法表现更好，如表所示。此次实验中使用的数据集比典型的基于深度学习的系统要小。随着训练数据的增加，基于深度学习和随机森林分类器的性能将进一步提高。<br><img src="https://i.loli.net/2019/05/12/5cd82f97ebd04.png" alt="图片2.png">  </p><p><center> 表1 Tor流量检测实验 </center><br>僵尸网络由一系列被恶意软件感染的主机组成，受到一个被称为僵尸主控机远程控制。僵尸网络可以被用于执行一系列恶意活动，例如分布式拒绝服务攻击、发送垃圾邮件、窃取个人信息、执行分布式计算任务等[12]。从网络流量角度分析，僵尸网络的通信行为从流量角度分析具有一定的关联性和群体相似性，因此许多研究者通过聚类方法分析不同的网络流量特征，从而检测僵尸网络。<br>对于僵尸网络的检测，首先得进行特征提取，这些特征可以是网络流量特征，除了提取僵尸网络流量的流量特征外[13]，僵尸网络的通信行为往往和一些恶意事件在时间或空间上有关联。对于模型构建算法包括随机森林算法、随机游走聚类算法及自适应特征集和训练分类标签的LS-SVM算法[14]，都有很好的效果，但是对于目前日益增长的网络空间，对于其安全分析具有巨大挑战，因此随着僵尸网络传播、控制及攻击形式的多样化，如何对僵尸网络流量进行有效的特征提取、如何能够全面提高各种类型僵尸检测效率及精度，都是需要进一步深入研究的方向。<br>总的来说网络入侵检测、僵尸网络检测即根据网络流量数据或主机数据来判断系统的正常行为或异常行为，可以抽象为分类问题。根据入侵检测系统中检测引擎使用方法的不同，网络入侵检测分为误用检测、异常检测以及混合检测。误用检测是以已知攻击为特征，将入侵行为与异常行为按照已知的特征区分开来。而这些实现及算法都离不开机器学习，在目前的各种分类器中，基于随机森林和深度学习的方法的检测方法是值得研究的一个方向。<br>3.2.系统硬件及软件安全应用<br>系统硬件安全问题包括硬件设备身份认证安全问题、系统硬件与外部设备进行信息交换或通信时常常会遇到信息泄露、中间人攻击等问题，例如常见的物理层边信道攻击、伪基站， MAC地址伪造，而机器学习在硬件设备也有很广泛的 的应用。<br>设备身份认证技术是将信号分析与处理技术与机器学习技术相结合．目前该领域的相关研究成果主要基于暂态信号、调制信号、频谱响应以及传感器响应产生的指纹及人脸特征等其他生物特征进行设备身份识别，最大程度的确保了网络设备的硬件安全问题。现有的硬件设备主要利用单一或少量生物特征要素是一个重大的突破，但是对于现有方法在采集数据时可能都会涉及到用户隐私，因此在未来的研究中要加强用户隐私保护[15]。<br>对于检测伪基站，主要包括在线检测和离线学习两部分．在线检测由若干单类SVM、神经网络等构成的异常检测器组成，对于其监控和数据分析确保都有着重要的价值[16]。<br>路由系统和域名系统的安全性是网络安全中最基本的要素，异常路由的检测是通过提取当前BGP更新消息的特征或时序特征，将当前流量识别为正常路由或异常路由，该问题可以抽象为机器学习二分类问题，是机器学习算法的基本应用[14]。<br>基于机器学习的域名检测模型的建立主要基于网络特征，对于新地址空间映射的恶意域名无法进行检测。域名分析系统从多个来源的已知的域名数据中提取了短期域名、域名的访问比例、不同IP地址的个数、不同国家的数量、共享IP的数量、不同TTL值的数量、域名的长度等行为特征进行模型训练，在进行异常检测，取得了一定的成效[17]。<br>4.总结<br>在现如今的大量网络安全数据背景下，机器学习的应用已经成为一种趋势，特别是最近比较火热的人工智能和深度学习，这些人工智能系统通常有权以自动方式进行推算和决策，而无需人工参与日常工作，减少了人力资源浪费。另外，其进行大规模分析以找到大海捞针中的众所周知的针头并不是一个挑战。机器学习可以模拟安全分析师的相同手动过程，通过使用强大的算法创建学习行为模式的模型，提供对异常或风险活动的自动分析。但是，它们也可能会受到损害，而且很长一段时间都无法检测到。其次，机器学习或人工智能程序进行特定扣减和决策的原因并不总是对监督者立即明确。意味着即使检测到违规，其目的也可能保持不透明。也会对系统造成损害，对于这方面的研究还需要投入更多精力。<br>参考文献<br>[1]周志华. 机器学习. 清华大学出版社, 北京, 2016. ISBN 978-7-302-206853-6.<br>[2]张夏.基于机器学习算法的网络入侵检测[J].现代电子技术,2018,41(03):124-127.<br>[3]朱琨,张琪.机器学习在网络入侵检测中的应用[J].数据采集与处理,2017,32(03):479-488.<br>[4]张蕾,崔勇,刘静,江勇,吴建平.机器学习在网络空间安全研究中的应用[J].计算机学报,2018,41(09):1943-1975.<br>[5] N. Lu, S. Mabu, T. Wang, and K. Hirasawa, “An Efficient Class Association Rule-Pruning Method for Unified Intrusion Detection System using Genetic Algorithm”, in IEEJ Transactions on Electrical and Electronic Engineering, Vol. 8, Issue 2, pp. 164 – 172, January 2, 2013.<br>[6]Rui Zhang and Quanyan Zhu. A Game -Theoretic Approach to Design Secure and Resilient Distributed Support Vector Machines [J]. arXiv:1802.02907v1 [stat.ML] Feb., 2018.<br>[7]陈萍.网络入侵检测系统的研究与实现[D].山东大学,2008.<br>[8]成汶洲,张亮.浅谈分布式入侵检测系统[J].企业科技与发展,2018(07):93-94.<br>[9]王秀英.分布式网络时序关联入侵攻击行为检测系统设计[J].现代电子技术,2018,41(03):107-110.<br>[10]闫友彪,陈元琰.机器学习的主要策略综述[J].计算机应用研究,2004,21(7):4-10.<br>[11]Habibi Lashkari A., Draper Gil G., Mamun M. and Ghorbani A., “Characterization of Tor Traffic using Time based Features,” Proceedings of the 3rd International Conference on Information Systems Security and Privacy – Volume 1, pages 253-262, 2017.<br>[12]陈瑞东,赵凌园,张小松.基于模糊聚类的僵尸网络识别技术[J].计算机工程,2018,44(10):46-50.<br>[13]金渝筌,谢彬,朱毅.基于通信相似度的僵尸网络节点检测方法[J].网络与信息安全学报,2018,4(10):31-38.<br>[14]刘国璧,袁宏俊.人工蜂群算法优化LS-SVM的预测模型[J].湖南文理学院学报(自然科学版),2018,30(02):27-29+94.<br>[15]王金海,陈泓宇,崔军,戴华林.生物特征识别系统安全加固方法[J].计算机工程与设计,2018,39(12):3661-3666.<br>[16]孙旭敏. 伪基站信息检测与识别算法研究[D].内蒙古大学,2018.<br>[17]蒋磊.BGP路由协议的基本原理分析[J].江苏科技信息,2018,35(31):35-37.<br>[18]殷聪贤. 基于大数据分析的恶意域名检测技术研究与实现[D].北京邮电大学,2018<br>[19]刘阚蓉,李丹,裴梦迪,张家熹.机器学习算法在网络入侵检测中的应用综述[J].赤峰学院学报(自然科学版),2018,34(12):44-46.<br>[20]张舒婷.机器学习在网络安全中的应用[J].电子技术与软件工程,2018(19):212.<br>[21]陈捷,丛键,张海燕.基于机器学习的行为分析技术在下一代智能化网络安全体系中的应用[J].通信技术,2018,51(08):1956-1960.<br>[22]马若龙. 基于卷积神经网络的未知和加密流量识别的研究与实现[D].北京邮电大学,2018.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;机器学习在网络安全中的应用综述&quot;&gt;&lt;a href=&quot;#机器学习在网络安全中的应用综述&quot; class=&quot;headerlink&quot; title=&quot;机器学习在网络安全中的应用综述&quot;&gt;&lt;/a&gt;机器学习在网络安全中的应用综述&lt;/h2&gt;&lt;p&gt;摘要：随着互联网人口在线人数的增长，在互联网背景下各行业爆发了很多问题，例如信息的加密和治理，可疑的营销信息，特别是网络安全问题不断的锐化。机器学习和人工智能的诞生，对网络发展既是机遇也是挑战，它用于搜索引擎，图像分类，语音识别等，而利用网络上的安全问题融合机器学习算法，成为网络安全技术的一个新的研究领域，利用机器学习得到的模型和方法，对网络安全攻击行为自动进行判断和预测，进而进行防御，是非常具有利用前景和使用价值，本文是对当前机器学习在网络安全中的不同应用进行总结和概述。&lt;br&gt;关键词：机器学习 网络安全 入侵防御&lt;br&gt;Abstract: with the growth of the number of Internet online population, in the context of the Internet industry broke out a lot of problems, such as the encryption and governance of information, suspicious marketing information, especially the sharpening of network security issues. The birth of machine learning and artificial intelligence, is both opportunity and challenge of network development, which is used to search engine, image classification, speech recognition, etc., and the use of machine learning algorithm on the network security problem fusion, become a new research field of network security technology, using machine learning model and method of judgment and projections for network security attacks automatically, and defend, is very has the advantage of future and use value, this article is for the current machine learning summarize its application in network security.&lt;br&gt;Key words: machine learning; network security; defense&lt;br&gt;
    
    </summary>
    
    
      <category term="network security" scheme="http://peisenli.github.io/tags/network-security/"/>
    
  </entry>
  
  <entry>
    <title>MPI Programming Project</title>
    <link href="http://peisenli.github.io/2019/05/11/MPI-Programming-Project/"/>
    <id>http://peisenli.github.io/2019/05/11/MPI-Programming-Project/</id>
    <published>2019-05-11T13:44:31.000Z</published>
    <updated>2019-07-13T10:53:48.149Z</updated>
    
    <content type="html"><![CDATA[<p>一、实验目的<br>1、掌握分布式并行计算基础<br>2、掌握MPI分布式并行基本操作<br>3、利用MPI进行程序设计，寻找1000000000以内的素数<br>二、实验环境<br>PC、Ubuntu16.04、MPICH<br>三、实验要求<br>Part 1: Modify the parallel Sieve of Eratosthenes program in class so that the program  does NOT set aside memory for even integers.<br><a id="more"></a><br>Part 2: Modify the parallel Sieve of Eratosthenes program in Part 1 so that each process of the program finds its own sieving primes via local computations instead of broadcasts.<br>四、实验步骤<br>1、在进行MPI程序设计之前确保Ubuntu、GCC环境可用之后再进行MPICH安装，如下所示安装GCC环境后确保正常。<br><img src="https://i.loli.net/2019/05/11/5cd6d2bbde6c0.png" alt="1.png"><br>2、进行MPI程序设计需要进行MPICH安装，直接使用sudo apt-get install –y mpich,如下图所示，已经安装完成。<br><img src="https://i.loli.net/2019/05/11/5cd6d2bb5e7b7.png" alt="图片1.png"><br>安装完成后进行MPI环境测试，确保正常使用，使用mpicc –v进行查看是否安装成功。<br><img src="https://i.loli.net/2019/05/11/5cd6d2bbeee22.png" alt="图片2.png"><br>3、使用老师所给的例程进行环境测试，进行编译运行，编译如下：<br><img src="https://i.loli.net/2019/05/11/5cd6d2bb9a97f.png" alt="图片3.png"><br>使用mpicc sieve0.c –o sieve0.o –lm命令后生成可执行文件sieve.o，使用mpirun –np 8 ./sieve.o 10000000000进行测试出现一下情况。<br><img src="https://i.loli.net/2019/05/11/5cd6d2bbb5feb.png" alt="图片4.png"><br>需要在使用此命令行时添加参数–allow-run-as-root后正常，环境安装完成。当改变参数时发现程序运行时间无多大变化，如下所示：<br><img src="https://i.loli.net/2019/05/11/5cd6d2bbb31a7.png" alt="图片5.png"><br>进行排查后发现自己的电脑的参数无法达到8进程所以使用4进程和8进程时间无多大区别，弄清自己PC的型号最大为4个进程再进行实验设计。<br><img src="https://i.loli.net/2019/05/11/5cd6d39d6f679.png" alt="图片6.png"><br>4、根据实验要求进行程序设计，完成Part1内容，预先对寻求素数中的偶数进行移除处理，不再为偶数进行计算。当移除偶数时，需要对每个进程中存取数组进行从新定义，每个进程的最低值和最高值如下所示：<br><img src="https://i.loli.net/2019/05/11/5cd6d39d71936.png" alt="图片7.png"><br>由于数据每个进程分配会出现不一致性，其处理方式如下所示：</p><pre><code>proc0_size = (n - 1) / p;if ((3 + 2*(proc0_size-1)) &lt; (int) sqrt((double) (3+2*(n-1)))) {  if (!id) printf (&quot;Too many processes\n&quot;);  MPI_Finalize();  exit (1);}</code></pre><p>Part1之中去除偶数之后在进程中进行计算的核心代码如下所示：<br><img src="https://i.loli.net/2019/05/11/5cd6d39d864d7.png" alt="图片8.png"><br>5、根据实验要求对Part2进行程序设计，其主要修改如下图所示，对每个进程的分配如下所示：<br><img src="https://i.loli.net/2019/05/11/5cd6d39d82ba9.png" alt="图片9.png"><br>在原来设计的基础之上不进行数据广播，需要进行进程本地内存使用保存数据，在每个进程中进行素数检查。<br><img src="https://i.loli.net/2019/05/11/5cd6d39d952df.png" alt="图片10.png"><br>6、根据具体的实验进行对比，完成MPI实验报告设计<br>五、实验结果<br>根据不同的实验方法进行程序设计，在具体的实验中得到实验结果，时间(s)效果如下所示：<br>|process     |Sieve0         |Part1            | Part2       |<br>| ——–   | —–:        | :—-:       | :—–:     |<br>|2             |209.828280     |108.456367    |343.496301   |<br>|4             |182.311808     |96.609751        |202.671327   |<br><img src="https://i.loli.net/2019/05/11/5cd6d39dbbfe0.png" alt="图片11.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、实验目的&lt;br&gt;1、掌握分布式并行计算基础&lt;br&gt;2、掌握MPI分布式并行基本操作&lt;br&gt;3、利用MPI进行程序设计，寻找1000000000以内的素数&lt;br&gt;二、实验环境&lt;br&gt;PC、Ubuntu16.04、MPICH&lt;br&gt;三、实验要求&lt;br&gt;Part 1: Modify the parallel Sieve of Eratosthenes program in class so that the program  does NOT set aside memory for even integers.&lt;br&gt;
    
    </summary>
    
    
      <category term="MPICH  分布式" scheme="http://peisenli.github.io/tags/MPICH-%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Chat based on Socket</title>
    <link href="http://peisenli.github.io/2019/05/11/Chat-based-on-Socket/"/>
    <id>http://peisenli.github.io/2019/05/11/Chat-based-on-Socket/</id>
    <published>2019-05-11T13:35:33.000Z</published>
    <updated>2019-07-13T10:53:48.147Z</updated>
    
    <content type="html"><![CDATA[<p>套接字库加载：<br>Socket socket=new Socket();<br>ServerSocket server=new ServerSocket();<br><a id="more"></a><br>套接字初始化：<br>客户端：</p><p>public void setUpNet(){</p><pre><code>    try{        Socket s=new Socket(ipInput.getText(),25003);        InputStreamReader StreamReader=new InputStreamReader(s.getInputStream());        reader=new BufferedReader(StreamReader);        writer=new PrintWriter(s.getOutputStream());        System.out.println(&quot;connect is vivasible!&quot;);        JOptionPane.showMessageDialog(null, &quot;连接成功&quot;);    }catch(IOException ex){        ex.printStackTrace();        JOptionPane.showMessageDialog(null, &quot;连接失败&quot;);    }}  </code></pre><p>服务端： </p><p>openServiceBtn.addActionListener(new ActionListener(){</p><pre><code>@Overridepublic void actionPerformed(ActionEvent e) {    // TODO Auto-generated method stub    try{        ServerSocket ss=new ServerSocket(25003);        while(true){            Socket s=ss.accept();            socketList.add(s);            final DataInputStream bufIn = new DataInputStream(                    s.getInputStream());            final BufferedOutputStream bufOut= new BufferedOutputStream(                    s.getOutputStream());            new Thread(new ServerThread(s)).start();            }    }catch(Exception e3){        JOptionPane.showConfirmDialog(null,&quot;&quot;);    }}});</code></pre><p>接收聊天内容线程：</p><p>public class ClientThread implements Runnable {</p><pre><code>@Overridepublic void run() {    // TODO Auto-generated method stub</code></pre><p>String content;<br>try{</p><pre><code>while((content=reader.readLine())!=null){    System.out.println(&quot;read:&quot;+content);    chatJText.append(content+&quot;\n&quot;);}</code></pre><p>}catch(Exception e){<br>    e.printStackTrace();<br>}<br>        }</p><pre><code>}</code></pre><p>聊天内容发送按钮：(类本身作为监听器)  </p><p>if(e.getSource()==sendBtn){<br>            try{<br>    //读取TextFiled中获取数据<br>        writer.println(nameInput.getText()+”说：”+inputTfd.getText());<br>        writer.flush();}<br>            catch(Exception ex){<br>                ex.printStackTrace();<br>            }<br>            inputTfd.setText(“”);<br>            inputTfd.requestFocus();<br>        }</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;套接字库加载：&lt;br&gt;Socket socket=new Socket();&lt;br&gt;ServerSocket server=new ServerSocket();&lt;br&gt;
    
    </summary>
    
    
      <category term="Socket" scheme="http://peisenli.github.io/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>手机通信录备份设计</title>
    <link href="http://peisenli.github.io/2019/05/10/%E6%89%8B%E6%9C%BA%E9%80%9A%E4%BF%A1%E5%BD%95%E5%A4%87%E4%BB%BD%E8%AE%BE%E8%AE%A1/"/>
    <id>http://peisenli.github.io/2019/05/10/手机通信录备份设计/</id>
    <published>2019-05-10T07:32:32.000Z</published>
    <updated>2019-07-13T10:53:48.151Z</updated>
    
    <content type="html"><![CDATA[<p>一、设计目的  </p><ol><li>利用课程所学知识进行面向对象程序设计，理解类、对象、封装等概念。  </li><li>熟练掌握C++程序设计  </li><li>学会使用UML分析  </li><li>完成手机通信录备份设计<a id="more"></a>       二、设计要求<br>手机通信录备份：  </li><li>实现可以将通信录备份到预先设定的服务器数据库中。  </li><li>数据库使用SQLite。  </li><li>同时备份到TF卡中。  </li><li>Android下通信部分用C++完成，界面用JAVA完成，之间采用JNI调用。  </li><li>需要有完整的设计文档。  </li></ol><p>三、设计需求<br>实验环境：Android Studio3.2、Linux服务器、SQLite<br>设计语言：C++、Java<br>四、设计步骤<br>在进行系统设计之前进行系统分析，确定人员分工，分工完成后进行通信录备份系统设计。  </p><p>1.安卓端设计<br>安卓端设计采用Android Studio3.2，设计使用的版本是Android6.0，根据设计要求首先需要进行本地文件备份，然后进行通信录数据上传到服务器中，界面包含两个Button按钮，两个TextView以及一个ListView，其中点击第一个Button按钮进行通信录数据读取后写入Txt文件并存入本地TF卡中，第二个Button按键将Txt文件通过网络通信传到服务器中，TextView用于显示备份状态，另外ListView显示上传的通信录信息，并显示是否通信成功，初始界面如下所示：<br>通信录读取过程主要是对安卓客户端的通信录的数据库进行读取，读取和写入TF卡都需要进行权限申请，注意Android6.0以上的权限需要进行动态申请。设计动态申请权限包括内存读写以及通信录读写。实现如下所示：<br><code>codes</code><br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST_EXTERNAL_STORAGE = <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String[] PERMISSIONS_STORAGE = &#123;  </span><br><span class="line">        <span class="string">"android.permission.READ_EXTERNAL_STORAGE"</span>,  </span><br><span class="line">        <span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>,  </span><br><span class="line">        <span class="string">"android.permission.READ_CONTACTS"</span>,  </span><br><span class="line">        <span class="string">"android.permission.WRITE_CONTACTS"</span>&#125;;  </span><br><span class="line"><span class="comment">//确定动态权限获取  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> verifyStoragePermissions(Activity activity) &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="comment">//检测是否有写的权限  </span></span><br><span class="line">        <span class="keyword">int</span> permission = ActivityCompat.checkSelfPermission(activity,  </span><br><span class="line">                <span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (permission != PackageManager.PERMISSION_GRANTED) &#123;  </span><br><span class="line">            <span class="comment">// 没有写的权限，去申请写的权限，会弹出对话框  </span></span><br><span class="line">            ActivityCompat.requestPermissions(activity, PERMISSIONS_STORAGE, REQUEST_EXTERNAL_STORAGE);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (ContextCompat.checkSelfPermission(context,android.Manifest.permission.READ_CONTACTS)  </span><br><span class="line">                !=PackageManager.PERMISSION_GRANTED) &#123;  </span><br><span class="line">            ActivityCompat.requestPermissions((Activity) context,  </span><br><span class="line">                    <span class="keyword">new</span> String[]&#123;android.Manifest.permission.READ_CONTACTS&#125;,  </span><br><span class="line">                    <span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">        e.printStackTrace();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//另外，在安卓中的XML文件AndroidManifest.xml也需要加入权限：  </span></span><br><span class="line">&lt;uses-permission <span class="string">android:</span>name=<span class="string">"android.permission.READ_CONTACTS"</span>/&gt;  </span><br><span class="line">&lt;uses-permission <span class="string">android:</span>name=<span class="string">"android.permission.WRITE_CONTACTS"</span>/&gt;  </span><br><span class="line">&lt;uses-permission <span class="string">android:</span>name=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;  </span><br><span class="line">&lt;uses-permission <span class="string">android:</span>name=<span class="string">"android.permission.INTERNET"</span></span><br></pre></td></tr></table></figure></p><p>Android手机的通讯录联系人全部都存在系统的数据库中，如果须要获得通讯里联系人的信息就须要访问系统的数据库，才能将信息拿出来。对数据库查询代码主要如下所示：<br><code>codes</code><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Cursor <span class="built_in">cursor</span> = context  </span><br><span class="line">        .getContentResolver()  </span><br><span class="line">        .query(ContactsContract.Data.CONTENT_URI,  </span><br><span class="line">                <span class="keyword">new</span> <span class="keyword">String</span>[]&#123;StructuredName.DISPLAY_NAME,  </span><br><span class="line">                       Data.RAW_CONTACT_ID&#125;, Data.MIMETYPE + <span class="string">"= ?"</span>,  </span><br><span class="line">                <span class="keyword">new</span> <span class="keyword">String</span>[]&#123;StructuredName.CONTENT_ITEM_TYPE&#125;, <span class="keyword">null</span>);  </span><br><span class="line"><span class="comment">// 得到电话号码的游标  </span></span><br><span class="line">Cursor mobileCursor = context.getContentResolver().query(  </span><br><span class="line">        ContactsContract.Data.CONTENT_URI,  </span><br><span class="line">        <span class="keyword">new</span> <span class="keyword">String</span>[]&#123;Phone.NUMBER&#125;,  </span><br><span class="line">        Data.RAW_CONTACT_ID + <span class="string">" = "</span> + id + <span class="string">" AND "</span> + Data.DATA2  </span><br><span class="line">                + <span class="string">" = "</span> + <span class="number">2</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);  </span><br><span class="line"><span class="keyword">String</span> mobileNum = <span class="string">""</span>;  </span><br><span class="line"><span class="keyword">if</span> (mobileCursor.moveToNext()) &#123;  </span><br><span class="line">    mobileNum = mobileCursor.getString(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">mobileCursor.close();  </span><br><span class="line"><span class="comment">// 得到家庭电话  </span></span><br><span class="line">Cursor homeCursor = context.getContentResolver().query(  </span><br><span class="line">        ContactsContract.Data.CONTENT_URI,  </span><br><span class="line">        <span class="keyword">new</span> <span class="keyword">String</span>[]&#123;Phone.NUMBER&#125;,  </span><br><span class="line">        Data.RAW_CONTACT_ID + <span class="string">" = "</span> + id + <span class="string">" AND "</span> + Data.DATA2  </span><br><span class="line">                + <span class="string">" = "</span> + <span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p><p>将读取到的文件进行本地存储，写入到TF卡，其权限在使用之前已经进行申请，其写入主要代码如下所示：<br>private void writeFile(String path, String info) {<br>    try {<br>        File file = new File(path);<br>        FileWriter writer = new FileWriter(file, false);<br>        writer.write(info);<br>        writer.close();<br>    } catch (IOException e) {<br>        e.printStackTrace();<br>    }<br>}  </p><p>2.JNI配置<br>JNI的全称就是Java Native Interface，顾名思义，就是Java和C/C++相互通信的接口，就好比买卖房子都需要找中介一样，这里的JNI就是Java和C/C++通信的中介，一个中间人。<br>首先创建JNI类：<br><img src="https://i.loli.net/2019/05/10/5cd52b25bb387.png" alt="图片1.png"><br>配置 Anroid Studio 外部工具，File-&gt;Setting-&gt;Tools-&gt;External Tools-&gt;“+”，进入配置，完成之后如下图所示，先配置Javah。<br><img src="https://i.loli.net/2019/05/10/5cd52bcab9ff0.png" alt="图片2.png"><br>以相同的方式配置ndk-build。配置完成之后如图所示：<br><img src="https://i.loli.net/2019/05/10/5cd52bcabc4c5.png" alt="图片3.png"><br>修改app下的build.gradle文件, 如下图所示：<br><img src="https://i.loli.net/2019/05/10/5cd52bcab194a.png" alt="图片4.png"><br>并在项目下的gradle.properties文件添加代码：android.useDeprecatedNdk=true 生成JNI程序文件，点击JNI类文件，开始生成.h文件，选中JNI类右键-&gt;New-&gt;External Tools-&gt;javah，文件生成后如下所示：<br><img src="https://i.loli.net/2019/05/10/5cd52bcabe481.png" alt="图片5.png"><br>选中JNI类右键-&gt;New-&gt;External Tools-&gt;ndk-build，结果如图：<br><img src="https://i.loli.net/2019/05/10/5cd52bcac0a06.png" alt="图片6.png"><br>生成.h文件之后,根据生成的接口进行程序设计，接口函数如下所示：<br><img src="https://i.loli.net/2019/05/10/5cd52d056329a.png" alt="图片12.png"><br>新建立一个C++文件，在其中加入通信部分相关代码：<br><img src="https://i.loli.net/2019/05/10/5cd52bcaf07c3.png" alt="图片7.png"></p><p>安卓端整个设计完毕，最后进行调试生成相应的App应用，进行测试和完善，完成整体的设计。<br>3.服务器配置<br>服务器使用C++进行程序设计，服务器采用Centos6.8，配置好GCC-C++、SQLite环境之后，客户端使用Socket接口进行访问。将通信录信息传递到服务后进行相应的处理，存入数据库。启动界面如下图所示：<br><img src="https://i.loli.net/2019/05/10/5cd52bcac29b2.png" alt="图片8.png"><br>服务器程序中数据库存储部分具体见通信部分。<br>4.系统设计UML图<br>用户打开安卓界面，安卓获取本机通讯录打包好将信息给C++接口程序，同时保存数据到SD卡；C++接口程序通过Socket连接远程服务器，上传数据；服务器端接收数据，并插入到本地数据库，UML如图所示：<br><img src="https://i.loli.net/2019/05/10/5cd52bcacdd51.png" alt="图片9.png"><br>五、实验结果<br>根据设计要求，完成相应的工作，并进行测试，当用户进行使用时，首先开启服务器端接收部分进行监听，当安卓客户端点击备份和上传时，测试结果如下所示，客户端显示如下：<br><img src="https://i.loli.net/2019/05/10/5cd52bcad11c7.png" alt="图片10.png"><br>服务器测试如下所示：<br><img src="https://i.loli.net/2019/05/10/5cd52bcac897a.png" alt="图片11.png"><br>六、设计总结<br>本次设计深入了解面向对象设计方法，学习了JNI相关知识以及UML的设计，对C++程序又了进一步的了解，设计有所不足，服务器未考虑到多用户并发数据备份，另外安卓客户端比较简单，需要更多的优化设计。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、设计目的  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用课程所学知识进行面向对象程序设计，理解类、对象、封装等概念。  &lt;/li&gt;
&lt;li&gt;熟练掌握C++程序设计  &lt;/li&gt;
&lt;li&gt;学会使用UML分析  &lt;/li&gt;
&lt;li&gt;完成手机通信录备份设计
    
    </summary>
    
    
      <category term="Android C++ JNI" scheme="http://peisenli.github.io/tags/Android-C-JNI/"/>
    
  </entry>
  
</feed>
