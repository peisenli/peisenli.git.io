<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title> | Paysonly</title><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><link rel="icon" href="/favicon.ico"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/"></div><div class="author-info__name text-center">Kong</div><div class="author-info__description text-center">非宁静无以致远，非淡泊无以明志</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">53</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">19</span></a></div></div></div><nav class="https://paysonly.oss-cn-chengdu.aliyuncs.com/img/qiuqiudazuozhan.jpg" id="nav" style="background-image: url(https://paysonly.oss-cn-chengdu.aliyuncs.com/img/qiuqiudazuozhan.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Paysonly</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">Paysonly</div><div id="site-sub-title"></div><div id="site-social-icons"> <a class="social-icon" href="https://github.com/peisenli" target="_blank"><i class="fa fa-github fab"></i></a><a class="social-icon" href="http://weibo.com/577991660" target="_blank"><i class="fa fa-weibo fab"></i></a><a class="social-icon" href="https://twitter.com/Peisen_CHN" target="_blank"><i class="fa fa-twitter fas"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item"><a class="article-title" href="/2019/07/13/Resume/">Resume</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-22 </time><div class="content"><div style="float:right"><img src="https://paysonly.oss-cn-chengdu.aliyuncs.com/img/P91019-181942.jpg" width="350"></div>   

<h4 id="PeisenLi"><a href="#PeisenLi" class="headerlink" title="PeisenLi"></a><span style="color:#e33a00"><strong>PeisenLi</strong></span></h4><p><strong>硕士/计算机科学与技术<br>本科/电子信息工程<br>Github：<a href="http://github.com/peisenli" target="_blank" rel="noopener">http://github.com/peisenli</a> </strong><br><strong>Skill：多项大学生创新创业项目及电子类全国大学生竞赛经验</strong></p>
<h6 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a><span style="color:#fd3300"><strong>联系方式</strong></span></h6><p><strong>Email：<a href="mailto:peisenli1@gmail.com" target="_blank" rel="noopener">peisenli1@gmail.com</a><br>QQ：577602601<br>电话：17628090959</strong><br></p></div><a class="more" href="/2019/07/13/Resume/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2020/10/07/Mysql日志系统/">Mysql日志系统</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-08 </time><div class="content"><h3 id="MySQL日志系统"><a href="#MySQL日志系统" class="headerlink" title="MySQL日志系统"></a>MySQL日志系统</h3><p><strong>重要的日志模块：redo log</strong></p>
<p>MySQL里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。</p>
<p>MySQL里经常说到的WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。</p>
<p>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p>
<p>InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p>
<p><img src="https://paysonly.oss-cn-chengdu.aliyuncs.com/img/20201007220317.png" alt="image-20201007220317"></p>
<p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
<p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p></div><a class="more" href="/2020/10/07/Mysql日志系统/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2020/10/07/Mysql基础框架/">Mysql基础框架</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-08 </time><div class="content"><h3 id="MySQL基础框架"><a href="#MySQL基础框架" class="headerlink" title="MySQL基础框架"></a>MySQL基础框架</h3><p>MySQL的基本架构示意图，从中可以清楚地看到SQL语句在MySQL的各个功能模块中的执行过程。</p>
<p><img src="https://paysonly.oss-cn-chengdu.aliyuncs.com/img/image-20201007194823058.png" alt="image-20201007194823058"></p>
<p>大体来说，MySQL可以分为Server层和存储引擎层两部分。</p>
<p><strong>Server层包括连接器、查询缓存、分析器、优化器、执行器等</strong>，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有<strong>跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等</strong>。</p></div><a class="more" href="/2020/10/07/Mysql基础框架/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2020/09/03/动态规划—-Leetcode74编辑距离/">动态规划—-Leetcode74编辑距离</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-03 </time><div class="content"><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ol>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ol>
<p><img src="https://paysonly.oss-cn-chengdu.aliyuncs.com/typora/image-20200903201410570.png" alt="image-20200903201410570"></p></div><a class="more" href="/2020/09/03/动态规划—-Leetcode74编辑距离/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2020/09/03/动态规划-leetcode64最小路径和/">动态规划-leetcode64最小路径和</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-03 </time><div class="content"><h3 id="动态规划：最小路径和"><a href="#动态规划：最小路径和" class="headerlink" title="动态规划：最小路径和"></a>动态规划：最小路径和</h3><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p><strong>示例:</strong></p>
<p>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 7<br>解释: 因为路径 1→3→1→1→1 的总和最小。</p>
<p><strong>题解</strong></p>
<p>由于路径的方向只能是向下或向右，因此网格的第一行的每个元素只能从左上角元素开始向右移动到达，网格的第一列的每个元素只能从左上角元素开始向下移动到达，此时的路径是唯一的，因此每个元素对应的最小路径和即为对应的路径上的数字总和。</p>
<p>对于不在第一行和第一列的元素，可以从其上方相邻元素向下移动一步到达，或者从其左方相邻元素向右移动一步到达，元素对应的最小路径和等于其上方相邻元素与其左方相邻元素两者对应的最小路径和中的最小值加上当前元素的值。由于每个元素对应的最小路径和与其相邻元素对应的最小路径和有关，因此可以使用动态规划求解。</p></div><a class="more" href="/2020/09/03/动态规划-leetcode64最小路径和/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2020/09/02/The-Problem-of-DP/">动态规划—Leetcode62</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-02 </time><div class="content"><center> 动态规划 </center>

<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p><img src="https://paysonly.oss-cn-chengdu.aliyuncs.com/img/image-20200902203905153.png" alt="image-20200902203905153"></p>
<p><strong>输入</strong>: m = 3, n = 2<br><strong>输出</strong>: 3<br><strong>解释</strong>:<br>从左上角开始，总共有 3 条路径可以到达右下角。</p>
<ol>
<li>向右 -&gt; 向右 -&gt; 向下</li>
<li>向右 -&gt; 向下 -&gt; 向右</li>
<li>向下 -&gt; 向右 -&gt; 向右</li>
</ol></div><a class="more" href="/2020/09/02/The-Problem-of-DP/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2020/08/20/Cpp核心编程一/">Cpp核心编程一</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-20 </time><div class="content"><h3 id="C-核心编程"><a href="#C-核心编程" class="headerlink" title="C++核心编程"></a>C++核心编程</h3><h4 id="1、内存分区模型"><a href="#1、内存分区模型" class="headerlink" title="1、内存分区模型"></a>1、内存分区模型</h4><p>C++程序执行程序时，将内存大方向划分为4个区域  </p>
<ul>
<li><p>代码区：存放函数的二进制代码，由操作系统进行管理的<br>存放CPU执行的机器指令，代码区是共享的，其目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。<br>内存区是只读的，防止程序意外地修改了他的指令。</p>
</li>
<li><p>全局区：存放全局变量、静态变量及常量<br>该区的数据在程序结束后由操作系统释放。</p>
</li>
<li><p>栈区：由编译器自动分配及释放，存放函数的参数值、局部变量等<br>Notice：不要返回局部变量的地址</p>
</li>
<li><p>堆区：有程序员分配和释放。若程序员不释放，程序结束由系统回收。<br>在C++中主要利用new在堆区开辟内存。<br>Eg:  </p>
<pre><code>int *p = new int(10);   //小括号创建一个变量  
int *arr = new int[10];   //中括号表示申请多个变量  
</code></pre><p>手动释放利用操作符delete。<br>Eg:    </p>
<pre><code>delete p;   
delete[] arr;  //释放数组
</code></pre></li>
</ul></div><a class="more" href="/2020/08/20/Cpp核心编程一/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/09/18/数据结构-归并排序/">数据结构-归并排序</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-18 </time><div class="content"><h3 id="归并排序和基数排序"><a href="#归并排序和基数排序" class="headerlink" title="归并排序和基数排序"></a>归并排序和基数排序</h3><p><strong>归并排序</strong>（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>
<ul>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列  </li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一序列的指针达到序列尾</li>
<li><p>将另一序列剩下的所有元素直接复制到合并序列尾，一次归并结束</p></li></ul></div><a class="more" href="/2019/09/18/数据结构-归并排序/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/09/18/数据结构-选择排序/">数据结构-选择排序</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-18 </time><div class="content"><h3 id="数据结构-选择排序"><a href="#数据结构-选择排序" class="headerlink" title="数据结构-选择排序"></a>数据结构-选择排序</h3><p><strong>选择排序</strong>（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。<br><strong>简单选择排序：</strong><br>该算法的实现思想为：对于具有 n 个记录的无序表遍历 n-1 次，第 i 次从无序表中第 i 个记录开始，找出后序关键字中最小的记录，然后放置在第 i 的位置上。<br>例如对无序表{56，12，80，91，20}采用简单选择排序算法进行排序，具体过程为：<br>第一次遍历时，从下标为 1 的位置即 56 开始，找出关键字值最小的记录 12，同下标为 0 的关键字 56 交换位置：<br>{12，56，80，91，20}<br>第二次遍历时，从下标为 2 的位置即 56 开始，找出最小值 20，同下标为 2 的关键字 56 互换位置：<br>{12，20，80，91，56}<br>第三次遍历时，从下标为 3 的位置即 80 开始，找出最小值 56，同下标为 3 的关键字 80 互换位置：<br>{12，20，56，91，80}<br>第四次遍历时，从下标为 4 的位置即 91 开始，找出最小是 80，同下标为 4 的关键字 91 互换位置：<br>{12，20，56，80，91}<br>到此简单选择排序算法完成，无序表变为有序表。<br></p></div><a class="more" href="/2019/09/18/数据结构-选择排序/#more">阅读更多</a><hr></div><div class="recent-post-item"><a class="article-title" href="/2019/09/18/数据结构-交换排序/">数据结构-交换排序</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-18 </time><div class="content"><h3 id="数据结构-交换排序"><a href="#数据结构-交换排序" class="headerlink" title="数据结构-交换排序"></a>数据结构-交换排序</h3><p>所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，交换排序的特点是：将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。<br><strong>冒泡排序（Bubble Sort）</strong>是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。<br>冒泡排序对n个项目需要O(n^2)的比较次数，且可以原地排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于包含大量的元素的数列排序是很没有效率的。<br>冒泡排序是与插入排序拥有相等的运行时间，但是两种算法在需要的交换次数却很大地不同。在最坏的情况，冒泡排序需要 O(n^2)次交换，而插入排序只要最多O(n)交换。冒泡排序的实现（类似下面）通常会对已经排序好的数列拙劣地运行O(n^2)，而插入排序在这个例子只需要O(n)个运算。因此很多现代的算法教科书避免使用冒泡排序，而用插入排序取代之。冒泡排序如果能在内部循环第一次运行时，使用一个旗标来表示有无需要交换的可能，也可以把最优情况下的复杂度降低到O(n)。在这个情况，已经排序好的数列就无交换的需要。若在每次走访数列时，把走访顺序反过来，也可以稍微地改进效率。有时候称为鸡尾酒排序，因为算法会从数列的一端到另一端之间穿梭往返。<br>冒泡排序算法的运作如下：  </p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p></li></ul></div><a class="more" href="/2019/09/18/数据结构-交换排序/#more">阅读更多</a><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">©2016 - 2021 By Kong</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span> |  </span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span> |  </span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/fancybox.js"></script><script src="/js/sidebar.js"></script><script src="/js/copy.js"></script><script src="/js/fireworks.js"></script><script src="/js/transition.js"></script><script src="/js/scroll.js"></script><script src="/js/head.js"></script></body></html>